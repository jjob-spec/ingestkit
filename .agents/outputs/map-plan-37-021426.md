---
issue: 37
agent: MAP-PLAN
date: 2026-02-14
complexity: SIMPLE
stack: backend
---

# MAP-PLAN: Issue #37 -- Layout Analysis for Multi-Column Detection

## Executive Summary

Implement `utils/layout_analysis.py`, a utility module that detects multi-column layouts in PDF pages via text block x-coordinate clustering and reorders text blocks into correct reading order. This module is called by the Complex Processor (Path C, SPEC 11.3 step 4) and its `is_multi_column` detection result feeds into the `PageProfile.is_multi_column` signal used by the Tier 1 Inspector (SPEC 9.2 signal 5). The implementation uses PyMuPDF's `page.get_text("blocks")` API and stdlib-only clustering (no scikit-learn dependency).

## Investigation Findings

### Spec Requirements

**SPEC 11.3 step 4 -- Multi-column handling:**
- Detect multi-column layouts via text block x-coordinate clustering.
- Reorder text blocks into correct reading order (left column first, then right column) before chunking.

**SPEC 2.3 -- Module listing:**
- `utils/layout_analysis.py` -- Multi-column detection, reading order.

**SPEC 9.2 -- Inspector signal 5:**
- `PageProfile.is_multi_column: bool` -- "detected via text block x-coordinate clustering" (line 330).
- Used by inspector to classify pages as complex when multi-column is detected.

**SPEC 11.1 step 2 (Path A fallback):**
- `page.get_text("blocks")` is the block-level extraction API (line 1042).

### PyMuPDF `get_text("blocks")` API

From existing code in `header_footer.py:75-76`:
```python
# get_text("blocks") returns (x0, y0, x1, y1, text, block_no, type)
blocks = page.get_text("blocks")
```

Each block is a tuple: `(x0, y0, x1, y1, text, block_no, block_type)` where:
- `x0, y0` = top-left corner coordinates
- `x1, y1` = bottom-right corner coordinates
- `text` = block text content (for text blocks)
- `block_no` = sequential block number
- `block_type` = 0 for text, 1 for image

### Integration Points

1. **PageProfile.is_multi_column** (`models.py:141`): Already exists as a `bool` field. The layout analyzer provides the detection logic to populate this field. Currently consumers (inspector) just read the field -- the parser or profile builder needs to call the layout analyzer.

2. **Complex Processor** (SPEC 11.3 step 4): Will call the layout analyzer to reorder text blocks before chunking. The module must return both the detection result AND the reordered blocks.

3. **Inspector** (`inspector.py:250`): Reads `page.is_multi_column` as signal 5. Does not call layout_analysis directly.

### Configuration

No layout-specific config fields exist in `config.py`. The SPEC does not specify configurable thresholds for column detection. The implementation should use sensible internal defaults:
- Minimum gap between columns (e.g., page_width * 0.05 = 5% of page width)
- Minimum number of text blocks to attempt clustering (e.g., 3)

No config changes are needed -- these are internal constants, consistent with the SPEC's silence on configurability.

### Existing Patterns

- Utils follow: module docstring referencing SPEC section, `from __future__ import annotations`, `TYPE_CHECKING` guard for `fitz`, logger under `ingestkit_pdf` namespace, config injected via constructor.
- `header_footer.py` demonstrates the block-level fitz API pattern used by this module.
- `heading_detector.py` demonstrates the `get_text("dict")` API for span-level access.
- Tests use `unittest.mock.MagicMock` for fitz objects, `@pytest.mark.unit` markers.

### Error Codes

No specific error code for layout analysis failure. Failures should be caught and logged, with the module returning a safe default (single-column, original block order). This is consistent with heading_detector.py's pattern of returning empty lists on failure.

## Implementation Plan

### File 1: `packages/ingestkit-pdf/src/ingestkit_pdf/utils/layout_analysis.py`

**Public API:**

```python
class LayoutAnalyzer:
    """Detect multi-column layouts and reorder text blocks for correct reading order.

    Parameters
    ----------
    config:
        Pipeline configuration (reserved for future layout thresholds).
    """

    def __init__(self, config: PDFProcessorConfig) -> None: ...

    def detect_columns(self, page: fitz.Page) -> LayoutResult: ...

    def reorder_blocks(
        self, blocks: list[TextBlock], layout: LayoutResult
    ) -> list[TextBlock]: ...
```

**Data classes (module-level, Pydantic models):**

```python
class TextBlock(BaseModel):
    """A positioned text block extracted from a PDF page."""
    x0: float
    y0: float
    x1: float
    y1: float
    text: str
    block_number: int

class LayoutResult(BaseModel):
    """Result of layout analysis for a single page."""
    is_multi_column: bool
    column_count: int          # 1, 2, or 3
    column_boundaries: list[tuple[float, float]]  # (x_start, x_end) per column
```

**Implementation Details:**

1. **`__init__(self, config)`** -- Store config (reserved for future use). Initialize logger `ingestkit_pdf.utils.layout_analysis`.

2. **`detect_columns(self, page)`**:
   - Extract text blocks via `page.get_text("blocks")`.
   - Filter to text blocks only (block_type == 0) with non-empty text.
   - If fewer than 3 text blocks, return single-column result immediately.
   - Get page width from `page.rect.width`.
   - Collect the x0 (left edge) coordinate of each text block.
   - Cluster x0 values using a gap-based algorithm:
     - Sort unique x0 values.
     - Find gaps larger than `page_width * 0.10` (10% of page width).
     - Number of clusters = number of gaps + 1, capped at 3.
   - Validate clusters: each cluster must contain at least 2 text blocks. Discard clusters with fewer.
   - If only 1 valid cluster, return single-column.
   - Compute column boundaries: for each cluster, `x_start` = min(x0) of blocks in cluster, `x_end` = max(x1) of blocks in cluster.
   - Handle mixed layouts (full-width header + columns): blocks whose width spans >75% of page width are classified as "full-width" and excluded from column clustering. These are placed before any columnar content in reading order.
   - Return `LayoutResult` with `is_multi_column`, `column_count`, and `column_boundaries`.

3. **`reorder_blocks(self, blocks, layout)`**:
   - If `layout.column_count == 1`, return blocks sorted by y0 (top-to-bottom).
   - Separate full-width blocks (width > 75% of page width based on column boundaries) from columnar blocks.
   - Assign each columnar block to a column based on its x0 midpoint falling within which column boundary range.
   - Sort each column's blocks by y0 (top-to-bottom).
   - Concatenate: full-width blocks first (sorted by y0), then column 1 blocks, then column 2 blocks, then column 3 blocks (if present).
   - Return the reordered list.

4. **Helper: `extract_text_blocks(page: fitz.Page) -> list[TextBlock]`** (module-level function):
   - Calls `page.get_text("blocks")`.
   - Filters to text blocks (type == 0) with non-empty stripped text.
   - Returns list of `TextBlock` objects.

5. **Clustering algorithm detail:**
   - Collect all x0 values from text blocks.
   - Sort them.
   - Compute gaps between consecutive sorted x0 values.
   - A "significant gap" is one larger than `min_column_gap = page_width * 0.10`.
   - Split the sorted x0 values at significant gaps to form clusters.
   - Each cluster represents one column.
   - This avoids any external dependency (no sklearn KMeans needed).

6. **Logging:** Logger name `ingestkit_pdf.utils.layout_analysis`. Log detection results at DEBUG (column count, boundaries). Log at WARNING if detection fails unexpectedly (return single-column default).

7. **Fail-safe:** All public methods wrapped in try/except. On any unexpected error, log warning and return single-column default. Never raise exceptions to caller.

### File 2: `packages/ingestkit-pdf/src/ingestkit_pdf/utils/__init__.py`

Add imports and re-exports:

```python
from ingestkit_pdf.utils.layout_analysis import LayoutAnalyzer, LayoutResult, TextBlock

__all__ = [
    ...,  # existing exports
    "LayoutAnalyzer",
    "LayoutResult",
    "TextBlock",
]
```

### File 3: `packages/ingestkit-pdf/tests/test_layout_analysis.py`

See test plan below.

## Test Plan

All tests are `@pytest.mark.unit`. No real PDFs or external services. Mock `fitz.Page` using `MagicMock`.

**Test helpers:**

```python
def _make_block(x0, y0, x1, y1, text, block_no=0):
    """Create a fitz-style block tuple: (x0, y0, x1, y1, text, block_no, type)."""
    return (x0, y0, x1, y1, text, block_no, 0)  # type 0 = text

def _make_mock_page(blocks, width=612.0, height=792.0):
    """Create a mock fitz.Page returning the given blocks."""
    page = MagicMock()
    page.get_text.return_value = blocks
    page.rect = MagicMock()
    page.rect.width = width
    page.rect.height = height
    return page
```

### Test Cases

**Single-column detection:**

| ID | Scenario | Blocks | Expected |
|----|----------|--------|----------|
| T1 | Single column, blocks aligned left | 5 blocks at x0=72 | `is_multi_column=False`, `column_count=1` |
| T2 | No text blocks (image-only page) | 0 text blocks | `is_multi_column=False`, `column_count=1` |
| T3 | Fewer than 3 text blocks | 2 blocks | `is_multi_column=False`, `column_count=1` |

**Two-column detection:**

| ID | Scenario | Blocks | Expected |
|----|----------|--------|----------|
| T4 | Classic two-column layout | 3 blocks at x0=72, 3 at x0=320 | `is_multi_column=True`, `column_count=2` |
| T5 | Two columns, unequal block count | 4 blocks left, 2 blocks right | `is_multi_column=True`, `column_count=2` |

**Three-column detection:**

| ID | Scenario | Blocks | Expected |
|----|----------|--------|----------|
| T6 | Three-column layout | 2 blocks each at x0=50, 220, 400 | `is_multi_column=True`, `column_count=3` |

**Mixed layout (full-width header + columns):**

| ID | Scenario | Blocks | Expected |
|----|----------|--------|----------|
| T7 | Full-width title + 2 columns | 1 block spanning 90% width, 4 blocks in 2 columns | `is_multi_column=True`, `column_count=2` |
| T8 | All blocks full-width | 3 blocks each spanning 80% of page | `is_multi_column=False`, `column_count=1` |

**Reading order (reorder_blocks):**

| ID | Scenario | Expected Order |
|----|----------|----------------|
| T9 | Two-column, 3 blocks each | Full-width (if any) first, then left col top-to-bottom, then right col top-to-bottom |
| T10 | Single column | Sorted by y0 (top to bottom) |
| T11 | Mixed: header + 2 columns | Header first, then left column, then right column |

**Edge cases:**

| ID | Scenario | Expected |
|----|----------|----------|
| T12 | Image blocks mixed with text blocks | Image blocks (type=1) filtered out |
| T13 | Empty text in text block | Block with whitespace-only text filtered out |
| T14 | Very narrow page (column gap too small) | Single column (gap threshold not met) |
| T15 | Blocks with overlapping x-ranges | Assigned to nearest column by midpoint |
| T16 | Exception in get_text | Returns single-column default, logs warning |

**Column boundaries:**

| ID | Scenario | Validation |
|----|----------|------------|
| T17 | Two-column, verify boundaries | `column_boundaries` contains 2 tuples, boundaries don't overlap |
| T18 | Three-column, verify boundaries | `column_boundaries` contains 3 tuples, sorted left-to-right |

## Acceptance Criteria

1. `LayoutAnalyzer.detect_columns()` correctly identifies single, two-column, and three-column layouts.
2. Detection uses text block x-coordinate clustering as specified in SPEC 11.3 step 4 and 9.2 signal 5.
3. `LayoutAnalyzer.reorder_blocks()` produces correct reading order: full-width content first, then left-to-right, top-to-bottom within each column.
4. Mixed layouts (full-width header + columns) are handled correctly.
5. Fewer than 3 text blocks returns single-column (no false positives on sparse pages).
6. Image blocks (block_type != 0) and empty text blocks are filtered out.
7. All methods are fail-safe: exceptions are caught, logged, and single-column default is returned.
8. `LayoutAnalyzer`, `LayoutResult`, and `TextBlock` are re-exported from `utils/__init__.py`.
9. All unit tests pass with `pytest packages/ingestkit-pdf/tests/test_layout_analysis.py -m unit`.
10. Tests use only mock `fitz.Page` objects -- no real PDFs.
11. Logger uses name `ingestkit_pdf.utils.layout_analysis`.
12. Module follows existing conventions: `from __future__ import annotations`, `TYPE_CHECKING` guard for fitz, Pydantic models for data classes.
13. No external clustering dependencies (stdlib-only gap-based algorithm).

## Risks / Edge Cases

- **False positive on indented text**: Paragraphs with varying indentation could be misclassified as multi-column. The 10% page-width gap threshold mitigates this since indentation is typically 2-5% of page width.
- **Narrow columns with close spacing**: If columns are very close together (gap < 10% of page width), they may be detected as single column. This is an acceptable conservative behavior (fail-safe to single column).
- **Right-to-left languages**: The current implementation assumes left-to-right reading order. This is acceptable per the SPEC which only specifies "left column first, then right column."
- **Blocks spanning column boundaries**: A text block whose x0 falls in one column but extends into another (e.g., a paragraph that wraps across columns in unusual formatting) is assigned by midpoint heuristic.
