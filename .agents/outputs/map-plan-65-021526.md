# MAP-PLAN: Issue #65 -- Implement Excel Cell Mapping Extraction

## 1. Investigation Summary

### Files Read

| File | Purpose | Key Findings |
|------|---------|--------------|
| `docs/specs/form-ingestor-plugin.md` (lines 829-865) | Spec section 7.3 | Complete algorithm for `extract_excel_cells()` -- cell/range resolution, merged cell handling, type coercion, confidence rules |
| `packages/ingestkit-forms/src/ingestkit_forms/extractors/native_pdf.py` | Pattern reference | Established extractor pattern: class with `__init__` (injected backends/config), `extract(file_path, template) -> list[ExtractedField]`, static helpers for coercion/validation |
| `packages/ingestkit-forms/src/ingestkit_forms/extractors/excel_cell.py` | Stub to implement | Currently only a docstring (6 lines). This is the target file. |
| `packages/ingestkit-forms/src/ingestkit_forms/models.py` | Data models | `CellAddress` (cell: str, sheet_name: str\|None), `FieldMapping` (field_id, field_name, field_label, field_type, cell_address, required, validation_pattern, default_value, options), `ExtractedField` (field_id, field_name, field_label, field_type, value, raw_value, confidence, extraction_method, bounding_box, validation_passed, warnings), `FieldType` enum (TEXT, NUMBER, DATE, CHECKBOX, RADIO, SIGNATURE, DROPDOWN), `FormTemplate` |
| `packages/ingestkit-forms/src/ingestkit_forms/errors.py` | Error codes | `FormErrorCode.W_FORM_MERGED_CELL_RESOLVED`, `W_FORM_FIELD_LOW_CONFIDENCE`, `W_FORM_FIELD_VALIDATION_FAILED`, `W_FORM_FIELD_MISSING_REQUIRED`, `W_FORM_FIELD_TYPE_COERCION`, `E_FORM_EXTRACTION_FAILED` |
| `packages/ingestkit-forms/src/ingestkit_forms/extractors/__init__.py` | Package init | Exports `NativePDFExtractor`, `OCROverlayExtractor`. Must add `ExcelCellExtractor`. |
| `packages/ingestkit-forms/src/ingestkit_forms/config.py` | Config | `FormProcessorConfig` with `log_sample_data`, `log_extraction_details` flags (PII safety). No Excel-specific config params needed. |
| `packages/ingestkit-forms/src/ingestkit_forms/protocols.py` | Backend protocols | No Excel-specific protocol needed -- openpyxl is used directly (it is a core dependency, not swappable). |
| `packages/ingestkit-forms/tests/conftest.py` | Test fixtures | `form_config` fixture, `make_field_mapping()`, `make_template()` factories. No Excel fixtures yet. |
| `packages/ingestkit-forms/tests/test_extractors.py` | Existing tests | Pattern: per-scenario tests with `@pytest.mark.unit`, mock backends, factory helpers. Tests for NativePDF and OCR overlay already here. |
| `packages/ingestkit-excel/src/ingestkit_excel/parser_chain.py` (grep) | openpyxl patterns | Uses `ws.merged_cells.ranges` to count merged cells, `openpyxl.load_workbook()` with `read_only=True` and `read_only=False` modes |

### Architecture Decision: No Protocol Needed

Unlike PDF and OCR extractors, the Excel cell extractor does **not** need a backend protocol. openpyxl is a direct, deterministic library dependency (no network calls, no engine swapping). The spec confirms this -- section 7.3 shows a plain function signature, not a protocol-based class. However, for consistency with the established extractor pattern (NativePDFExtractor, OCROverlayExtractor), we will implement it as a class `ExcelCellExtractor` with an `extract()` method accepting `(file_path, template)`.

## 2. Implementation Plan

### File 1: `packages/ingestkit-forms/src/ingestkit_forms/extractors/excel_cell.py`

**Action:** Replace stub with full implementation.

```python
class ExcelCellExtractor:
    """Extracts form field values from Excel files using cell address mappings.

    Uses openpyxl to read cell values from designated addresses defined
    in the FormTemplate (spec section 7.3).
    """

    def __init__(self, config: FormProcessorConfig) -> None:
        self._config = config

    def extract(self, file_path: str, template: FormTemplate) -> list[ExtractedField]:
        """Main entry point. Opens workbook, iterates template fields."""

    # Private helpers:
    def _read_cell_value(self, wb, field: FieldMapping) -> tuple[Any, str | None, list[str]]:
        """Resolve sheet, handle single cell vs range, handle merged cells."""

    def _resolve_merged_cell(self, ws, cell_coord: str) -> tuple[Any, bool]:
        """Check if cell is in a merged range; if so, read top-left. Returns (value, was_merged)."""

    def _read_range(self, ws, range_str: str) -> tuple[str, list[str]]:
        """Read all cells in range, join non-empty with newline. Returns (joined_value, warnings)."""

    @staticmethod
    def _coerce_value(raw_value: Any, field_type: FieldType) -> tuple[Any, list[str]]:
        """Type coercion per spec 7.3d."""

    @staticmethod
    def _validate_field_value(value, field: FieldMapping) -> tuple[Any, bool | None, list[str]]:
        """Regex validation (reuse same pattern as NativePDFExtractor._validate_field_value)."""
```

**Algorithm (from spec 7.3):**

1. `openpyxl.load_workbook(file_path, read_only=False, data_only=True)` -- `read_only=False` is required for merged cell access; `data_only=True` reads formula results.
2. For each field in `template.fields` where `field.cell_address is not None`:
   a. Resolve sheet: `wb[field.cell_address.sheet_name]` if specified, else `wb.active`.
   b. Parse cell address: if ":" in `cell` (range like "D5:D7"), use `_read_range()`. Otherwise single cell.
   c. For single cell: check merged ranges via `_resolve_merged_cell()`. If merged, emit `W_FORM_MERGED_CELL_RESOLVED`.
   d. Read raw value from cell.
   e. Type coercion via `_coerce_value()`:
      - `NUMBER`: `float(value)`, if fails -> `value=None`, emit `W_FORM_FIELD_TYPE_COERCION`
      - `DATE`: parse as `datetime` (openpyxl already returns datetime for date cells; handle string fallback), if fails -> `value=None`
      - `CHECKBOX`: `"X"`, `"x"`, `"Yes"`, `"TRUE"`, `1`, `True` -> `True`; empty/`"No"`/`"FALSE"`/`0`/`None`/`False` -> `False`
      - `TEXT`: `str(value).strip()`
      - `DROPDOWN`/`RADIO`: `str(value)` (same as TEXT)
      - `SIGNATURE`: not applicable for Excel, treat as TEXT
   f. Confidence:
      - Cell has non-empty value: `0.95`
      - Cell empty + field required: `0.0`, emit `W_FORM_FIELD_MISSING_REQUIRED`
      - Cell empty + field optional: `0.95`, `value = field.default_value`
   g. `extraction_method = "cell_mapping"`
3. Apply `validation_pattern` regex via `_validate_field_value()`.
4. Return `list[ExtractedField]`.

**Error handling:**
- If sheet_name not found in workbook: emit `E_FORM_EXTRACTION_FAILED` warning for that field, confidence=0.0, continue.
- If cell address is invalid: same pattern.
- Wrap entire workbook open in try/except for corrupt files: raise `FormIngestException` with `E_FORM_FILE_CORRUPT`.

### File 2: `packages/ingestkit-forms/src/ingestkit_forms/extractors/__init__.py`

**Action:** Add `ExcelCellExtractor` to imports and `__all__`.

```python
from ingestkit_forms.extractors.excel_cell import ExcelCellExtractor
__all__ = ["NativePDFExtractor", "OCROverlayExtractor", "ExcelCellExtractor"]
```

### File 3: `packages/ingestkit-forms/tests/test_extractors.py`

**Action:** Add Excel cell extraction test class at the end of file.

**Tests to add (following established pattern):**

| # | Test | What it verifies |
|---|------|-----------------|
| 1 | `test_extract_text_field_single_cell` | Single cell "B2" with text value -> ExtractedField with value, confidence=0.95, method="cell_mapping" |
| 2 | `test_extract_number_field_coercion` | Cell contains numeric string -> coerced to float |
| 3 | `test_extract_number_field_coercion_failure` | Cell contains "abc" for NUMBER field -> value=None, W_FORM_FIELD_TYPE_COERCION |
| 4 | `test_extract_date_field` | Cell contains datetime object -> returned as datetime |
| 5 | `test_extract_checkbox_true_values` | Parametrize: "X", "x", "Yes", "TRUE", 1, True -> True |
| 6 | `test_extract_checkbox_false_values` | Parametrize: None, "", "No", "FALSE", 0, False -> False |
| 7 | `test_extract_cell_range` | Range "D5:D7" with values -> joined with newline |
| 8 | `test_extract_cell_range_skips_empty` | Range with some empty cells -> only non-empty joined |
| 9 | `test_merged_cell_resolution` | Cell in merged range -> reads top-left, emits W_FORM_MERGED_CELL_RESOLVED |
| 10 | `test_empty_required_field` | Empty cell + required=True -> confidence=0.0, W_FORM_FIELD_MISSING_REQUIRED |
| 11 | `test_empty_optional_field` | Empty cell + required=False + default_value -> confidence=0.95, value=default |
| 12 | `test_validation_pattern_pass` | Value matches regex -> validation_passed=True |
| 13 | `test_validation_pattern_fail` | Value fails regex -> validation_passed=False, W_FORM_FIELD_VALIDATION_FAILED |
| 14 | `test_sheet_name_resolution` | Field with explicit sheet_name -> reads from that sheet |
| 15 | `test_sheet_name_not_found` | Invalid sheet_name -> value=None, confidence=0.0, warning |
| 16 | `test_multiple_fields_extraction` | Template with 3+ fields -> all extracted in order |
| 17 | `test_skips_pdf_fields` | Template mixing cell_address and region fields -> only cell_address fields processed |

**Mock strategy:** Use `unittest.mock.patch("openpyxl.load_workbook")` to return a mock Workbook with mock Worksheet(s). Mock worksheet provides:
- `ws[cell_coord]` -> mock Cell with `.value`
- `ws.merged_cells.ranges` -> list of `MergedCellRange` mocks
- `ws.iter_rows(min_row, max_row, min_col, max_col)` for range reads (or use `ws[range_str]` which returns tuple of tuples)

## 3. Dependency Summary

| Dependency | Status |
|-----------|--------|
| `openpyxl` | Already a core dependency in both ingestkit-excel and ingestkit-forms |
| `FormProcessorConfig` | Exists, no changes needed |
| `ExtractedField`, `FieldMapping`, `CellAddress`, `FieldType`, `FormTemplate` | All exist in models.py |
| `FormErrorCode` | All needed codes exist: `W_FORM_MERGED_CELL_RESOLVED`, `W_FORM_FIELD_LOW_CONFIDENCE`, `W_FORM_FIELD_VALIDATION_FAILED`, `W_FORM_FIELD_MISSING_REQUIRED`, `W_FORM_FIELD_TYPE_COERCION`, `E_FORM_EXTRACTION_FAILED` |

## 4. Risk Assessment

| Risk | Mitigation |
|------|-----------|
| openpyxl's merged cell API: `ws.merged_cells.ranges` returns `MergedCellRange` objects that have `.coord` property and containment check | Verify by reading openpyxl docs; use `cell_coord in merged_range` pattern from ingestkit-excel splitter |
| Cell range parsing: "D5:D7" needs to be parsed into row/col bounds | Use `openpyxl.utils.range_boundaries()` or `ws[range_str]` which returns a tuple of row tuples |
| `data_only=True` returns None for cells with formulas if the file wasn't saved with cached values | Document this behavior; confidence=0.95 for empty optional, 0.0 for empty required handles it correctly |
| DATE coercion: openpyxl may return datetime objects directly for date-formatted cells | Check `isinstance(value, datetime)` before attempting string parse |

## 5. Files Changed Summary

| File | Action | Lines (est.) |
|------|--------|-------------|
| `packages/ingestkit-forms/src/ingestkit_forms/extractors/excel_cell.py` | Replace stub | ~180 |
| `packages/ingestkit-forms/src/ingestkit_forms/extractors/__init__.py` | Add import + export | +2 |
| `packages/ingestkit-forms/tests/test_extractors.py` | Add test class | ~250 |

**Total estimated: ~430 lines**

AGENT_RETURN: .agents/outputs/map-plan-65-021526.md
