---
issue: 9
title: "Implement Path B text serializer (Backend)"
agent: plan
timestamp: 2026-02-12
status: complete
branch: feature/issue-9-path-b-serializer
complexity: COMPLEX
stack: backend
files_to_create:
  - packages/ingestkit-excel/src/ingestkit_excel/processors/serializer.py
  - packages/ingestkit-excel/tests/test_serializer.py
files_to_modify:
  - packages/ingestkit-excel/src/ingestkit_excel/processors/__init__.py
  - packages/ingestkit-excel/src/ingestkit_excel/__init__.py
---

# PLAN: Issue #9 -- Path B Text Serializer

## Executive Summary

Implement `TextSerializer` in `processors/serializer.py` to process Type B formatted-document Excel files. The class detects logical sections in worksheets using openpyxl (merged headers, blank row separators, indentation), classifies each section's sub-structure (small_table, checklist, matrix, free_text), serializes sections into natural language chunks, embeds them, and upserts to a vector store. Follows the same structural pattern as Path A's `StructuredDBProcessor` but without any `StructuredDBBackend` dependency.

## File 1: `processors/serializer.py` (CREATE)

**Full path:** `packages/ingestkit-excel/src/ingestkit_excel/processors/serializer.py`

### 1.1 Imports and Module Setup

Standard imports: `hashlib`, `logging`, `time`, `uuid`, `dataclasses.dataclass`, `pathlib.Path`, `openpyxl`. From `ingestkit_excel`: `ExcelProcessorConfig`, `ErrorCode`, `IngestError`, `ChunkMetadata`, `ChunkPayload`, `ClassificationResult`, `ClassificationStageResult`, `EmbedStageResult`, `FileProfile`, `IngestionMethod`, `ParseStageResult`, `ProcessingResult`, `SheetProfile`, `WrittenArtifacts`, `EmbeddingBackend`, `VectorStoreBackend`. Logger: `logging.getLogger(__name__)`.

### 1.2 Internal `Section` Dataclass

```python
@dataclass
class Section:
    """A detected logical section within a worksheet."""
    title: str
    sub_structure: str  # "table", "checklist", "matrix", "free_text"
    rows: list[list]    # raw cell values, one list per row
    start_row: int
    end_row: int
    col_count: int
    header_row: list[str] | None = None
```

Internal only, not exported. Valid `sub_structure` values: `"table"`, `"checklist"`, `"matrix"`, `"free_text"`.

### 1.3 Constructor

Takes `(vector_store: VectorStoreBackend, embedder: EmbeddingBackend, config: ExcelProcessorConfig)`. No `StructuredDBBackend` -- Path B writes only to vector store. Stores as `self._vector_store`, `self._embedder`, `self._config`.

### 1.4 `process()` Method

**Signature** -- follows reconciled Path A pattern (MAP section 4.2):

```python
def process(self, file_path: str, profile: FileProfile, ingest_key: str,
            ingest_run_id: str, parse_result: ParseStageResult,
            classification_result: ClassificationStageResult,
            classification: ClassificationResult) -> ProcessingResult:
```

**Algorithm** (mirrors Path A `structured_db.py:129-341`):

1. `start_time = time.monotonic()`
2. `source_uri = f"file://{Path(file_path).resolve().as_posix()}"`
3. Initialize `errors: list[str]`, `warnings: list[str]`, `error_details: list[IngestError]`
4. `written = WrittenArtifacts(vector_collection=config.default_collection)`
5. `self._vector_store.ensure_collection(collection, self._embedder.dimension())`
6. `wb = openpyxl.load_workbook(file_path, data_only=True)`
7. `chunk_index_counter = 0`, `total_chunks = 0`, `total_texts_embedded = 0`, `embed_duration = 0.0`
8. Per-sheet loop with skip logic (identical to Path A lines 154-171):
   - Hidden -> `W_SHEET_SKIPPED_HIDDEN`
   - Chart-only (row_count==0 and col_count==0) -> `W_SHEET_SKIPPED_CHART`
   - Oversized (row_count > max_rows_in_memory) -> `W_ROWS_TRUNCATED`
9. Per-sheet try/except:
   - `ws = wb[sheet.name]`
   - `sections = self._detect_sections(ws, sheet)`
   - For each section: serialize text, compute `chunk_hash = sha256(text)`, build `ChunkPayload` with placeholder vector `[]`, collect into `sheet_chunks` list
   - Embed `sheet_chunks` in batches of `config.embedding_batch_size`:
     - `vectors = self._embedder.embed(texts, timeout=config.backend_timeout_seconds)`
     - Assign vectors, upsert batch, track `written.vector_point_ids`
   - Increment `chunk_index_counter` and `total_chunks`
10. On exception: `_classify_backend_error(exc)`, append to errors/error_details, log, continue
11. `wb.close()`
12. Build `EmbedStageResult` if `total_texts_embedded > 0`
13. Return `ProcessingResult` with:
    - `ingestion_method=IngestionMethod.TEXT_SERIALIZATION` (enum member, NOT string)
    - `tables_created=0`, `tables=[]`
    - `written.db_table_names=[]`

### 1.5 `_detect_sections(ws, sheet) -> list[Section]`

**Algorithm:**

1. **Read all rows**: `all_rows = [[cell.value for cell in row] for row in ws.iter_rows()]`
2. **Build merged cell map** from `ws.merged_cells.ranges`:
   - For each `MergedCellRange`, record the min_row, min_col, max_row, max_col and the span width (max_col - min_col + 1).
   - Store as dict: `merged_headers[row_idx] = (value, span_width)` for rows where a merge spans 2+ columns.
3. **Scan rows top-to-bottom** to find boundaries:
   - A row is a **blank separator** if all cells are `None` or empty string.
   - A row is a **merged header** if it appears in `merged_headers` dict with a non-empty value.
   - 1+ blank rows after non-blank content marks a section boundary.
   - A merged header row marks the start of a new section (its value becomes section title).
4. **Split into sections**:
   - Title: merged header value > first non-empty cell in first row > `"Section N"` fallback.
   - Rows: non-blank data rows (excluding blank separators and merged header title row).
   - `start_row`/`end_row`: 1-based row numbers for provenance.
   - `col_count`: max number of columns across the section's rows.
5. **Classify sub-structure** for each section via `_classify_sub_structure()`.
6. **Edge cases**: no boundaries -> single section titled from sheet name; empty sections dropped.

### 1.6 `_classify_sub_structure(section) -> str` (static)

Returns `"table"`, `"checklist"`, `"matrix"`, or `"free_text"`.

1. If < 2 data rows -> `"free_text"` immediately.
2. **Checklist** (highest priority): examine first row for status keywords (`{"status", "done", "complete", "pending", "checked", "yes", "no"}`). If a header column matches (case-insensitive) AND section has item data -> `"checklist"`.
3. **Matrix**: col 0 has non-empty values in rows 2+ (row headers), row 0 has non-empty values in cols 2+ (column headers), intersection cells populated -> `"matrix"`.
4. **Table**: first row looks like a header (distinct string values, not all numeric), subsequent rows have consistent column usage (>50% columns populated in >50% rows) -> `"table"`.
5. Default: `"free_text"` (fail-closed).

Also sets `section.header_row` for table/checklist types from the first row values.

### 1.7 Serialization Methods

**`_serialize_section(section) -> str`**: Dispatches to sub-type serializer based on `section.sub_structure`.

**`_serialize_table(section) -> str`** (static):
- Format: `"In section '{title}', {col} is {val}, {col} is {val}."`
- Uses `section.header_row` for column names (fallback: `"Column N"`).
- None values -> "N/A". One sentence per data row, joined with newline.

**`_serialize_checklist(section) -> str`** (static):
- Format (SPEC line 754): `"Item X: status is Y, due date is Z, responsible party is W."`
- Identify column roles from header:
  - **Item**: first text-heavy column (not status/date).
  - **Status**: column matching status keywords.
  - **Date**: column with "date"/"due" in header.
  - **Responsible**: column with "responsible"/"owner"/"assigned" in header.
- Missing roles omitted from sentence. One sentence per data row.

**`_serialize_matrix(section) -> str`** (static):
- Format: `"For {row_header}, {col_header} is {value}."`
- Column headers from row 0 (cols 1+). Row headers from col 0 (rows 1+).
- One sentence per non-empty intersection cell. Skip None values.

**`_serialize_free_text(section) -> str`** (static):
- Join non-empty cells per row with space.
- Join rows with double newline (paragraph breaks).
- Prepend title if present: `"{title}\n\n{content}"`.

### 1.8 `_classify_backend_error(exc) -> ErrorCode` (static)

Same pattern as Path A (`structured_db.py:537-558`):
- "timeout" in message -> `E_BACKEND_EMBED_TIMEOUT` or `E_BACKEND_VECTOR_TIMEOUT`
- "connect" in message -> `E_BACKEND_EMBED_CONNECT` or `E_BACKEND_VECTOR_CONNECT`
- Default -> `E_PROCESS_SERIALIZE` (NOT `E_PROCESS_SCHEMA_GEN`)
- No DB-related error codes (Path B has no StructuredDBBackend)

### 1.9 ChunkMetadata Construction

```python
ChunkMetadata(
    source_uri=source_uri, source_format="xlsx", sheet_name=sheet.name,
    region_id=None,
    ingestion_method=IngestionMethod.TEXT_SERIALIZATION.value,  # "text_serialization"
    parser_used=sheet.parser_used.value,
    parser_version=config.parser_version,
    chunk_index=chunk_index_counter, chunk_hash=chunk_hash,
    ingest_key=ingest_key, ingest_run_id=ingest_run_id,
    tenant_id=config.tenant_id,
    table_name=None, db_uri=None, row_count=None, columns=None,
    section_title=section.title,
    original_structure=section.sub_structure,
)
```

Chunk ID: `str(uuid5(NAMESPACE_URL, f"{ingest_key}:{sha256(text)}"))` -- same deterministic pattern as Path A.

## File 2: `processors/__init__.py` (MODIFY)

**Full path:** `packages/ingestkit-excel/src/ingestkit_excel/processors/__init__.py`

Add `TextSerializer` import and export:

```python
from ingestkit_excel.processors.serializer import TextSerializer
from ingestkit_excel.processors.structured_db import StructuredDBProcessor

__all__ = ["StructuredDBProcessor", "TextSerializer"]
```

## File 3: `__init__.py` (MODIFY)

**Full path:** `packages/ingestkit-excel/src/ingestkit_excel/__init__.py`

1. Add import after line 33: `from ingestkit_excel.processors import TextSerializer`
2. Add `"TextSerializer"` to `__all__` after `"StructuredDBProcessor"` (line 71).

## File 4: `tests/test_serializer.py` (CREATE)

**Full path:** `packages/ingestkit-excel/tests/test_serializer.py`

### 4.1 Test Infrastructure

**Mock backends:** Copy `MockVectorStore` and `MockEmbedder` from `test_structured_db.py` (test files must be self-contained). No `MockStructuredDB` needed for Path B.

**Factory functions:** Create Path B-specific versions:
- `_make_sheet_profile(**overrides)` -- defaults with `merged_cell_count=5`, `merged_cell_ratio=0.1`
- `_make_file_profile(sheets, **overrides)` -- same pattern as Path A
- `_make_parse_result(**overrides)` -- same as Path A
- `_make_classification_stage_result(**overrides)` -- default `FileType.FORMATTED_DOCUMENT`
- `_make_classification_result(**overrides)` -- default `FileType.FORMATTED_DOCUMENT`

**openpyxl mock pattern:** Patch `ingestkit_excel.processors.serializer.openpyxl.load_workbook`. Build mock worksheet with:
- `ws.merged_cells.ranges` -- list of mock `MergedCellRange` objects
- `ws.iter_rows()` -- returns mock rows with mock cells having `.value` attribute
- Helper: `_make_mock_workbook(sheets_data)` that returns a configured mock workbook

### 4.2 Test Cases (44 tests, 9 classes)

**`TestSectionDetection`** (6 tests):
1. `test_blank_row_splits_sections` -- two data blocks separated by blank rows -> 2 sections
2. `test_merged_header_creates_section` -- merged cell row starts new section with that title
3. `test_no_boundaries_single_section` -- no blank rows or merged headers -> 1 section
4. `test_empty_sheet_produces_no_sections` -- all blank -> no sections
5. `test_section_title_from_merged_cell` -- title from merged cell value
6. `test_section_title_fallback_numbering` -- no clear title -> "Section N"

**`TestSubStructureClassification`** (5 tests):
7. `test_classify_checklist` -- status column -> "checklist"
8. `test_classify_matrix` -- row+col headers -> "matrix"
9. `test_classify_table` -- consistent header+data -> "table"
10. `test_classify_free_text_default` -- ambiguous -> "free_text"
11. `test_classify_few_rows_defaults_free_text` -- <2 rows -> "free_text"

**`TestSerializationFormats`** (5 tests):
12. `test_serialize_checklist_format` -- matches "Item X: status is Y, due date is Z..."
13. `test_serialize_matrix_format` -- matches "For {row_header}, {col_header} is {value}."
14. `test_serialize_table_format` -- matches "In section '{title}', {col} is {val}..."
15. `test_serialize_free_text_preserves_paragraphs` -- double newlines between rows
16. `test_serialize_handles_none_values` -- None -> "N/A" or skipped

**`TestMergedCellHandling`** (2 tests):
17. `test_merged_cells_detected_from_openpyxl` -- ranges parsed correctly
18. `test_merged_header_value_used_as_title` -- merged value becomes section title

**`TestChunkMetadata`** (7 tests):
19. `test_metadata_ingestion_method` -- == "text_serialization"
20. `test_metadata_section_title_populated` -- set from section
21. `test_metadata_original_structure_populated` -- set from sub-structure
22. `test_metadata_no_table_fields` -- table_name/db_uri are None
23. `test_metadata_tenant_id_propagated` -- from config
24. `test_metadata_source_uri_format` -- starts with "file://"
25. `test_metadata_parser_used` -- matches sheet.parser_used.value

**`TestProcessFlow`** (7 tests):
26. `test_process_single_sheet_happy_path`
27. `test_process_result_ingestion_method` -- == IngestionMethod.TEXT_SERIALIZATION
28. `test_process_tables_created_zero` -- tables_created=0, tables=[]
29. `test_process_written_artifacts_no_db_tables` -- db_table_names=[]
30. `test_process_written_artifacts_vector_ids_populated`
31. `test_process_embed_result_populated`
32. `test_process_chunk_ids_deterministic`

**`TestMultiSheet`** (2 tests):
33. `test_process_multi_sheet_chunk_index_global`
34. `test_process_multi_sheet_different_structures`

**`TestSheetSkipping`** (4 tests):
35. `test_process_skips_hidden_sheet` -- W_SHEET_SKIPPED_HIDDEN
36. `test_process_skips_chart_only_sheet` -- W_SHEET_SKIPPED_CHART
37. `test_process_skips_oversized_sheet` -- W_ROWS_TRUNCATED
38. `test_process_all_sheets_skipped_empty_result`

**`TestErrorHandling`** (5 tests):
39. `test_process_sheet_error_continues`
40. `test_process_error_recorded_in_details` -- stage="process", sheet_name correct
41. `test_classify_backend_error_timeout`
42. `test_classify_backend_error_connect`
43. `test_classify_backend_error_default` -- E_PROCESS_SERIALIZE

**`TestEmbeddingBatching`** (1 test):
44. `test_embedding_respects_batch_size`

## Acceptance Criteria

- [ ] `TextSerializer` class with constructor `(vector_store, embedder, config)` -- no DB backend
- [ ] `process()` signature matches Path A reconciled pattern (8 params)
- [ ] Section detection: merged headers, blank row separators
- [ ] Sub-structure classification: table, checklist, matrix, free_text
- [ ] Serialization formats match SPEC exactly (checklist/matrix/table/free_text)
- [ ] ChunkMetadata: `section_title`, `original_structure`, `ingestion_method="text_serialization"`
- [ ] Result: `tables_created=0`, `tables=[]`, `written.db_table_names=[]`
- [ ] Deterministic chunk IDs via UUID5
- [ ] Embedding batch pattern matches Path A
- [ ] Per-sheet error handling with continue (fail-closed)
- [ ] Error default: `E_PROCESS_SERIALIZE`
- [ ] Sheet skipping: hidden, chart-only, oversized
- [ ] `tenant_id` propagation from config to ChunkMetadata
- [ ] Exported from `processors/__init__.py` and package `__init__.py`
- [ ] All 44 unit tests pass with mock backends, no external services
- [ ] No regressions in existing tests

## Verification Gates

```bash
pytest packages/ingestkit-excel/tests -v
pytest packages/ingestkit-excel/tests/test_serializer.py -v
pytest packages/ingestkit-excel/tests/test_structured_db.py -v
python -c "from ingestkit_excel import TextSerializer; print('OK')"
pytest packages/ingestkit-excel/tests/test_serializer.py --cov=ingestkit_excel.processors.serializer --cov-report=term-missing
```

## Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| Reconciled 8-param process signature | `ProcessingResult` requires parse/classification fields |
| openpyxl direct (not pandas) | Spec requires merged cell preservation; pandas drops merge info |
| Default to `"free_text"` | Fail-closed principle from CLAUDE.md |
| `E_PROCESS_SERIALIZE` default error | Path B specific; `E_PROCESS_SCHEMA_GEN` is Path A only |
| Independent mock backends in test | Test files must be self-contained |
| Internal `Section` dataclass | Not exported; implementation detail for section detection |
| One chunk per section | Clean 1:1 metadata mapping; keeps provenance traceable |
| `wb.close()` after processing | Prevent file handle leaks |

---

AGENT_RETURN: plan-9-021226.md
