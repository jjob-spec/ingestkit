---
issue: 70
agent: PLAN
date: 2026-02-15
complexity: COMPLEX
package: ingestkit-forms
spec_sections: "13, 13.1-13.5"
map_artifact: map-70-021526.md
files_to_create: 2
files_to_modify: 5
---

# PLAN: Issue #70 -- Implement security controls and input validation

## Executive Summary

This plan implements the missing ~40% of security controls for `ingestkit-forms` per spec section 13. The work is organized into four tasks: (1) create `security.py` with a centralized `FormSecurityScanner` class for file size, extension, and magic byte validation, plus a shared `regex_match_with_timeout` utility; (2) add template field count limits in `models.py`; (3) add regex compilation validation in `api.py` at template creation/update time; (4) refactor duplicated regex timeout code from two extractors to import from `security.py`. A comprehensive `test_security.py` covers all seven test requirements from spec section 13.5.

## Acceptance Criteria

- [ ] AC1: Files exceeding `max_file_size_mb` are rejected with `E_FORM_FILE_TOO_LARGE` before processing
- [ ] AC2: File extension whitelist enforced (`.pdf`, `.xlsx`, `.jpg`, `.jpeg`, `.png`, `.tiff`, `.tif`)
- [ ] AC3: Magic byte verification for all five format families (PDF, XLSX, JPEG, PNG, TIFF)
- [ ] AC4: Templates with >200 fields rejected with `E_FORM_TEMPLATE_INVALID`
- [ ] AC5: Invalid regex patterns rejected at template creation/update with `E_FORM_TEMPLATE_INVALID`
- [ ] AC6: `regex_match_with_timeout` consolidated into `security.py`, both extractors import from there
- [ ] AC7: `FormSecurityScanner` exported from `__init__.py`
- [ ] AC8: All seven spec 13.5 test cases pass in `test_security.py`
- [ ] AC9: Existing tests remain green (no regressions from refactor)

## Task 1: Create `security.py` (NEW FILE)

**File**: `packages/ingestkit-forms/src/ingestkit_forms/security.py`
**Pattern**: Follow `ingestkit-pdf/security.py` (302 lines) -- scanner class returning `(metadata_or_none, list[FormIngestError])`

### 1.1 Module-level constants

```python
# Magic byte signatures
_MAGIC_BYTES = {
    ".pdf": (b"%PDF-", 5),
    ".xlsx": (b"PK\x03\x04", 4),      # ZIP container
    ".jpg": (b"\xff\xd8\xff", 3),
    ".jpeg": (b"\xff\xd8\xff", 3),
    ".png": (b"\x89PNG\r\n\x1a\n", 8),
    ".tiff": None,  # special: two variants
    ".tif": None,
}
_TIFF_MAGIC_LE = b"II\x2a\x00"  # little-endian
_TIFF_MAGIC_BE = b"MM\x00\x2a"  # big-endian

_ALLOWED_EXTENSIONS = frozenset(_MAGIC_BYTES.keys())
_REGEX_TIMEOUT_SECONDS = 1.0
```

### 1.2 `FormSecurityScanner` class

Constructor takes `FormProcessorConfig`. Single public method `scan(file_path: str) -> list[FormIngestError]`.

Checks run in this order (fail-fast, each returns early on fatal error):

1. **Extension whitelist**: Extract suffix via `pathlib.Path(file_path).suffix.lower()`. If not in `_ALLOWED_EXTENSIONS`, append `E_FORM_UNSUPPORTED_FORMAT` error and return.

2. **File size check**: `os.path.getsize(file_path)` vs `config.max_file_size_mb * 1024 * 1024`. If exceeded, append `E_FORM_FILE_TOO_LARGE` error and return.

3. **Magic byte verification**: Read first N bytes (max 8). Compare against expected magic for the extension. For TIFF, check both endianness variants. If mismatch, append `E_FORM_FILE_CORRUPT` error and return.

Return type is `list[FormIngestError]` (not a tuple with metadata -- forms don't have a DocumentMetadata equivalent). Fatal errors have `E_` prefix codes; caller checks `any(e.code.value.startswith("E_") for e in errors)`.

### 1.3 `regex_match_with_timeout` function (module-level)

Consolidate the two implementations. Use `re.fullmatch` (matches the Excel extractor's stricter semantics -- the OCR extractor uses `re.match` which is less strict, but the spec says "validation patterns" which implies full match). Accept a `match_mode` parameter defaulting to `"fullmatch"` with `"match"` as alternative, so both call sites can preserve their current behavior.

```python
def regex_match_with_timeout(
    pattern: str,
    value: str,
    timeout: float = _REGEX_TIMEOUT_SECONDS,
    *,
    match_mode: str = "fullmatch",
) -> bool | None:
```

### 1.4 `validate_regex_pattern` function (module-level)

Compile-time validation for template creation. Attempts `re.compile(pattern)` and returns `None` on success or the error message string on failure.

```python
def validate_regex_pattern(pattern: str) -> str | None:
    """Return None if valid, else error description string."""
```

**Estimated size**: ~120-140 lines.

## Task 2: Add field count limit in `models.py`

**File**: `packages/ingestkit-forms/src/ingestkit_forms/models.py`

### 2.1 `FormTemplate.fields` -- add `max_length=200`

Line 190-193, change:
```python
fields: list[FieldMapping] = Field(
    min_length=1,
    description="At least one field mapping is required.",
)
```
to:
```python
fields: list[FieldMapping] = Field(
    min_length=1,
    max_length=200,
    description="At least one field mapping is required. Max 200 fields.",
)
```

### 2.2 `FormTemplateCreateRequest.fields` -- add `max_length=200`

Line 460, change:
```python
fields: list[FieldMapping] = Field(min_length=1)
```
to:
```python
fields: list[FieldMapping] = Field(min_length=1, max_length=200)
```

### 2.3 `FormTemplateUpdateRequest.fields` -- add `max_length=200`

Line 475, change:
```python
fields: list[FieldMapping] | None = None
```
to:
```python
fields: list[FieldMapping] | None = Field(default=None, max_length=200)
```

**Note**: Pydantic v2 raises `ValidationError` on max_length violation. The caller (api.py) already receives the request as a Pydantic model, so validation happens automatically at model construction. To emit `E_FORM_TEMPLATE_INVALID` specifically, we add a try/except in `api.py` (see Task 3). Alternatively, use a `model_validator` -- but `max_length` on the Field is simpler and more declarative.

**Decision**: Use `max_length=200` on the Field constraint. The Pydantic `ValidationError` is sufficient for library consumers. If the caller needs a `FormIngestException`, that wrapping happens at the API layer (Task 3).

## Task 3: Add regex validation and field count guard in `api.py`

**File**: `packages/ingestkit-forms/src/ingestkit_forms/api.py`

### 3.1 Import from security.py

Add to imports:
```python
from ingestkit_forms.security import validate_regex_pattern
```

### 3.2 Add private method `_validate_field_patterns`

Add to `FormTemplateAPI`:

```python
@staticmethod
def _validate_field_patterns(fields: list[FieldMapping]) -> None:
    """Validate all regex patterns compile successfully.

    Raises FormIngestException with E_FORM_TEMPLATE_INVALID if any
    validation_pattern is an invalid regex.
    """
    for field in fields:
        if field.validation_pattern is not None:
            error_msg = validate_regex_pattern(field.validation_pattern)
            if error_msg is not None:
                raise FormIngestException(
                    code=FormErrorCode.E_FORM_TEMPLATE_INVALID,
                    message=(
                        f"Invalid regex pattern for field '{field.field_name}': "
                        f"{error_msg}"
                    ),
                    field_name=field.field_name,
                    stage="api",
                    recoverable=False,
                )
```

### 3.3 Call in `create_template`

Insert after `template_id = str(uuid.uuid4())` (line 71) and before fingerprint computation:

```python
self._validate_field_patterns(template_def.fields)
```

### 3.4 Call in `update_template`

Insert after the partial-update fields assembly (after line 154, before fingerprint recomputation) -- only when `template_def.fields is not None`:

```python
if template_def.fields is not None:
    self._validate_field_patterns(fields)
```

## Task 4: Refactor extractors to use shared regex function

### 4.1 `ocr_overlay.py`

**File**: `packages/ingestkit-forms/src/ingestkit_forms/extractors/ocr_overlay.py`

**Remove**: lines 71-96 (the `_regex_match_with_timeout` function and `_REGEX_TIMEOUT_SECONDS` constant)
**Remove**: `import re` and `import threading` from line 12-13 (only if no other usage in the file -- verify first)
**Add import**: `from ingestkit_forms.security import regex_match_with_timeout`
**Update call sites**: All calls to `_regex_match_with_timeout(pattern, value)` become `regex_match_with_timeout(pattern, value, match_mode="match")` to preserve existing `re.match` behavior.

**Verify**: Search for all `_regex_match_with_timeout` calls in ocr_overlay.py and update each one.

### 4.2 `excel_cell.py`

**File**: `packages/ingestkit-forms/src/ingestkit_forms/extractors/excel_cell.py`

**Remove**: lines 28-58 (the `_REGEX_TIMEOUT_SECONDS` constant and `_regex_match_with_timeout` function)
**Remove**: `import re` and `import threading` from lines 10-11 (only if no other usage)
**Add import**: `from ingestkit_forms.security import regex_match_with_timeout`
**Update call sites**: All calls to `_regex_match_with_timeout(pattern, value)` become `regex_match_with_timeout(pattern, value)` (default `match_mode="fullmatch"` preserves existing behavior).

## Task 5: Update `__init__.py` exports

**File**: `packages/ingestkit-forms/src/ingestkit_forms/__init__.py`

Add import and export for the new security module:

```python
from ingestkit_forms.security import FormSecurityScanner, regex_match_with_timeout
```

Add to `__all__`:
```python
# Security (from issue #70)
"FormSecurityScanner",
"regex_match_with_timeout",
```

## Task 6: Create `test_security.py` (NEW FILE)

**File**: `packages/ingestkit-forms/tests/test_security.py`

All tests marked `@pytest.mark.unit`. Uses `tmp_path` fixture for temp files. No external services.

### 6.1 FormSecurityScanner tests

| Test function | What it verifies | AC |
|---------------|-----------------|-----|
| `test_scan_valid_pdf` | Valid PDF file passes all checks | AC1-3 |
| `test_scan_valid_xlsx` | Valid XLSX (PK header) passes | AC3 |
| `test_scan_valid_jpeg` | Valid JPEG passes | AC3 |
| `test_scan_valid_png` | Valid PNG passes | AC3 |
| `test_scan_valid_tiff_le` | Valid TIFF (little-endian) passes | AC3 |
| `test_scan_valid_tiff_be` | Valid TIFF (big-endian) passes | AC3 |
| `test_scan_file_too_large` | File > max_file_size_mb -> `E_FORM_FILE_TOO_LARGE` | AC1, spec 13.5 row 5 |
| `test_scan_unsupported_extension` | `.docx` file -> `E_FORM_UNSUPPORTED_FORMAT` | AC2 |
| `test_scan_magic_mismatch_pdf` | `.pdf` with JPEG bytes -> `E_FORM_FILE_CORRUPT` | AC3, spec 13.5 row 2 |
| `test_scan_magic_mismatch_xlsx` | `.xlsx` with PDF bytes -> `E_FORM_FILE_CORRUPT` | AC3, spec 13.5 row 2 |
| `test_scan_magic_mismatch_jpeg` | `.jpg` with PNG bytes -> `E_FORM_FILE_CORRUPT` | AC3, spec 13.5 row 2 |
| `test_scan_magic_mismatch_png` | `.png` with PDF bytes -> `E_FORM_FILE_CORRUPT` | AC3, spec 13.5 row 2 |
| `test_scan_magic_mismatch_tiff` | `.tiff` with PDF bytes -> `E_FORM_FILE_CORRUPT` | AC3, spec 13.5 row 2 |
| `test_scan_empty_file` | 0-byte file -> `E_FORM_FILE_CORRUPT` or `E_FORM_FILE_TOO_LARGE` | AC1 |

**Implementation approach**: Create minimal temp files with correct/incorrect magic bytes. For the "valid" tests, write just the magic bytes (scanner only reads headers). For the "too large" test, use `os.truncate` to create a file larger than `max_file_size_mb` (set config to 1 MB and create a 2 MB file).

### 6.2 Template field count tests

| Test function | What it verifies | AC |
|---------------|-----------------|-----|
| `test_template_field_count_at_limit` | Exactly 200 fields -> accepted | AC4 |
| `test_template_field_count_exceeds_limit` | 201 fields -> `ValidationError` | AC4, spec 13.5 row 6 |
| `test_create_request_field_count_exceeds_limit` | 201 fields in CreateRequest -> `ValidationError` | AC4 |

**Implementation**: Construct `FormTemplate`/`FormTemplateCreateRequest` with generated `FieldMapping` lists. Assert Pydantic `ValidationError` is raised.

### 6.3 Regex validation tests

| Test function | What it verifies | AC |
|---------------|-----------------|-----|
| `test_validate_regex_pattern_valid` | `r"^\d{3}-\d{4}$"` -> None | AC5 |
| `test_validate_regex_pattern_invalid` | `r"[unclosed"` -> error string | AC5 |
| `test_regex_match_with_timeout_match` | Normal pattern matches | AC6 |
| `test_regex_match_with_timeout_no_match` | Normal pattern no match -> False | AC6 |
| `test_regex_match_with_timeout_redos` | ReDoS pattern -> None (timeout) | AC6, spec 13.5 row 1 |
| `test_regex_match_with_timeout_invalid_pattern` | Bad regex -> None or False | AC6 |
| `test_regex_match_fullmatch_vs_match` | Verify `match_mode` parameter works | AC6 |

**ReDoS pattern**: Use `(a+)+b` matched against `"a" * 30` (known catastrophic backtracking).

### 6.4 API-level regex validation tests

| Test function | What it verifies | AC |
|---------------|-----------------|-----|
| `test_create_template_invalid_regex_rejected` | `create_template` with bad regex -> `FormIngestException` with `E_FORM_TEMPLATE_INVALID` | AC5 |
| `test_update_template_invalid_regex_rejected` | `update_template` with bad regex -> `FormIngestException` with `E_FORM_TEMPLATE_INVALID` | AC5 |
| `test_create_template_valid_regex_accepted` | `create_template` with valid regex -> success | AC5 |

**Implementation**: Use a mock `FormTemplateStore` (same pattern as `test_api.py`).

### 6.5 Existing security test coverage (verify, do NOT duplicate)

The following already have tests in `test_extractors.py` -- do NOT re-test:
- Resolution guardrail (10000px) -- `test_extractors.py:1423-1429`
- ReDoS timeout in OCR extractor -- `test_extractors.py:1431-1439`
- ReDoS timeout in Excel extractor -- `test_extractors.py:2028-2038`

**Estimated test count**: ~22 tests, ~250-300 lines.

## Implementation Order

1. **Task 1** (security.py) -- standalone, no dependencies
2. **Task 2** (models.py field count limits) -- standalone
3. **Task 3** (api.py regex validation) -- depends on Task 1 for `validate_regex_pattern`
4. **Task 4** (extractor refactor) -- depends on Task 1 for `regex_match_with_timeout`
5. **Task 5** (__init__.py exports) -- depends on Task 1
6. **Task 6** (test_security.py) -- depends on all above

Tasks 1 and 2 can be done in parallel. Tasks 3, 4, 5 can be done in parallel after Task 1.

## Verification Gates

```bash
# Unit tests (must pass)
pytest packages/ingestkit-forms/tests/test_security.py -v -m unit

# Regression check (must pass)
pytest packages/ingestkit-forms/tests/ -v -m unit

# Import check
python -c "from ingestkit_forms import FormSecurityScanner, regex_match_with_timeout; print('OK')"
```

## Risk Mitigation

| Risk | Mitigation |
|------|-----------|
| Moving `_regex_match_with_timeout` breaks existing extractor tests | Update imports in extractors first; run `test_extractors.py` before writing `test_security.py` |
| `re.match` vs `re.fullmatch` semantic difference | `match_mode` parameter preserves each call site's current behavior |
| Pydantic `max_length` on Optional field | Test explicitly that `None` (no update) still works in `FormTemplateUpdateRequest` |
| Empty file edge case in scanner | Handle `os.path.getsize() == 0` as `E_FORM_FILE_CORRUPT` before magic byte read |

---

AGENT_RETURN: PLAN complete. 2 new files (security.py, test_security.py), 5 modified files (models.py, api.py, ocr_overlay.py, excel_cell.py, __init__.py). 6 tasks, ~22 tests. Ready for PLAN-CHECK then PATCH.
