---
issue: 5
agent: MAP-PLAN
date: 2026-02-10
complexity: SIMPLE
stack: backend
files_identified: 3
---

# MAP-PLAN - Issue #5

## Summary

Issue #5 requires implementing the `ParserChain` class in a new `parser_chain.py` module that provides a three-tier fallback strategy for parsing `.xlsx` files. The chain tries openpyxl (full fidelity) first, falls back to pandas `read_excel` (reduced fidelity), and finally to openpyxl `data_only=True` (minimal fidelity). If all three parsers fail, it produces an `E_PARSE_CORRUPT` error. Fallback is per-sheet: each sheet independently traverses the chain, and the `ParserUsed` enum is recorded on each `SheetProfile`. Non-fatal warnings (`W_PARSER_FALLBACK`) and structured `IngestError` objects are collected and returned alongside the `FileProfile`.

The implementation must also handle edge cases: password-protected sheets (`E_PARSE_PASSWORD` / `W_SHEET_SKIPPED_PASSWORD`), chart-only sheets (`W_SHEET_SKIPPED_CHART`), empty files (`E_PARSE_EMPTY`), and sheets exceeding `config.max_rows_in_memory` (`W_ROWS_TRUNCATED`). The `FileProfile` returned must include a `content_hash` (SHA-256 of file bytes). All models, enums, and error codes needed for this implementation already exist in `models.py` and `errors.py`. A corresponding test file `tests/test_parser_chain.py` must be created to validate the acceptance criteria.

## VERIFICATION STEPS (MANDATORY)

1. **Specification**: Read SPEC.md section 7 (Parser Fallback Chain), lines 523-562. Defines the three-tier chain (openpyxl -> pandas -> raw text), per-sheet fallback behavior, `fallback_reason_code` recording, `W_PARSER_FALLBACK` warning, and the public interface `ParserChain.parse(file_path) -> tuple[FileProfile, list[IngestError]]`. Also cross-referenced section 14 (Error Handling) at lines 939-955 for the full error/warning behavior table covering password, chart-only, empty, and truncation cases.

2. **Code Verification**:
   - `models.py` (lines 72-78): `ParserUsed` enum already defined with values `OPENPYXL`, `PANDAS_FALLBACK`, `RAW_TEXT_FALLBACK`.
   - `models.py` (lines 148-180): `SheetProfile` has `parser_used: ParserUsed` field. `FileProfile` has `content_hash: str`, `has_password_protected_sheets: bool`, `has_chart_only_sheets: bool`, and all required aggregate fields.
   - `models.py` (lines 112-120): `ParseStageResult` has `parser_used`, `fallback_reason_code`, `sheets_parsed`, `sheets_skipped`, `skipped_reasons`, `parse_duration_seconds`.
   - `errors.py` (lines 19-24): Parse error codes exist: `E_PARSE_CORRUPT`, `E_PARSE_OPENPYXL_FAIL`, `E_PARSE_PANDAS_FAIL`, `E_PARSE_PASSWORD`, `E_PARSE_EMPTY`, `E_PARSE_TOO_LARGE`.
   - `errors.py` (lines 47-52): Warning codes exist: `W_SHEET_SKIPPED_CHART`, `W_SHEET_SKIPPED_PASSWORD`, `W_PARSER_FALLBACK`, `W_ROWS_TRUNCATED`.
   - `errors.py` (lines 55-67): `IngestError` model with `code`, `message`, `sheet_name`, `stage`, `recoverable` fields.
   - `config.py` (line 58): `max_rows_in_memory: int = 100_000` exists.
   - `config.py` (line 26): `parser_version: str = "ingestkit_excel:1.0.0"` exists.
   - `idempotency.py` (lines 63-64): SHA-256 content hash computation already exists as a reference pattern.
   - `__init__.py`: `ParserChain` is NOT yet exported (expected -- this is a new module).
   - No existing `parser_chain.py` file found anywhere in the project.
   - No existing `test_parser_chain.py` file found.

3. **Approach Decision**: Create a new `parser_chain.py` module containing the `ParserChain` class with a single public method `parse(file_path) -> tuple[FileProfile, list[IngestError]]`. Internally, implement three private parser methods (`_parse_openpyxl`, `_parse_pandas`, `_parse_raw_text`) and a per-sheet orchestrator (`_parse_sheet`) that tries each in sequence. The file-level `parse` method will: compute the content_hash, open the workbook to enumerate sheets, call the per-sheet orchestrator for each, aggregate results into a `FileProfile`, and collect `IngestError` objects.

4. **Impact Analysis**:
   - **New file**: `src/ingestkit_excel/parser_chain.py` -- the entire implementation.
   - **New file**: `tests/test_parser_chain.py` -- test suite.
   - **Modified file**: `src/ingestkit_excel/__init__.py` -- add `ParserChain` to exports and `__all__`.
   - No modifications needed to `models.py`, `errors.py`, or `config.py` since all required types already exist.

5. **Completeness**: All components identified. The three files above cover the full requirement scope. All enums, models, and error codes are already defined. The `content_hash` computation pattern exists in `idempotency.py` and can be reused. The `conftest.py` in `tests/` may need additional fixtures for test xlsx files, but those can be created programmatically within the test file using openpyxl.

## INVESTIGATION

### Affected Files

**Files to create:**

1. `/home/jjob/projects/ingestkit/packages/ingestkit-excel/src/ingestkit_excel/parser_chain.py` (NEW)
   - `ParserChain` class with `__init__(self, config: ExcelProcessorConfig)` and `parse(self, file_path: str) -> tuple[FileProfile, list[IngestError]]`
   - Private methods for each parser tier and per-sheet orchestration
   - Content hash computation
   - Edge case handling (password, chart-only, empty, row truncation)

2. `/home/jjob/projects/ingestkit/packages/ingestkit-excel/tests/test_parser_chain.py` (NEW)
   - Test suite covering all acceptance criteria
   - Programmatically created .xlsx fixtures using openpyxl
   - Tests for primary parser success, fallback scenarios, all-fail corrupt, per-sheet independence, edge cases

**Files to modify:**

3. `/home/jjob/projects/ingestkit/packages/ingestkit-excel/src/ingestkit_excel/__init__.py` (MODIFY)
   - Add `from ingestkit_excel.parser_chain import ParserChain` import
   - Add `"ParserChain"` to `__all__` list

### Risks

**Risk 1: Detecting password-protected sheets**
- openpyxl raises a specific exception when encountering password-protected workbooks. However, per-sheet password protection (sheet-level, not file-level) behaves differently: openpyxl can open the file but the sheet data may be inaccessible or an exception is raised when iterating cells.
- **Mitigation**: Catch the specific openpyxl exceptions. For file-level passwords, `openpyxl.load_workbook()` itself will fail. For sheet-level protection, the sheet is typically still readable (protection prevents editing, not reading). The main concern is encrypted workbooks where the entire file is encrypted.

**Risk 2: Detecting chart-only sheets**
- openpyxl distinguishes between `Worksheet` and `Chartsheet` types. A chart-only sheet is of type `openpyxl.chartsheet.Chartsheet`, not `openpyxl.worksheet.worksheet.Worksheet`.
- **Mitigation**: Check `isinstance(sheet, Chartsheet)` or check `type(sheet).__name__` after loading the workbook. Skip `Chartsheet` instances and record `W_SHEET_SKIPPED_CHART`.

**Risk 3: Pandas fallback may not provide all SheetProfile fields**
- `pandas.read_excel()` does not expose merged cells, formulas, or hidden sheet status. The `SheetProfile` fields `merged_cell_count`, `merged_cell_ratio`, `has_formulas`, `is_hidden` will need sensible defaults (0 / 0.0 / False) when the pandas fallback is used.
- **Mitigation**: Set these fields to their "unknown/minimal" values and document that fidelity is reduced. The `parser_used` field on `SheetProfile` already signals reduced fidelity.

**Risk 4: Raw text fallback (openpyxl data_only=True) may also fail on corrupt files**
- If the file is truly corrupt (not valid xlsx at all), even `data_only=True` will fail. This is the expected "all parsers fail" scenario leading to `E_PARSE_CORRUPT`.
- **Mitigation**: This is by design. The three-tier chain exhausts all options, and `E_PARSE_CORRUPT` is the correct terminal error.

**Risk 5: Row count detection before full sheet load**
- Checking `max_rows_in_memory` requires knowing the row count. With openpyxl, `ws.max_row` gives this. With pandas, `len(df)` after loading gives this, but loading already consumed memory.
- **Mitigation**: For openpyxl, check `ws.max_row` before iterating. For pandas, check `len(df)` immediately after read and truncate or skip. The warning `W_ROWS_TRUNCATED` is added but processing continues with truncated data (per SPEC table in section 14: "Skip sheet, add warning").

## PLAN

### File-by-File Steps

#### Step 1: Create `src/ingestkit_excel/parser_chain.py`

**Purpose:** Implement the parser fallback chain per SPEC.md section 7.

**Module structure:**

```
Imports:
  - hashlib, logging, time, pathlib.Path
  - openpyxl (load_workbook)
  - openpyxl.chartsheet.Chartsheet (for chart-only detection)
  - pandas (read_excel)
  - ExcelProcessorConfig from config
  - SheetProfile, FileProfile, ParserUsed from models
  - ErrorCode, IngestError from errors

Logger:
  - logger = logging.getLogger("ingestkit_excel")

Class: ParserChain
  - __init__(self, config: ExcelProcessorConfig)
  - parse(self, file_path: str) -> tuple[FileProfile, list[IngestError]]
  - _compute_content_hash(self, file_path: str) -> str
  - _parse_sheet_openpyxl(self, ws, sheet_name: str) -> SheetProfile
  - _parse_sheet_pandas(self, file_path: str, sheet_name: str) -> SheetProfile
  - _parse_sheet_raw_text(self, file_path: str, sheet_name: str) -> SheetProfile
  - _build_sheet_profile_from_openpyxl(self, ws, sheet_name: str) -> SheetProfile
  - _build_sheet_profile_from_pandas(self, df, sheet_name: str) -> SheetProfile
  - _build_sheet_profile_from_raw(self, ws, sheet_name: str) -> SheetProfile
```

**Detailed implementation for `parse(self, file_path: str)`:**

1. Start timer with `time.monotonic()`.
2. Compute `content_hash` via `_compute_content_hash(file_path)` -- SHA-256 of raw file bytes (same pattern as `idempotency.py` line 63-64).
3. Validate file is not empty (0 bytes) -- if so, return a minimal `FileProfile` with `E_PARSE_EMPTY` error immediately.
4. Attempt to open with `openpyxl.load_workbook(file_path)`:
   - If this raises an exception indicating password protection, record `E_PARSE_PASSWORD` and return error result.
   - If this raises a general exception, the entire file cannot be opened by openpyxl. Try pandas-level file open next.
5. Enumerate sheets from the workbook. For each sheet:
   a. Check if it is a `Chartsheet` -- if so, skip with `W_SHEET_SKIPPED_CHART` warning, increment `sheets_skipped`.
   b. Check if `ws.max_row` exceeds `config.max_rows_in_memory` -- if so, skip with `W_ROWS_TRUNCATED` warning.
   c. Try `_parse_sheet_openpyxl(ws, sheet_name)`:
      - On success: append `SheetProfile` with `parser_used=ParserUsed.OPENPYXL`.
      - On failure: record `E_PARSE_OPENPYXL_FAIL` as `fallback_reason_code`, try fallback.
   d. On openpyxl failure, try `_parse_sheet_pandas(file_path, sheet_name)`:
      - On success: append `SheetProfile` with `parser_used=ParserUsed.PANDAS_FALLBACK`. Add `W_PARSER_FALLBACK` warning with `fallback_reason_code` of `E_PARSE_OPENPYXL_FAIL`.
      - On failure: record `E_PARSE_PANDAS_FAIL`, try next fallback.
   e. On pandas failure, try `_parse_sheet_raw_text(file_path, sheet_name)`:
      - On success: append `SheetProfile` with `parser_used=ParserUsed.RAW_TEXT_FALLBACK`. Add `W_PARSER_FALLBACK` warning with `fallback_reason_code` of `E_PARSE_PANDAS_FAIL`.
      - On failure: this sheet is corrupt. Record per-sheet error.
6. If no sheets were successfully parsed and no data sheets exist, produce `E_PARSE_EMPTY` or `E_PARSE_CORRUPT`.
7. Aggregate `SheetProfile` list into `FileProfile`:
   - `file_path`, `file_size_bytes` (from `os.path.getsize` or `Path.stat()`), `sheet_count`, `sheet_names`, `sheets`, `has_password_protected_sheets`, `has_chart_only_sheets`, `total_merged_cells` (sum across sheets), `total_rows` (sum across sheets), `content_hash`.
8. Return `(FileProfile, list[IngestError])`.

**Detailed implementation for `_compute_content_hash(self, file_path: str) -> str`:**
- Read raw bytes: `Path(file_path).read_bytes()`
- Return `hashlib.sha256(file_bytes).hexdigest()`

**Detailed implementation for `_parse_sheet_openpyxl(self, ws, sheet_name: str) -> SheetProfile`:**
- Extract from the openpyxl worksheet object:
  - `row_count`: `ws.max_row` (or 0 if None)
  - `col_count`: `ws.max_column` (or 0 if None)
  - `merged_cell_count`: `len(ws.merged_cells.ranges)`
  - `merged_cell_ratio`: `merged_cell_count / (row_count * col_count)` if total_cells > 0 else 0.0
  - `header_row_detected`: heuristic -- first row has string values in most cells
  - `header_values`: list of string values from row 1
  - `column_type_consistency`: analyze column types across rows (float 0.0-1.0)
  - `numeric_ratio`, `text_ratio`, `empty_ratio`: count cell types
  - `sample_rows`: first `config.max_sample_rows` rows as list of strings
  - `has_formulas`: any cell has a formula (cell value starts with "=" when not data_only)
  - `is_hidden`: `ws.sheet_state == "hidden"`
  - `parser_used`: `ParserUsed.OPENPYXL`

**Detailed implementation for `_parse_sheet_pandas(self, file_path: str, sheet_name: str) -> SheetProfile`:**
- Load via `pd.read_excel(file_path, sheet_name=sheet_name, header=None)`
- Extract:
  - `row_count`: `len(df)`
  - `col_count`: `len(df.columns)`
  - `merged_cell_count`: 0 (not available from pandas)
  - `merged_cell_ratio`: 0.0
  - `header_row_detected`: heuristic on first row
  - `header_values`: first row values as strings
  - `column_type_consistency`: analyze df dtypes
  - `numeric_ratio`, `text_ratio`, `empty_ratio`: from df dtypes and null counts
  - `sample_rows`: first N rows as strings
  - `has_formulas`: False (not available from pandas)
  - `is_hidden`: False (not available from pandas)
  - `parser_used`: `ParserUsed.PANDAS_FALLBACK`

**Detailed implementation for `_parse_sheet_raw_text(self, file_path: str, sheet_name: str) -> SheetProfile`:**
- Load via `openpyxl.load_workbook(file_path, data_only=True)`
- Extract same fields as openpyxl parser but with `data_only=True` (formulas replaced with cached values).
- `has_formulas`: False (data_only mode discards formula info)
- `parser_used`: `ParserUsed.RAW_TEXT_FALLBACK`

**Logging:**
- INFO: Log each file parsed with parser used and timing.
- WARNING: Log each fallback event with `W_PARSER_FALLBACK` code.
- ERROR: Log `E_PARSE_CORRUPT` when all parsers fail.

#### Step 2: Modify `src/ingestkit_excel/__init__.py`

**Purpose:** Export `ParserChain` from the package public API.

**Changes:**
1. Add import: `from ingestkit_excel.parser_chain import ParserChain`
2. Add `"ParserChain"` to `__all__` list (under a comment like `# Parser`)

#### Step 3: Create `tests/test_parser_chain.py`

**Purpose:** Validate all acceptance criteria from Issue #5.

**Test fixtures (created programmatically using openpyxl in fixtures or conftest):**
- `clean_xlsx` -- a valid 3-column, 20-row workbook created with openpyxl (tmp_path fixture)
- `corrupt_for_openpyxl_xlsx` -- a file that openpyxl fails to parse for a specific sheet but pandas succeeds (can be simulated by writing valid xlsx then corrupting specific sheet XML in the zip archive, or by monkeypatching openpyxl to raise)
- `fully_corrupt_xlsx` -- a file that no parser can read (random bytes written to a .xlsx extension)
- `multi_sheet_xlsx` -- workbook with 2+ sheets for per-sheet fallback independence testing
- `empty_xlsx` -- workbook with no data (0 rows)
- `chart_only_xlsx` -- workbook with a chartsheet
- `large_sheet_xlsx` -- workbook with rows > max_rows_in_memory (dynamically set config to small value for testing)
- `password_protected_xlsx` -- can simulate by writing an encrypted xlsx or monkeypatching openpyxl load to raise the appropriate exception

**Test cases:**

1. `test_clean_xlsx_uses_openpyxl_primary` -- parse a clean file, verify all SheetProfiles have `parser_used == ParserUsed.OPENPYXL`, no errors, no warnings.

2. `test_openpyxl_fail_falls_back_to_pandas` -- monkeypatch openpyxl sheet parsing to raise, verify fallback to pandas, verify `parser_used == ParserUsed.PANDAS_FALLBACK`, verify `W_PARSER_FALLBACK` in errors list, verify `fallback_reason_code` is set.

3. `test_all_parsers_fail_produces_e_parse_corrupt` -- write random bytes as .xlsx, verify `E_PARSE_CORRUPT` in returned errors.

4. `test_per_sheet_fallback_independence` -- multi-sheet workbook where sheet 1 parses with openpyxl and sheet 2 requires pandas fallback. Verify sheet 1 has `ParserUsed.OPENPYXL` and sheet 2 has `ParserUsed.PANDAS_FALLBACK`.

5. `test_fallback_reason_code_correctly_set` -- verify `fallback_reason_code` on the `IngestError` matches the error code of the parser that failed.

6. `test_w_parser_fallback_in_warnings` -- verify `W_PARSER_FALLBACK` appears in the IngestError list when any fallback is used.

7. `test_password_protected_file` -- verify `E_PARSE_PASSWORD` or `W_SHEET_SKIPPED_PASSWORD` produced. Can monkeypatch `openpyxl.load_workbook` to raise the password-protection exception.

8. `test_chart_only_sheet_skipped` -- create workbook with a chartsheet, verify `W_SHEET_SKIPPED_CHART` in errors and `has_chart_only_sheets=True` on FileProfile.

9. `test_empty_file` -- create empty workbook (no data), verify `E_PARSE_EMPTY` in errors.

10. `test_rows_truncated_warning` -- create workbook with rows exceeding a small `max_rows_in_memory` config value, verify `W_ROWS_TRUNCATED` in errors.

11. `test_content_hash_computed` -- verify `FileProfile.content_hash` is a valid SHA-256 hex string matching independent computation.

12. `test_file_profile_aggregate_fields` -- verify `sheet_count`, `sheet_names`, `total_merged_cells`, `total_rows`, `file_size_bytes` are correctly aggregated.

### Acceptance Criteria

From issue requirements:

1. Clean .xlsx parsed successfully with openpyxl (primary) -- `test_clean_xlsx_uses_openpyxl_primary`
2. Corrupted-for-openpyxl file falls back to pandas -- `test_openpyxl_fail_falls_back_to_pandas`
3. All-parsers-fail produces `E_PARSE_CORRUPT` -- `test_all_parsers_fail_produces_e_parse_corrupt`
4. Per-sheet fallback independence verified -- `test_per_sheet_fallback_independence`
5. `fallback_reason_code` correctly set per sheet -- `test_fallback_reason_code_correctly_set`
6. `W_PARSER_FALLBACK` in warnings when fallback used -- `test_w_parser_fallback_in_warnings`
7. Password-protected, chart-only, empty edge cases handled -- `test_password_protected_file`, `test_chart_only_sheet_skipped`, `test_empty_file`
8. `pytest tests/test_parser_chain.py -q` passes -- all tests green

### Verification Gates

**Gate 1: Module creation**
- `src/ingestkit_excel/parser_chain.py` created
- `ParserChain` class with correct `__init__` and `parse` signatures
- Module imports resolve without errors
- No circular import issues

**Gate 2: Core functionality**
- Clean xlsx parses successfully with openpyxl as primary parser
- `SheetProfile` fields populated correctly for openpyxl parsing
- `FileProfile` aggregation correct (content_hash, sheet_count, etc.)
- `content_hash` matches SHA-256 of file bytes

**Gate 3: Fallback chain**
- openpyxl failure triggers pandas fallback
- pandas failure triggers raw text fallback
- All failures produce `E_PARSE_CORRUPT`
- `W_PARSER_FALLBACK` warning added for each fallback event
- `fallback_reason_code` correctly records the failed parser's error code
- Per-sheet fallback independence confirmed

**Gate 4: Edge cases**
- Password-protected files produce `E_PARSE_PASSWORD` / `W_SHEET_SKIPPED_PASSWORD`
- Chart-only sheets produce `W_SHEET_SKIPPED_CHART`
- Empty files produce `E_PARSE_EMPTY`
- Oversized sheets produce `W_ROWS_TRUNCATED`

**Gate 5: Integration**
- `__init__.py` exports `ParserChain`
- `pytest tests/test_parser_chain.py -q` passes with all tests green
- No regressions in existing tests (`test_config.py`, `test_idempotency.py`, `test_models.py`)

---

**IMPLEMENTATION NOTES:**

Key design decisions:

1. **Per-sheet vs. per-file fallback**: The spec explicitly states "Fallback is per-sheet: sheet 1 may use openpyxl while sheet 2 falls back to pandas." This means the initial `load_workbook()` call is file-level (needed to enumerate sheets), but individual sheet parsing is per-sheet with independent fallback chains.

2. **File-level open failure**: If `openpyxl.load_workbook()` fails at the file level (not per-sheet), the entire file is tried with pandas `read_excel(sheet_name=None)` to get all sheets, then each sheet is tried individually. If that also fails, raw text fallback is attempted. If all fail, `E_PARSE_CORRUPT`.

3. **Password detection**: openpyxl does not natively support encrypted xlsx files. When it encounters one, it will raise an exception (typically from the zipfile module or a specific openpyxl error about encryption). This should be caught and mapped to `E_PARSE_PASSWORD`.

4. **Content hash placement**: The `content_hash` is computed once at the start of `parse()` from raw file bytes, before any parsing attempt. This is consistent with the idempotency module's approach.

5. **ParseStageResult**: Note that `ParseStageResult` (models.py line 112-120) is a separate model used by the router. The `ParserChain.parse()` returns `tuple[FileProfile, list[IngestError]]` per the spec. The router will construct `ParseStageResult` from the `FileProfile` and error list. The `ParserChain` itself does NOT return `ParseStageResult`.

6. **Logging**: Use logger `"ingestkit_excel"` per SPEC section 15. Log at INFO for successful parses, WARNING for fallbacks, ERROR for `E_PARSE_CORRUPT`. PII-safe by default -- no raw cell data in logs.

---

AGENT_RETURN: map-plan-5-021026.md
