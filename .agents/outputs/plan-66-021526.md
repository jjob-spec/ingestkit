---
issue: 66
title: "Implement VLM fallback extraction for low-confidence OCR fields"
agent: PLAN
timestamp: 2026-02-15
status: complete
branch: feature/issue-66-vlm-fallback-extraction
complexity: COMPLEX
stack: backend
files_to_create:
  - packages/ingestkit-forms/src/ingestkit_forms/extractors/vlm_fallback.py
files_to_modify:
  - packages/ingestkit-forms/src/ingestkit_forms/extractors/__init__.py
  - packages/ingestkit-forms/tests/test_extractors.py
  - packages/ingestkit-forms/tests/conftest.py
---

# PLAN: Issue #66 -- VLM Fallback Extraction for Low-Confidence OCR Fields

## Executive Summary

Implement `VLMFieldExtractor` in `extractors/vlm_fallback.py` as a standalone post-processing class that re-extracts OCR fields with confidence below `form_vlm_fallback_threshold` (0.4) using a VLM backend. The class filters eligible fields, sorts by priority (required first, lowest confidence first), enforces the per-document budget (`form_vlm_max_fields_per_document`), crops each field region with 10% padding, and calls `VLMBackend.extract_field()`. If the VLM result meets `form_extraction_min_field_confidence` (0.5), it replaces the OCR result; otherwise the original is retained. All VLM access is via the `VLMBackend` protocol. Graceful degradation on timeout/error. 13 unit test cases.

---

## File 1: `extractors/vlm_fallback.py` (CREATE)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/extractors/vlm_fallback.py`

### 1.1 Module Docstring and Imports

```python
"""VLM fallback extractor for low-confidence OCR fields.

Post-processes OCR extraction results by re-extracting fields with
confidence below form_vlm_fallback_threshold using a Vision-Language
Model backend. See spec section 7.5.
"""

from __future__ import annotations

import io
import logging
from typing import TYPE_CHECKING

from ingestkit_forms.errors import FormErrorCode
from ingestkit_forms.extractors._rendering import get_page_image
from ingestkit_forms.models import BoundingBox, ExtractedField

if TYPE_CHECKING:
    from PIL import Image

    from ingestkit_forms.config import FormProcessorConfig
    from ingestkit_forms.models import FieldMapping, FormTemplate
    from ingestkit_forms.protocols import VLMBackend

logger = logging.getLogger("ingestkit_forms")
```

### 1.2 Private Helper: `_crop_field_region_with_padding`

Module-level function. Extends the existing `_crop_field_region` logic from `ocr_overlay.py` with 10% padding on each side, clamped to image bounds.

```python
def _crop_field_region_with_padding(
    page_image: Image.Image,
    region: BoundingBox,
    padding_pct: float = 0.10,
) -> Image.Image:
    """Crop field region with padding for VLM context (spec section 7.5 step 1).

    Expands the bounding box by padding_pct on each side, clamped to
    image dimensions. Default 10% padding provides surrounding context
    for the VLM to interpret the field.

    Args:
        page_image: Full page image (PIL Image).
        region: Normalized bounding box (0.0-1.0 coordinates).
        padding_pct: Fractional padding to add on each side (default 0.10).

    Returns:
        Cropped PIL Image with padding.
    """
    page_w, page_h = page_image.size

    # Convert normalized coords to pixels
    px_x = region.x * page_w
    px_y = region.y * page_h
    px_w = region.width * page_w
    px_h = region.height * page_h

    # Compute padding in pixels
    pad_x = px_w * padding_pct
    pad_y = px_h * padding_pct

    # Expand with padding, clamp to image bounds
    left = max(0, int(px_x - pad_x))
    top = max(0, int(px_y - pad_y))
    right = min(page_w, int(px_x + px_w + pad_x))
    bottom = min(page_h, int(px_y + px_h + pad_y))

    return page_image.crop((left, top, right, bottom))
```

**Design note:** Padding is computed relative to the field's own dimensions (`px_w * padding_pct`, `px_h * padding_pct`), not the page dimensions. This ensures small fields get proportionally small padding and large fields get larger padding. Clamping ensures no out-of-bounds cropping.

### 1.3 Private Helper: `_image_to_png_bytes`

```python
def _image_to_png_bytes(image: Image.Image) -> bytes:
    """Convert PIL Image to PNG-encoded bytes for VLM backend."""
    buf = io.BytesIO()
    if image.mode == "1":
        image = image.convert("L")
    image.save(buf, format="PNG")
    return buf.getvalue()
```

**Note:** Duplicated from `ocr_overlay.py` rather than importing a private function. This keeps VLM module self-contained per the MAP recommendation.

### 1.4 Class: `VLMFieldExtractor`

```python
class VLMFieldExtractor:
    """Post-processes OCR results using VLM for low-confidence fields.

    Standalone class called after OCR extraction. Iterates the extraction
    results, identifies fields below the VLM threshold, and re-extracts
    them using the VLMBackend protocol with padded field crops.

    All VLM access is via the VLMBackend protocol (never concrete imports).
    See spec section 7.5.
    """

    def __init__(
        self,
        vlm_backend: VLMBackend,
        config: FormProcessorConfig,
    ) -> None:
        self._vlm = vlm_backend
        self._config = config
```

### 1.5 Primary Method: `apply_vlm_fallback`

```python
    def apply_vlm_fallback(
        self,
        fields: list[ExtractedField],
        template: FormTemplate,
        file_path: str,
    ) -> list[ExtractedField]:
        """Apply VLM fallback extraction to low-confidence OCR fields.

        Algorithm (spec section 7.5):
        1. Guard: if not form_vlm_enabled or vlm_backend is None, return unchanged.
        2. Availability check: if vlm_backend.is_available() is False, log
           E_FORM_VLM_UNAVAILABLE and return unchanged.
        3. Identify candidates: fields with confidence < form_vlm_fallback_threshold.
        4. Priority sort: (not required, confidence) -- required first, lowest first.
        5. Budget: take first form_vlm_max_fields_per_document candidates.
           Emit W_FORM_VLM_BUDGET_EXHAUSTED for overflow.
        6. For each candidate:
           a. Look up FieldMapping from template by field_id.
           b. Render page image (cache per page_number).
           c. Crop with 10% padding.
           d. Convert to PNG bytes.
           e. Call vlm_backend.extract_field().
           f. If VLM confidence >= form_extraction_min_field_confidence:
              replace with VLM result (extraction_method="vlm_fallback").
           g. Else: retain original OCR result.
           h. On TimeoutError: log E_FORM_VLM_TIMEOUT, retain original.
           i. On other Exception: log E_FORM_VLM_UNAVAILABLE, retain original.
           j. Always append W_FORM_VLM_FALLBACK_USED to warnings.
        7. Return updated field list.

        Args:
            fields: List of ExtractedField from OCR extraction.
            template: FormTemplate with field mappings.
            file_path: Path to the source document (PDF or image).

        Returns:
            Updated list of ExtractedField with VLM results where improved.
        """
```

**Implementation details for the method body:**

**Step 1 -- Guard clause:**
```python
        if not self._config.form_vlm_enabled:
            return fields
```

**Step 2 -- Availability check:**
```python
        if not self._vlm.is_available():
            logger.warning(
                "VLM backend unavailable, skipping fallback for %d fields",
                len(fields),
            )
            return fields
```

**Step 3 -- Identify candidates:**
Build a dict of `field_id -> index` for efficient lookup. Filter fields where `confidence < self._config.form_vlm_fallback_threshold`.

**Step 4 -- Priority sort:**
Build field mapping lookup: `{field.field_id: field for field in template.fields}`. Sort candidates by `(not mapping.required, candidate.confidence)`. This gives required fields first (False < True), then lowest confidence first.

**Step 5 -- Budget enforcement:**
```python
        budget = self._config.form_vlm_max_fields_per_document
        within_budget = sorted_candidates[:budget]
        over_budget = sorted_candidates[budget:]
```
For fields in `over_budget`, append `W_FORM_VLM_BUDGET_EXHAUSTED` to their warnings in the output list.

**Step 6 -- Process each candidate:**
- Cache page images in a `dict[int, Image.Image]` to avoid re-rendering the same page multiple times.
- Use `get_page_image(file_path, page_number, dpi=self._config.form_ocr_dpi)` to render.
- On render failure, log warning and retain original OCR result for all fields on that page.
- Crop with `_crop_field_region_with_padding()`.
- Convert with `_image_to_png_bytes()`.
- Call `self._vlm.extract_field(image_bytes, field_type, field_name, extraction_hint, timeout)`.
  - `field_type`: `mapping.field_type.value` (string like "text", "checkbox").
  - `field_name`: `mapping.field_name`.
  - `extraction_hint`: `mapping.extraction_hint`.
  - `timeout`: `float(self._config.form_vlm_timeout_seconds)`.
- On success with `vlm_result.confidence >= self._config.form_extraction_min_field_confidence`:
  Create new `ExtractedField` replacing the original:
  ```python
  ExtractedField(
      field_id=original.field_id,
      field_name=original.field_name,
      field_label=original.field_label,
      field_type=original.field_type,
      value=vlm_result.value,
      raw_value=str(vlm_result.value) if vlm_result.value is not None else None,
      confidence=vlm_result.confidence,
      extraction_method="vlm_fallback",
      bounding_box=original.bounding_box,
      validation_passed=None,  # VLM result not re-validated
      warnings=[..., FormErrorCode.W_FORM_VLM_FALLBACK_USED.value],
  )
  ```
- On success with low VLM confidence: retain original, append `W_FORM_VLM_FALLBACK_USED` to warnings.
- On `TimeoutError`: log with `E_FORM_VLM_TIMEOUT`, retain original, append `W_FORM_VLM_FALLBACK_USED`.
- On other `Exception`: log with `E_FORM_VLM_UNAVAILABLE`, retain original, append `W_FORM_VLM_FALLBACK_USED`.

**PII-safe logging:** Only log extracted VLM values if `self._config.log_sample_data` is True. Otherwise log only field_name, original confidence, and VLM confidence.

**Step 7 -- Return:** Build new list by replacing entries at candidate indices, leaving non-candidate entries unchanged.

### 1.6 Private Helper: `_get_field_mapping`

```python
    def _get_field_mapping(
        self,
        field_id: str,
        template: FormTemplate,
    ) -> FieldMapping | None:
        """Look up a FieldMapping from the template by field_id."""
        for f in template.fields:
            if f.field_id == field_id:
                return f
        return None
```

### 1.7 Private Helper: `_get_page_number_for_field`

Not needed as a separate method -- `FieldMapping.page_number` is accessible from the mapping lookup. Use it directly in the main loop.

---

## File 2: `extractors/__init__.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/extractors/__init__.py`

**Change:** Add `VLMFieldExtractor` to imports and `__all__`.

**Before:**
```python
from ingestkit_forms.extractors.native_pdf import NativePDFExtractor
from ingestkit_forms.extractors.ocr_overlay import OCROverlayExtractor

__all__ = ["NativePDFExtractor", "OCROverlayExtractor"]
```

**After:**
```python
from ingestkit_forms.extractors.native_pdf import NativePDFExtractor
from ingestkit_forms.extractors.ocr_overlay import OCROverlayExtractor
from ingestkit_forms.extractors.vlm_fallback import VLMFieldExtractor

__all__ = ["NativePDFExtractor", "OCROverlayExtractor", "VLMFieldExtractor"]
```

---

## File 3: `tests/conftest.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/tests/conftest.py`

**Change:** Add `MockVLMBackend` class and `mock_vlm_backend` fixture.

### 3.1 MockVLMBackend Class

Add after the existing `MockOCRBackend` class (after line 78):

```python
class MockVLMBackend:
    """Mock VLMBackend for testing VLM fallback extraction.

    Configurable: default return value, confidence, availability,
    and optional per-call overrides. Tracks call count and arguments.
    """

    def __init__(
        self,
        default_value: str | bool = "extracted_value",
        default_confidence: float = 0.85,
        available: bool = True,
        model: str = "mock-vlm",
        raise_timeout: bool = False,
        raise_error: bool = False,
    ) -> None:
        self._default_value = default_value
        self._default_confidence = default_confidence
        self._available = available
        self._model = model
        self._raise_timeout = raise_timeout
        self._raise_error = raise_error
        self.call_count = 0
        self.call_args: list[dict] = []

    def extract_field(
        self,
        image_bytes: bytes,
        field_type: str,
        field_name: str,
        extraction_hint: str | None = None,
        timeout: float | None = None,
    ) -> VLMFieldResult:
        self.call_count += 1
        self.call_args.append({
            "field_type": field_type,
            "field_name": field_name,
            "extraction_hint": extraction_hint,
            "timeout": timeout,
        })
        if self._raise_timeout:
            raise TimeoutError("VLM timeout")
        if self._raise_error:
            raise RuntimeError("VLM backend error")
        return VLMFieldResult(
            value=self._default_value,
            confidence=self._default_confidence,
            model=self._model,
            prompt_tokens=100,
            completion_tokens=20,
        )

    def model_name(self) -> str:
        return self._model

    def is_available(self) -> bool:
        return self._available
```

**Additional import needed:** `from ingestkit_forms.protocols import VLMFieldResult` (add to existing import line).

### 3.2 Fixture

Add after the existing `mock_pdf_widget_backend` fixture:

```python
@pytest.fixture()
def mock_vlm_backend():
    """Mock VLMBackend for testing VLM fallback."""
    return MockVLMBackend()
```

### 3.3 VLM-Enabled Config Fixture

Add a second config fixture for VLM-enabled tests:

```python
@pytest.fixture()
def vlm_enabled_config():
    """FormProcessorConfig with VLM enabled."""
    return FormProcessorConfig(
        form_vlm_enabled=True,
        form_vlm_fallback_threshold=0.4,
        form_vlm_max_fields_per_document=10,
        form_vlm_timeout_seconds=15,
    )
```

---

## File 4: `tests/test_extractors.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/tests/test_extractors.py`

**Change:** Add VLM fallback test cases at the end of the file. Add necessary imports.

### 4.1 Additional Imports

```python
from ingestkit_forms.extractors.vlm_fallback import (
    VLMFieldExtractor,
    _crop_field_region_with_padding,
)
from ingestkit_forms.protocols import VLMFieldResult
```

Import `MockVLMBackend` from conftest (already available via fixtures).

### 4.2 VLM Helper: `_make_extracted_field`

Factory to create `ExtractedField` instances for VLM tests:

```python
def _make_vlm_extracted_field(
    field_id: str = "f1",
    field_name: str = "employee_name",
    field_label: str = "Employee Name",
    field_type: FieldType = FieldType.TEXT,
    value: str | bool | None = "OCR Value",
    confidence: float = 0.3,
    extraction_method: str = "ocr_overlay",
    page_number: int = 0,
    x: float = 0.1,
    y: float = 0.1,
    width: float = 0.3,
    height: float = 0.05,
) -> ExtractedField:
    return ExtractedField(
        field_id=field_id,
        field_name=field_name,
        field_label=field_label,
        field_type=field_type,
        value=value,
        confidence=confidence,
        extraction_method=extraction_method,
        bounding_box=BoundingBox(x=x, y=y, width=width, height=height),
        warnings=[],
    )
```

### 4.3 Test Cases (13 total)

All tests marked `@pytest.mark.unit`. All use mock backends -- no external services.

---

#### Test 1: `test_vlm_fallback_disabled` (P0)

**Purpose:** When `form_vlm_enabled=False`, fields are returned unchanged and VLM is never called.

**Setup:**
- `form_config` fixture (default: `form_vlm_enabled=False`)
- MockVLMBackend
- One field with confidence 0.2 (below threshold)
- Template with matching field mapping

**Assertions:**
- Returned fields identical to input
- `mock_vlm_backend.call_count == 0`
- No `W_FORM_VLM_FALLBACK_USED` in warnings

---

#### Test 2: `test_vlm_fallback_no_low_confidence_fields` (P0)

**Purpose:** When all fields are above threshold, no VLM calls are made.

**Setup:**
- `vlm_enabled_config` fixture
- MockVLMBackend
- Two fields with confidence 0.85 and 0.92 (both above 0.4 threshold)

**Assertions:**
- Returned fields identical to input
- `mock_vlm_backend.call_count == 0`

---

#### Test 3: `test_vlm_fallback_improves_field` (P0)

**Purpose:** Low-confidence OCR field is replaced when VLM returns high confidence.

**Setup:**
- `vlm_enabled_config` fixture
- MockVLMBackend with `default_value="VLM Value"`, `default_confidence=0.85`
- One field with confidence 0.2 (below 0.4 threshold)
- Mock `get_page_image` to return a test image

**Assertions:**
- Result field has `value == "VLM Value"`
- Result field has `confidence == 0.85`
- Result field has `extraction_method == "vlm_fallback"`
- `W_FORM_VLM_FALLBACK_USED` in warnings
- `mock_vlm_backend.call_count == 1`

---

#### Test 4: `test_vlm_fallback_no_improvement` (P0)

**Purpose:** When VLM confidence is below `form_extraction_min_field_confidence` (0.5), original OCR result is retained.

**Setup:**
- `vlm_enabled_config` fixture
- MockVLMBackend with `default_confidence=0.35` (below 0.5 min threshold)
- One field with confidence 0.2

**Assertions:**
- Result field has original `value`
- Result field has original `confidence == 0.2`
- Result field has `extraction_method == "ocr_overlay"` (unchanged)
- `W_FORM_VLM_FALLBACK_USED` in warnings (VLM was still attempted)

---

#### Test 5: `test_vlm_fallback_budget_exhausted` (P0)

**Purpose:** When more fields need VLM than budget allows, overflow fields get `W_FORM_VLM_BUDGET_EXHAUSTED`.

**Setup:**
- `vlm_enabled_config` with `form_vlm_max_fields_per_document=3`
- MockVLMBackend with `default_confidence=0.85`
- 5 fields all with confidence 0.2 (all below threshold)
- Template with 5 matching field mappings

**Assertions:**
- `mock_vlm_backend.call_count == 3` (budget limit)
- 3 fields updated with VLM results
- 2 overflow fields retain OCR values
- `W_FORM_VLM_BUDGET_EXHAUSTED` in warnings for the 2 overflow fields
- `W_FORM_VLM_FALLBACK_USED` in warnings for the 3 processed fields

---

#### Test 6: `test_vlm_fallback_priority_required_first` (P0)

**Purpose:** Required fields are processed before optional, lowest confidence first within each group.

**Setup:**
- `vlm_enabled_config` with `form_vlm_max_fields_per_document=2`
- MockVLMBackend that records call order via `call_args`
- 4 fields:
  - Field A: optional, confidence 0.1
  - Field B: required, confidence 0.3
  - Field C: required, confidence 0.15
  - Field D: optional, confidence 0.05
- Template with matching mappings (B and C have `required=True`)

**Assertions:**
- `mock_vlm_backend.call_count == 2` (budget)
- First call is for Field C (required, lowest confidence 0.15)
- Second call is for Field B (required, confidence 0.3)
- Fields A and D get `W_FORM_VLM_BUDGET_EXHAUSTED`

---

#### Test 7: `test_vlm_fallback_timeout_graceful` (P0)

**Purpose:** On VLM `TimeoutError`, original OCR result is retained and `E_FORM_VLM_TIMEOUT` is logged.

**Setup:**
- `vlm_enabled_config` fixture
- MockVLMBackend with `raise_timeout=True`
- One field with confidence 0.2
- `caplog` to check log output

**Assertions:**
- Result field has original `value` and `confidence`
- `W_FORM_VLM_FALLBACK_USED` in warnings
- Log contains "E_FORM_VLM_TIMEOUT" or related timeout message

---

#### Test 8: `test_vlm_fallback_error_graceful` (P0)

**Purpose:** On VLM generic exception, original OCR result is retained.

**Setup:**
- `vlm_enabled_config` fixture
- MockVLMBackend with `raise_error=True`
- One field with confidence 0.2

**Assertions:**
- Result field has original `value` and `confidence`
- `W_FORM_VLM_FALLBACK_USED` in warnings

---

#### Test 9: `test_vlm_fallback_unavailable` (P1)

**Purpose:** When `is_available()` returns False, all fields returned unchanged.

**Setup:**
- `vlm_enabled_config` fixture
- MockVLMBackend with `available=False`
- One field with confidence 0.2
- `caplog` to check log output

**Assertions:**
- Returned fields identical to input
- `mock_vlm_backend.call_count == 0`
- Log contains "VLM backend unavailable"

---

#### Test 10: `test_vlm_fallback_checkbox_field` (P1)

**Purpose:** Checkbox field with low confidence is correctly handled by VLM returning a bool.

**Setup:**
- `vlm_enabled_config` fixture
- MockVLMBackend with `default_value=True`, `default_confidence=0.90`
- One CHECKBOX field with confidence 0.15, value=False

**Assertions:**
- Result field has `value == True`
- Result field has `confidence == 0.90`
- Result field has `extraction_method == "vlm_fallback"`

---

#### Test 11: `test_vlm_fallback_warnings_appended` (P1)

**Purpose:** `W_FORM_VLM_FALLBACK_USED` is appended to existing warnings, not replacing them.

**Setup:**
- `vlm_enabled_config` fixture
- MockVLMBackend with `default_confidence=0.85`
- One field with confidence 0.2 and existing warnings `["W_FORM_FIELD_LOW_CONFIDENCE"]`

**Assertions:**
- Result warnings contain both `W_FORM_FIELD_LOW_CONFIDENCE` and `W_FORM_VLM_FALLBACK_USED`

---

#### Test 12: `test_crop_with_padding` (P1)

**Purpose:** Verify 10% padding is applied correctly to crop coordinates.

**Setup:**
- 1000x1000 white PIL Image
- BoundingBox(x=0.2, y=0.3, width=0.4, height=0.2)
  - Pixel coords: x=200, y=300, w=400, h=200
  - 10% padding: pad_x=40, pad_y=20
  - Expected crop: (160, 280, 640, 520)

**Assertions:**
- Cropped image size is `(480, 240)` (640-160, 520-280)

---

#### Test 13: `test_crop_with_padding_edge` (P1)

**Purpose:** Padding at image edge is clamped to bounds.

**Setup:**
- 1000x1000 white PIL Image
- BoundingBox(x=0.0, y=0.0, width=0.1, height=0.1)
  - Pixel coords: x=0, y=0, w=100, h=100
  - 10% padding: pad_x=10, pad_y=10
  - Expected crop: (0, 0, 110, 110) -- left/top clamped to 0

**Assertions:**
- Cropped image left/top starts at (0, 0)
- Cropped image size is `(110, 110)`

---

## Acceptance Criteria

- [ ] `VLMFieldExtractor` class in `extractors/vlm_fallback.py` with `apply_vlm_fallback()` method
- [ ] Trigger condition: field confidence < `form_vlm_fallback_threshold` (0.4) AND `form_vlm_enabled=True`
- [ ] Budget guard: max `form_vlm_max_fields_per_document` (10) fields, emit `W_FORM_VLM_BUDGET_EXHAUSTED` for overflow
- [ ] Priority: required fields first, lowest confidence first
- [ ] Graceful degradation: timeout/error returns original OCR result
- [ ] Field crop with 10% padding for VLM context
- [ ] `extraction_method="vlm_fallback"` on VLM-improved fields
- [ ] `W_FORM_VLM_FALLBACK_USED` warning on all VLM-processed fields
- [ ] `is_available()` check before processing; log `E_FORM_VLM_UNAVAILABLE` if not
- [ ] PII-safe logging (no extracted values unless `log_sample_data=True`)
- [ ] All VLM access via `VLMBackend` protocol only (no concrete imports)
- [ ] Unit tests cover all 13 cases with mock VLM backend
- [ ] No regressions in existing extractor tests
- [ ] `VLMFieldExtractor` exported from `extractors/__init__.py`
- [ ] `MockVLMBackend` added to `conftest.py` with fixture

---

## Verification Gates (for PROVE)

```bash
# Unit tests only (no external services)
pytest packages/ingestkit-forms/tests/test_extractors.py -m unit -v

# Full test suite (check no regressions)
pytest packages/ingestkit-forms/tests/ -m unit -v

# Import check
python -c "from ingestkit_forms.extractors import VLMFieldExtractor; print('OK')"
```

---

## Key Design Decisions

1. **Standalone class (Option 1 from MAP):** `VLMFieldExtractor` is a separate class, not integrated into `OCROverlayExtractor`. This follows the existing pattern (each extractor is standalone) and keeps VLM logic isolated.

2. **Re-render pages (Option B from MAP):** `apply_vlm_fallback()` accepts `file_path` and re-renders only pages with VLM candidates using `get_page_image()`. This avoids modifying the existing OCR extractor API. With a budget cap of 10 fields and page image caching within the method, re-rendering cost is negligible.

3. **Duplicate `_image_to_png_bytes`:** Rather than importing a private function from `ocr_overlay.py`, the helper is duplicated in `vlm_fallback.py`. This keeps the VLM module self-contained and avoids fragile cross-module private imports.

4. **VLM result replaces entire ExtractedField:** When VLM succeeds, a new `ExtractedField` is created (not mutated) with `extraction_method="vlm_fallback"` and the VLM value/confidence. The original field's `warnings` are preserved and `W_FORM_VLM_FALLBACK_USED` is appended.

5. **`validation_passed=None` on VLM results:** VLM results are not re-validated against `validation_pattern`. The spec does not require re-validation after VLM fallback, and the caller can apply validation separately if needed.

AGENT_RETURN: .agents/outputs/plan-66-021526.md
