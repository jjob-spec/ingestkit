# MAP: Issue #55 -- Extract ingestkit-core Shared Package

## 1. Shared Protocols

All four protocols are 100% identical between the two packages. The PDF copy has a `# TODO: Extract to ingestkit-core` comment at the top.

| Protocol | Excel Signature | PDF Signature | Identical? | Notes |
|----------|----------------|---------------|------------|-------|
| `VectorStoreBackend` | `upsert_chunks(collection: str, chunks: list[ChunkPayload]) -> int` | same | YES | Both use TYPE_CHECKING import for `ChunkPayload` |
| | `ensure_collection(collection: str, vector_size: int) -> None` | same | YES | |
| | `create_payload_index(collection: str, field: str, field_type: str) -> None` | same | YES | |
| | `delete_by_ids(collection: str, ids: list[str]) -> int` | same | YES | |
| `StructuredDBBackend` | `create_table_from_dataframe(table_name: str, df: pd.DataFrame) -> None` | same | YES | Both use TYPE_CHECKING import for `pd` |
| | `drop_table(table_name: str) -> None` | same | YES | |
| | `table_exists(table_name: str) -> bool` | same | YES | |
| | `get_table_schema(table_name: str) -> dict` | same | YES | |
| | `get_connection_uri() -> str` | same | YES | |
| `LLMBackend` | `classify(prompt: str, model: str, temperature: float = 0.1, timeout: float \| None = None) -> dict` | same | YES | |
| | `generate(prompt: str, model: str, temperature: float = 0.7, timeout: float \| None = None) -> str` | same | YES | |
| `EmbeddingBackend` | `embed(texts: list[str], timeout: float \| None = None) -> list[list[float]]` | same | YES | |
| | `dimension() -> int` | same | YES | |

**Verdict**: All 4 protocols are verbatim identical. Straight extraction to core with zero reconciliation needed.

**KEY ISSUE**: `VectorStoreBackend.upsert_chunks` references `ChunkPayload` via TYPE_CHECKING import. In Excel, `ChunkPayload.metadata` is `ChunkMetadata`; in PDF, `ChunkPayload.metadata` is `PDFChunkMetadata`. The core protocol must use a generic or abstract chunk payload. See "Risks" section below.

---

## 2. Shared Models

### 2.1 Identical Models (move to core as-is)

| Model | Excel Location | PDF Location | Fields | Identical? |
|-------|---------------|-------------|--------|------------|
| `IngestKey` | `models.py:85-104` | `models.py:99-117` | `content_hash`, `source_uri`, `parser_version`, `tenant_id`, `key` property | YES -- exact same fields, same SHA-256 logic |
| `WrittenArtifacts` | `models.py:245-251` | `models.py:345-351` | `vector_point_ids: list[str]`, `vector_collection: str \| None`, `db_table_names: list[str]` | YES -- exact same fields and defaults |
| `EmbedStageResult` | `models.py:135-140` | `models.py:332-337` | `texts_embedded: int`, `embedding_dimension: int`, `embed_duration_seconds: float` | YES -- exact same fields |
| `ClassificationTier` | `models.py:36-46` | `models.py:50-55` | `RULE_BASED`, `LLM_BASIC`, `LLM_REASONING` | YES -- exact same enum values |

### 2.2 Similar but NOT Identical Models (need reconciliation before extraction)

| Model | Excel Fields | PDF Fields | Differences |
|-------|-------------|-----------|-------------|
| `ChunkPayload` | `id: str`, `text: str`, `vector: list[float]`, `metadata: ChunkMetadata` | `id: str`, `text: str`, `vector: list[float]`, `metadata: PDFChunkMetadata` | Metadata type differs. Core could define `ChunkPayload` as generic or use a common base metadata type |
| `ChunkMetadata` (Excel) vs `PDFChunkMetadata` (PDF) | `source_uri`, `source_format="xlsx"`, `sheet_name`, `region_id`, `ingestion_method`, `parser_used`, `parser_version`, `chunk_index`, `chunk_hash`, `ingest_key`, `ingest_run_id`, `tenant_id`, `table_name`, `db_uri`, `row_count`, `columns`, `section_title`, `original_structure` | `source_uri`, `source_format="pdf"`, `page_numbers`, `ingestion_method`, `parser_version`, `chunk_index`, `chunk_hash`, `ingest_key`, `ingest_run_id`, `tenant_id`, `heading_path`, `content_type`, `section_title`, `doc_title`, `doc_author`, `doc_date`, `ocr_engine`, `ocr_confidence`, `ocr_dpi`, `ocr_preprocessing`, `table_name`, `table_index`, `row_count`, `columns`, `language` | **Common fields**: `source_uri`, `source_format`, `ingestion_method`, `parser_version`, `chunk_index`, `chunk_hash`, `ingest_key`, `ingest_run_id`, `tenant_id`, `table_name`, `row_count`, `columns`, `section_title`. **Excel-only**: `sheet_name`, `region_id`, `parser_used`, `db_uri`, `original_structure`. **PDF-only**: `page_numbers`, `heading_path`, `content_type`, `doc_title`, `doc_author`, `doc_date`, `ocr_*`, `table_index`, `language`. |
| `ProcessingResult` | References `ParseStageResult(Excel)`, `ClassificationStageResult(Excel)`, `EmbedStageResult`, `ClassificationResult(Excel)`, `IngestionMethod(Excel)`, `WrittenArtifacts`, `IngestError(Excel)` | References `ParseStageResult(PDF)`, `ClassificationStageResult(PDF)`, `OCRStageResult`, `EmbedStageResult`, `ClassificationResult(PDF)`, `IngestionMethod(PDF)`, `WrittenArtifacts`, `IngestError(PDF)` | Common shape but different stage result types. Not a candidate for core extraction -- stays package-specific. |
| `ClassificationResult` | `file_type: FileType`, `confidence`, `tier_used`, `reasoning`, `per_sheet_types`, `signals` | `pdf_type: PDFType`, `confidence`, `tier_used`, `reasoning`, `per_page_types`, `signals`, `degraded` | Different primary type field (`file_type` vs `pdf_type`), different per-item map keys. Stays package-specific. |
| `IngestionMethod` | `SQL_AGENT`, `TEXT_SERIALIZATION`, `HYBRID_SPLIT` | `TEXT_EXTRACTION`, `OCR_PIPELINE`, `COMPLEX_PROCESSING` | Completely different values. Stays package-specific. |

### 2.3 Package-Specific Models (do NOT move)

**Excel-only**: `FileType`, `IngestionMethod`, `RegionType`, `ParserUsed`, `SheetProfile`, `FileProfile`, `SheetRegion`, `ClassificationResult`, `ParseStageResult`, `ClassificationStageResult`, `ChunkMetadata`, `ProcessingResult`

**PDF-only**: `PDFType`, `PageType`, `IngestionMethod`, `OCREngine`, `ExtractionQualityGrade`, `ContentType`, `ExtractionQuality`, `PageProfile`, `DocumentMetadata`, `DocumentProfile`, `ClassificationResult`, `OCRResult`, `TableResult`, `PDFChunkMetadata`, `ParseStageResult`, `ClassificationStageResult`, `OCRStageResult`, `ProcessingResult`

---

## 3. Shared Errors

### 3.1 IngestError Model

| Field | Excel | PDF | Notes |
|-------|-------|-----|-------|
| `code` | `ErrorCode` | `ErrorCode` | Different enum definitions (package-specific codes) |
| `message` | `str` | `str` | Same |
| `sheet_name` | `str \| None` | -- | Excel-specific location field |
| `page_number` | -- | `int \| None` | PDF-specific location field |
| `stage` | `str \| None` | `str \| None` | Same |
| `recoverable` | `bool = False` | `bool = False` | Same |

**Verdict**: `IngestError` needs a **base class** in core with `code`, `message`, `stage`, `recoverable`. Each package extends it with its location field (`sheet_name` for Excel, `page_number` for PDF). The `code` type in the base should accept any `str` or a base error code type.

### 3.2 Shared Error Codes

| Error Code | Excel | PDF | Shared? |
|-----------|-------|-----|---------|
| `E_CLASSIFY_INCONCLUSIVE` | YES | YES | YES |
| `E_LLM_TIMEOUT` | YES | YES | YES |
| `E_LLM_MALFORMED_JSON` | YES | YES | YES |
| `E_LLM_SCHEMA_INVALID` | YES | YES | YES |
| `E_LLM_CONFIDENCE_OOB` | YES | YES | YES |
| `E_BACKEND_VECTOR_TIMEOUT` | YES | YES | YES |
| `E_BACKEND_VECTOR_CONNECT` | YES | YES | YES |
| `E_BACKEND_DB_TIMEOUT` | YES | YES | YES |
| `E_BACKEND_DB_CONNECT` | YES | YES | YES |
| `E_BACKEND_EMBED_TIMEOUT` | YES | YES | YES |
| `E_BACKEND_EMBED_CONNECT` | YES | YES | YES |
| `E_PARSE_CORRUPT` | YES | YES | YES |
| `E_PARSE_PASSWORD` | YES | YES | YES |
| `E_PARSE_EMPTY` | YES | YES | YES |
| `W_LLM_RETRY` | YES | YES | YES |

**15 shared error codes** total: 6 backend, 5 classify/LLM, 3 parse, 1 warning.

### 3.3 Package-Specific Error Codes

**Excel-only (8)**: `E_PARSE_OPENPYXL_FAIL`, `E_PARSE_PANDAS_FAIL`, `E_PARSE_TOO_LARGE`, `E_PROCESS_REGION_DETECT`, `E_PROCESS_SERIALIZE`, `E_PROCESS_SCHEMA_GEN`, `W_SHEET_SKIPPED_CHART`, `W_SHEET_SKIPPED_HIDDEN`, `W_SHEET_SKIPPED_PASSWORD`, `W_PARSER_FALLBACK`, `W_ROWS_TRUNCATED`

**PDF-only (27)**: `E_SECURITY_*` (5), `E_PARSE_GARBLED`, `E_PARSE_REPAIR_FAILED`, `E_OCR_*` (3), `E_PROCESS_TABLE_EXTRACT`, `E_PROCESS_CHUNK`, `E_PROCESS_HEADER_FOOTER`, `W_PAGE_SKIPPED_*` (3), `W_PAGE_LOW_OCR_CONFIDENCE`, `W_QUALITY_LOW_NATIVE`, `W_OCR_FALLBACK`, `W_OCR_ENGINE_FALLBACK`, `W_TABLE_CONTINUATION`, `W_ENCRYPTED_OWNER_ONLY`, `W_DOCUMENT_SIGNED`, `W_EMBEDDED_FILES`, `W_LLM_UNAVAILABLE`, `W_CLASSIFICATION_DEGRADED`, `W_SECURITY_OVERRIDE`

---

## 4. Import Graph

### 4.1 Excel Package -- Who imports from shared modules

```
protocols.py:
  <-- __init__.py (re-exports all 4 protocols)
  <-- llm_classifier.py (imports LLMBackend)
  <-- processors/structured_db.py (imports VectorStoreBackend, StructuredDBBackend, EmbeddingBackend)
  <-- tests/test_models.py (imports all 4 for runtime_checkable tests)

models.py:
  <-- __init__.py (re-exports all models + enums)
  <-- protocols.py (TYPE_CHECKING: ChunkPayload)
  <-- idempotency.py (imports IngestKey)
  <-- inspector.py (imports SheetProfile, FileProfile, FileType, ClassificationResult, ClassificationTier)
  <-- llm_classifier.py (imports FileType, ClassificationTier, ClassificationResult, SheetProfile)
  <-- parser_chain.py (imports FileProfile, ParserUsed, SheetProfile)
  <-- processors/structured_db.py (imports ChunkMetadata, ChunkPayload, EmbedStageResult, WrittenArtifacts, IngestionMethod, IngestKey)
  <-- tests/conftest.py (imports IngestKey)
  <-- tests/test_models.py (imports everything)
  <-- tests/test_idempotency.py (imports IngestKey)
  <-- tests/test_inspector.py (imports various models)
  <-- tests/test_llm_classifier.py (imports various models)
  <-- tests/test_structured_db.py (imports various models)
  <-- tests/test_parser_chain.py (imports FileProfile, ParserUsed, SheetProfile)

errors.py:
  <-- __init__.py (re-exports ErrorCode, IngestError)
  <-- models.py (imports IngestError for ProcessingResult.error_details)
  <-- llm_classifier.py (imports ErrorCode, IngestError)
  <-- parser_chain.py (imports ErrorCode, IngestError)
  <-- processors/structured_db.py (imports ErrorCode, IngestError)
  <-- tests/test_models.py (imports ErrorCode, IngestError)
  <-- tests/test_config.py (imports ErrorCode)
  <-- tests/test_structured_db.py (imports ErrorCode, IngestError)
  <-- tests/test_parser_chain.py (imports ErrorCode, IngestError)
  <-- tests/test_llm_classifier.py (imports ErrorCode, IngestError)
```

### 4.2 PDF Package -- Who imports from shared modules

```
protocols.py:
  (not yet imported by any source module -- PDF package is still early implementation)

models.py:
  <-- config.py (imports OCREngine)
  <-- quality.py (imports ExtractionQuality, ExtractionQualityGrade)
  <-- security.py (imports DocumentMetadata)
  <-- protocols.py (TYPE_CHECKING: ChunkPayload)
  <-- tests/test_models.py (imports everything)
  <-- tests/test_config.py (imports OCREngine)
  <-- tests/test_quality.py (imports ExtractionQuality, ExtractionQualityGrade)

errors.py:
  <-- models.py (imports IngestError for ProcessingResult.error_details)
  <-- security.py (imports ErrorCode, IngestError)
  <-- tests/test_errors.py (imports ErrorCode, IngestError)
  <-- tests/test_security.py (imports ErrorCode)
```

---

## 5. Package Structure

### 5.1 Excel pyproject.toml

```toml
name = "ingestkit-excel"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = ["openpyxl>=3.1", "pandas>=2.0", "pydantic>=2.0"]
optional-dependencies:
  qdrant = ["qdrant-client>=1.7"]
  ollama = ["httpx>=0.27"]
  postgres = ["psycopg2-binary>=2.9"]
  dev = ["pytest>=7.0", "pytest-cov", "pyyaml>=6.0"]
```

### 5.2 PDF pyproject.toml

```toml
name = "ingestkit-pdf"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = ["pymupdf>=1.24", "pymupdf4llm>=0.0.10", "pdfplumber>=0.10", "pandas>=2.0", "pydantic>=2.0", "Pillow>=10.0"]
optional-dependencies:
  tesseract, paddleocr, langdetect, opencv, docling, qdrant, postgres, ollama, baseline, full, dev
```

### 5.3 Common Dependencies (candidates for core)

Both packages depend on:
- `pydantic>=2.0` (used by all shared models)
- `pandas>=2.0` (used in `StructuredDBBackend` protocol via TYPE_CHECKING)

---

## 6. Other Duplicated Code

### 6.1 `from_file()` classmethod on Config

Both `ExcelProcessorConfig.from_file()` and `PDFProcessorConfig.from_file()` have nearly identical logic:
- Detect `.yaml`/`.yml`/`.json` extension
- Load with `yaml.safe_load` or `json.load`
- Handle `FileNotFoundError`, `ImportError` (yaml), `ValueError` (unsupported extension)
- Handle `None` data
- Call `cls(**data)`

This could be a mixin or utility function in core, but is low-priority since configs themselves stay package-specific.

### 6.2 `idempotency.py` module

`compute_ingest_key()` exists in Excel but not yet in PDF. The PDF SPEC mentions it should reuse the core model. This function uses only `IngestKey` + stdlib (`hashlib`, `pathlib`), so it can move to core alongside `IngestKey`.

### 6.3 Logging pattern

Both packages use the pattern `logger = logging.getLogger("ingestkit_<package>")`. Not duplicated code per se, but the naming convention is consistent.

---

## 7. Proposed ingestkit-core Contents

### 7.1 `ingestkit_core/protocols.py`

Move verbatim (all 4 protocols are identical):
- `VectorStoreBackend`
- `StructuredDBBackend`
- `LLMBackend`
- `EmbeddingBackend`

NOTE: `VectorStoreBackend.upsert_chunks` references `ChunkPayload` via TYPE_CHECKING. Since `ChunkPayload` has package-specific metadata, the core protocol should reference a core `ChunkPayload` (see 7.2).

### 7.2 `ingestkit_core/models.py`

Move these identical models:
- `IngestKey` (with SHA-256 `key` property)
- `WrittenArtifacts` (3 fields, all defaults)
- `EmbedStageResult` (3 fields)
- `ClassificationTier` enum (3 values: `rule_based`, `llm_basic`, `llm_reasoning`)

For ChunkPayload, define a core version:
- `BaseChunkMetadata` -- common fields: `source_uri`, `source_format`, `ingestion_method`, `parser_version`, `chunk_index`, `chunk_hash`, `ingest_key`, `ingest_run_id`, `tenant_id`, `table_name`, `row_count`, `columns`, `section_title` (13 fields)
- `ChunkPayload` -- `id`, `text`, `vector`, `metadata: BaseChunkMetadata` (with metadata type as generic parameter or accepting any subclass)

### 7.3 `ingestkit_core/errors.py`

Move:
- `BaseErrorCode` enum with 15 shared codes:
  - Parse: `E_PARSE_CORRUPT`, `E_PARSE_PASSWORD`, `E_PARSE_EMPTY`
  - Classify/LLM: `E_CLASSIFY_INCONCLUSIVE`, `E_LLM_TIMEOUT`, `E_LLM_MALFORMED_JSON`, `E_LLM_SCHEMA_INVALID`, `E_LLM_CONFIDENCE_OOB`
  - Backend: `E_BACKEND_VECTOR_TIMEOUT`, `E_BACKEND_VECTOR_CONNECT`, `E_BACKEND_DB_TIMEOUT`, `E_BACKEND_DB_CONNECT`, `E_BACKEND_EMBED_TIMEOUT`, `E_BACKEND_EMBED_CONNECT`
  - Warning: `W_LLM_RETRY`
- `BaseIngestError` with fields: `code`, `message`, `stage`, `recoverable`

Each package extends:
- Excel: `ErrorCode(BaseErrorCode)` adding 11 Excel-specific codes; `IngestError(BaseIngestError)` adding `sheet_name`
- PDF: `ErrorCode(BaseErrorCode)` adding 27 PDF-specific codes; `IngestError(BaseIngestError)` adding `page_number`

### 7.4 `ingestkit_core/idempotency.py`

Move:
- `compute_ingest_key()` function (generic, only depends on `IngestKey` + stdlib)

### 7.5 `ingestkit_core/config.py` (optional / low priority)

Could extract:
- `load_config_file(path) -> dict` utility (the shared YAML/JSON loading logic)

Or provide a mixin class `ConfigFromFileMixin` with the `from_file()` pattern. Low priority.

### 7.6 `ingestkit_core/pyproject.toml`

```toml
name = "ingestkit-core"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = ["pydantic>=2.0"]
# pandas is only used in TYPE_CHECKING block of protocols.py, not a runtime dep
```

Both sibling packages add `"ingestkit-core>=0.1.0"` to their `dependencies`.

---

## 8. Risks / Reconciliation Needed

### RISK 1: ChunkPayload metadata type divergence (HIGH)

**Problem**: `ChunkPayload` is identical in structure (`id`, `text`, `vector`, `metadata`) but the `metadata` field uses different types:
- Excel: `ChunkMetadata` (20 fields, Excel-specific like `sheet_name`, `db_uri`)
- PDF: `PDFChunkMetadata` (27 fields, PDF-specific like `page_numbers`, `ocr_*`)

**Resolution options**:
1. **Generic ChunkPayload**: `ChunkPayload[M: BaseChunkMetadata]` using Pydantic generics. Excel uses `ChunkPayload[ChunkMetadata]`, PDF uses `ChunkPayload[PDFChunkMetadata]`.
2. **Core defines only BaseChunkMetadata**: Core `ChunkPayload` uses `BaseChunkMetadata` (13 common fields). Each package creates its own metadata subclass and either uses the core payload or defines a package-specific one.
3. **Protocol-only reference**: The `VectorStoreBackend` protocol in core references a `ChunkPayload` with `metadata: BaseChunkMetadata`. Concrete usage in each package upcasts. This is safest for structural subtyping.

**Recommendation**: Option 2. Define `BaseChunkMetadata` and `ChunkPayload` in core. Each package extends `BaseChunkMetadata` with package-specific fields. Since Pydantic supports inheritance, `ChunkPayload(metadata=ExcelChunkMetadata(...))` will work with validation.

### RISK 2: ErrorCode enum extension pattern (MEDIUM)

**Problem**: Python `str, Enum` subclasses cannot be extended after definition. You cannot do `class ErrorCode(BaseErrorCode)` and add new members.

**Resolution options**:
1. **Use `StrEnum` factory / string union**: Core defines shared codes as plain constants or a `StrEnum`. Each package defines its own full `ErrorCode` enum that includes both shared and package-specific values. The base `IngestError.code` field accepts `str` rather than a specific enum.
2. **Composition**: Core defines `SharedErrorCode` enum. Each package defines its own `ErrorCode` with ALL codes (duplicating shared values). Core `BaseIngestError` uses `str` for `code`.
3. **No enum inheritance**: Core exports shared codes as `Final[str]` constants. Each package has its own complete `ErrorCode` enum.

**Recommendation**: Option 1. Core defines `CoreErrorCode(str, Enum)` with 15 shared codes. `BaseIngestError.code` accepts `str`. Each package defines its own `ErrorCode` enum that includes both shared and package-specific codes. During the extraction, existing code that matches on error codes continues to work since values are plain strings.

### RISK 3: IngestError location field divergence (LOW)

**Problem**: Excel uses `sheet_name: str | None`, PDF uses `page_number: int | None`.

**Resolution**: Core `BaseIngestError` has 4 common fields (`code`, `message`, `stage`, `recoverable`). Each package extends with its location field. This is straightforward Pydantic inheritance.

### RISK 4: Import path migration (MEDIUM)

**Problem**: All existing imports like `from ingestkit_excel.models import IngestKey` need to change to `from ingestkit_core.models import IngestKey`. This affects:
- **Excel**: 15+ source/test files with imports from `models.py`, `errors.py`, `protocols.py`
- **PDF**: 10+ source/test files

**Mitigation**: Keep re-exports in each package's `models.py`, `errors.py`, `protocols.py` for backward compatibility during transition. E.g., `from ingestkit_core.models import IngestKey` at the top of Excel's `models.py`, so existing `from ingestkit_excel.models import IngestKey` continues to work.

### RISK 5: ClassificationTier duplication scope (LOW)

Both packages define identical `ClassificationTier` enum. Move to core. No reconciliation needed.

### RISK 6: Test duplication (LOW)

Both packages have tests for `IngestKey`, `WrittenArtifacts`, `EmbedStageResult`. After extraction, these tests should live in `ingestkit-core/tests/` and be removed from sibling packages.

---

## 9. Summary: What Moves vs What Stays

### Moves to `ingestkit-core`

| Type | Name | Source File |
|------|------|------------|
| Protocol | `VectorStoreBackend` | `protocols.py` |
| Protocol | `StructuredDBBackend` | `protocols.py` |
| Protocol | `LLMBackend` | `protocols.py` |
| Protocol | `EmbeddingBackend` | `protocols.py` |
| Model | `IngestKey` | `models.py` |
| Model | `WrittenArtifacts` | `models.py` |
| Model | `EmbedStageResult` | `models.py` |
| Model | `BaseChunkMetadata` | `models.py` (NEW: factored from common fields) |
| Model | `ChunkPayload` | `models.py` (using `BaseChunkMetadata`) |
| Enum | `ClassificationTier` | `models.py` |
| Enum | `CoreErrorCode` | `errors.py` (15 shared codes) |
| Model | `BaseIngestError` | `errors.py` (4 common fields) |
| Function | `compute_ingest_key` | `idempotency.py` |

### Stays Package-Specific

**Excel**: `FileType`, `IngestionMethod`, `RegionType`, `ParserUsed`, `SheetProfile`, `FileProfile`, `SheetRegion`, `ChunkMetadata` (extends `BaseChunkMetadata`), `ClassificationResult`, `ParseStageResult`, `ClassificationStageResult`, `ProcessingResult`, `ErrorCode` (extends core), `IngestError` (extends base with `sheet_name`), `ExcelProcessorConfig`, `ExcelInspector`, `LLMClassifier`, `ParserChain`, `StructuredDBProcessor`

**PDF**: `PDFType`, `PageType`, `IngestionMethod`, `OCREngine`, `ExtractionQualityGrade`, `ContentType`, `ExtractionQuality`, `PageProfile`, `DocumentMetadata`, `DocumentProfile`, `PDFChunkMetadata` (extends `BaseChunkMetadata`), `ClassificationResult`, `OCRResult`, `TableResult`, `ParseStageResult`, `ClassificationStageResult`, `OCRStageResult`, `ProcessingResult`, `ErrorCode` (extends core), `IngestError` (extends base with `page_number`), `PDFProcessorConfig`, `PDFSecurityScanner`, `QualityAssessor`
