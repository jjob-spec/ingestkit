---
issue: 46
title: "Implement ExecutionBackend protocol and distributed backend"
complexity: COMPLEX
agent: MAP
date: 2026-02-14
spec_sections: "None (not in SPEC; new feature)"
files_to_create:
  - packages/ingestkit-excel/src/ingestkit_excel/execution.py
  - packages/ingestkit-excel/tests/test_execution.py
files_to_modify:
  - packages/ingestkit-excel/src/ingestkit_excel/router.py
  - packages/ingestkit-excel/src/ingestkit_excel/config.py
  - packages/ingestkit-excel/src/ingestkit_excel/protocols.py
  - packages/ingestkit-excel/src/ingestkit_excel/__init__.py
  - packages/ingestkit-excel/pyproject.toml
dependencies: []
status: COMPLETE
---

# MAP Artifact -- Issue #46: ExecutionBackend Protocol and Distributed Backend

## Executive Summary

Issue #46 requests a pluggable execution backend abstraction for file processing. The current `ExcelRouter.process_batch()` (router.py:360-379) is a simple sequential loop with no concurrency. The issue asks for an `ExecutionBackend` Protocol with `submit()`/`get_result()` methods, a `LocalExecutionBackend` that wraps existing logic, and a `DistributedExecutionBackend` that submits to a queue (Redis/RabbitMQ). There is NO spec section covering this -- the SPEC ends at section 19 and does not mention ExecutionBackend. The ROADMAP item #1 (Durable State Machine / Dead-Letter Queue) explicitly deferred queue management as the caller's responsibility. This feature extends beyond the SPEC but is a reasonable abstraction layer.

## Investigation Findings

### 1. Current process_batch() Implementation

**File**: `packages/ingestkit-excel/src/ingestkit_excel/router.py` (lines 360-379)

The current implementation is trivially sequential:

```python
def process_batch(self, file_paths: list[str]) -> list[ProcessingResult]:
    results: list[ProcessingResult] = []
    for fp in file_paths:
        results.append(self.process(fp))
    return results
```

Key observations:
- No concurrency (no `ProcessPoolExecutor`, contrary to issue description)
- No parallelism at all -- pure sequential loop
- Each file calls `self.process(fp)` which runs the full pipeline
- Returns results in same order as input

The issue description mentions "refactors existing ProcessPoolExecutor logic from process_batch()" but **no ProcessPoolExecutor exists** in the current codebase. This is a factual error in the issue description. `LocalExecutionBackend` will wrap the sequential `process()` call, not a ProcessPoolExecutor.

### 2. Existing Protocol Patterns

**File**: `packages/ingestkit-core/src/ingestkit_core/protocols.py` (102 lines)

All four existing protocols follow the same pattern:
- `@runtime_checkable` decorator
- `typing.Protocol` base class
- Docstring describing the interface
- Method signatures with `...` (Ellipsis) bodies
- No `ABC` usage (project rule: structural subtyping only)
- Re-exported from `ingestkit_excel/protocols.py` via `from ingestkit_core.protocols import ...`

The new `ExecutionBackend` Protocol should follow this exact pattern. However, since this is an Excel-specific concern (not core), it should live in `ingestkit_excel/protocols.py` rather than `ingestkit_core/protocols.py`.

### 3. Config Structure

**File**: `packages/ingestkit-excel/src/ingestkit_excel/config.py` (119 lines)

`ExcelProcessorConfig` is a Pydantic v2 `BaseModel` with 21+ parameters organized by section. New config fields needed:

- `execution_backend`: str literal (`"local"` or `"distributed"`) -- controls which backend is used
- `execution_max_workers`: int -- for local concurrent execution (if adding ProcessPoolExecutor)
- `queue_url`: str | None -- Redis/RabbitMQ connection URL for distributed backend
- `job_timeout_seconds`: float -- timeout for `get_result()` polling

### 4. ProcessingResult Model

**File**: `packages/ingestkit-excel/src/ingestkit_excel/models.py` (lines 190-214)

`ProcessingResult` is a Pydantic `BaseModel` with 14 fields. Both `LocalExecutionBackend` and `DistributedExecutionBackend` must produce identical `ProcessingResult` instances. This model is already serializable (Pydantic), so it can be serialized/deserialized for queue transport.

### 5. Queue/Redis Infrastructure

**No existing queue infrastructure found.** Grep for redis, rabbitmq, celery, queue, distributed across all `.py` files returned zero relevant matches (only PDF test utilities with unrelated "queue" usage in mock classes).

The `DistributedExecutionBackend` will be the first queue-dependent component. It should be an optional dependency (like qdrant-client and httpx).

### 6. Error Codes

**File**: `packages/ingestkit-excel/src/ingestkit_excel/errors.py` (64 lines)

No execution-related error codes exist. New codes needed:
- `E_EXECUTION_TIMEOUT` -- job did not complete within timeout
- `E_EXECUTION_SUBMIT_FAIL` -- failed to submit job to queue
- `E_EXECUTION_RESULT_LOST` -- job completed but result is unavailable

### 7. ROADMAP Tension

ROADMAP item #1 explicitly defers queue management:
> "Queue management, retry orchestration, and state persistence are the calling system's responsibility. Embedding this here couples the library to specific infrastructure (Redis, Celery, etc.) and makes it unusable outside the RAG system."

This issue partially contradicts that deferral by adding queue infrastructure inside the package. The resolution: `DistributedExecutionBackend` is an **optional, injectable backend** -- the core library never imports Redis directly, and `LocalExecutionBackend` remains the default. The Protocol abstraction keeps the core decoupled.

### 8. Existing Test Patterns

**File**: `packages/ingestkit-excel/tests/conftest.py` (438 lines)

Test infrastructure includes:
- Protocol-conforming mock classes (`MockVectorStore`, `MockStructuredDB`, `MockLLM`, `MockEmbedding`)
- Queue-based response mocking (see `MockLLM.enqueue_classify()`)
- Session-scoped `.xlsx` fixture generators
- `test_config` fixture with test-friendly defaults
- Tests use `@pytest.mark.unit` / `@pytest.mark.integration` markers

New test needs:
- `MockExecutionBackend` -- mock that satisfies the Protocol
- `TestExecutionBackendProtocol` -- Protocol conformance tests
- `TestLocalExecutionBackend` -- verify wraps `process()` correctly
- `TestDistributedExecutionBackend` -- mock queue, verify submit/get_result
- `TestRouterWithExecutionBackend` -- verify router uses injected backend

### 9. __init__.py Exports

**File**: `packages/ingestkit-excel/src/ingestkit_excel/__init__.py` (103 lines)

Must add exports for:
- `ExecutionBackend` (Protocol)
- `LocalExecutionBackend`
- `DistributedExecutionBackend`

## Key Design Decisions for PLAN

### D1: Where to Define the Protocol

The `ExecutionBackend` Protocol should live in `packages/ingestkit-excel/src/ingestkit_excel/execution.py`, NOT in `ingestkit_core/protocols.py`. Reason: This is an Excel-specific orchestration concern. Other ingestkit packages (pdf, docx) may have different execution semantics. If it proves reusable, it can be extracted to core later.

However, the Protocol should ALSO be added to `protocols.py` as a re-export for consistency with the existing pattern (all protocols importable from `ingestkit_excel.protocols`).

### D2: Protocol Method Signatures

Based on the issue description:

```python
@runtime_checkable
class ExecutionBackend(Protocol):
    def submit(self, file_path: str, config: ExcelProcessorConfig) -> str:
        """Submit a file for processing. Returns a job_id."""
        ...

    def get_result(self, job_id: str, timeout: float | None = None) -> ProcessingResult:
        """Retrieve the result for a submitted job. Blocks until complete or timeout."""
        ...
```

Open question: Should `submit()` also accept `source_uri`? The current `process()` method accepts it. Recommendation: Yes, add `source_uri: str | None = None` for parity.

### D3: LocalExecutionBackend Design

This backend wraps `ExcelRouter.process()` synchronously:
- `submit()` calls `self._router.process()` immediately, stores result in a dict keyed by job_id, returns job_id
- `get_result()` looks up result in dict, raises if not found

The "local" backend executes synchronously in `submit()` -- no thread pool or process pool. This matches the current sequential behavior. A future `ConcurrentLocalExecutionBackend` could add ProcessPoolExecutor.

Alternatively, `submit()` could defer execution to `get_result()` (lazy evaluation). But synchronous-in-submit is simpler and matches the issue's "wraps existing process_batch() logic" intent.

Circular dependency concern: `LocalExecutionBackend` needs a reference to `ExcelRouter` to call `process()`, but `ExcelRouter` might hold a reference to the execution backend. Resolution: The router creates and holds the execution backend; the execution backend receives a callback/callable rather than the full router.

Better design: `LocalExecutionBackend.__init__(self, process_fn: Callable[[str, str | None], ProcessingResult])` where `process_fn` is `router.process`. This avoids circular imports and tight coupling.

### D4: DistributedExecutionBackend Design

This backend submits work to a message queue:
- `submit()` serializes `(file_path, config)` and publishes to queue, returns job_id
- `get_result()` polls/waits for result from a result store (Redis key, RabbitMQ reply queue)

Dependencies: `redis` or `pika` (RabbitMQ). Both should be optional.

The distributed backend needs:
1. A serialization format for the job payload (JSON via Pydantic's `.model_dump_json()`)
2. A result storage mechanism (Redis hash, or RabbitMQ RPC pattern)
3. A worker process that consumes jobs (out of scope? or minimal implementation?)

**Critical question**: Does the DistributedExecutionBackend include the worker implementation, or just the client side? The issue says "submits to queue (Redis/RabbitMQ)" which implies client-side only. The worker that dequeues and calls `router.process()` would be a separate concern.

Recommendation: Implement client-side only (submit to queue, poll for result). A minimal worker example can go in documentation but not in the library code.

### D5: Config Changes

Add to `ExcelProcessorConfig`:

```python
# --- Execution backend ---
execution_backend: str = "local"  # "local" or "distributed"
execution_queue_url: str | None = None  # Redis/RabbitMQ URL
execution_job_timeout: float = 300.0  # 5 minutes default
```

"Rollback to local is config-only change" means switching `execution_backend: "local"` should work without code changes.

### D6: Router Integration

`ExcelRouter.process_batch()` should be modified to use the execution backend:

```python
def process_batch(self, file_paths: list[str]) -> list[ProcessingResult]:
    job_ids = [self._execution.submit(fp, self._config) for fp in file_paths]
    return [self._execution.get_result(jid, self._config.execution_job_timeout) for jid in job_ids]
```

The `ExcelRouter.__init__()` should accept an optional `execution` parameter. If not provided, default to `LocalExecutionBackend`.

### D7: Error Handling

New error codes in `errors.py`:
- `E_EXECUTION_TIMEOUT = "E_EXECUTION_TIMEOUT"` -- get_result timed out
- `E_EXECUTION_SUBMIT = "E_EXECUTION_SUBMIT"` -- submit failed
- `E_EXECUTION_NOT_FOUND = "E_EXECUTION_NOT_FOUND"` -- job_id not found in result store

### D8: Test Strategy

**Unit tests (`@pytest.mark.unit`)**:
- Protocol conformance: both backends satisfy `ExecutionBackend`
- `LocalExecutionBackend`: submit returns job_id, get_result returns correct ProcessingResult
- `DistributedExecutionBackend`: mock Redis/pika, verify serialization, verify poll behavior
- Router integration: verify process_batch delegates to execution backend
- Config toggle: verify "local" vs "distributed" instantiates correct backend
- Error cases: timeout, submit failure, unknown job_id

**No integration tests** (would require Redis/RabbitMQ running).

## Dependency Analysis

### Internal Dependencies
- `ExcelProcessorConfig` -- config fields for backend selection
- `ProcessingResult` -- return type from `get_result()`
- `ErrorCode` / `IngestError` -- error handling
- `ExcelRouter.process()` -- called by `LocalExecutionBackend`

### External Dependencies (New, Optional)
- `redis>=4.0` -- for Redis-based distributed backend
- `pika>=1.3` -- for RabbitMQ-based distributed backend (alternative)

### Downstream Consumers
- `ExcelRouter.process_batch()` -- primary consumer
- `__init__.py` -- exports
- `protocols.py` -- re-export of Protocol

## File Inventory

### Files to Create

| File | Purpose | Est. Lines |
|---|---|---|
| `packages/ingestkit-excel/src/ingestkit_excel/execution.py` | ExecutionBackend Protocol, LocalExecutionBackend, DistributedExecutionBackend | ~180 |
| `packages/ingestkit-excel/tests/test_execution.py` | Unit tests for all execution backends | ~250 |

### Files to Modify

| File | Change | Est. Lines Changed |
|---|---|---|
| `packages/ingestkit-excel/src/ingestkit_excel/router.py` | Add execution backend param to `__init__`, modify `process_batch()` | ~25 |
| `packages/ingestkit-excel/src/ingestkit_excel/config.py` | Add execution_backend, execution_queue_url, execution_job_timeout fields | ~8 |
| `packages/ingestkit-excel/src/ingestkit_excel/protocols.py` | Re-export ExecutionBackend | ~3 |
| `packages/ingestkit-excel/src/ingestkit_excel/__init__.py` | Add exports for ExecutionBackend, LocalExecutionBackend, DistributedExecutionBackend | ~8 |
| `packages/ingestkit-excel/src/ingestkit_excel/errors.py` | Add E_EXECUTION_TIMEOUT, E_EXECUTION_SUBMIT, E_EXECUTION_NOT_FOUND | ~5 |
| `packages/ingestkit-excel/pyproject.toml` | Add optional redis/pika dependencies | ~2 |

### Files Read (Reference Only)

| File | What was extracted |
|---|---|
| `SPEC.md` sections 13, 18, 19 | process_batch spec, dependencies, future considerations |
| `ROADMAP.md` item #1 | Deferral of queue management (tension with this issue) |
| `router.py` | Current process_batch() implementation (sequential loop, no ProcessPoolExecutor) |
| `protocols.py` (core + excel) | Protocol pattern: @runtime_checkable, structural subtyping |
| `config.py` | ExcelProcessorConfig structure, Pydantic v2 BaseModel |
| `models.py` | ProcessingResult fields (14 fields, Pydantic serializable) |
| `errors.py` | ErrorCode enum (23 codes), IngestError model |
| `conftest.py` | Mock backend patterns, test fixture conventions |
| `__init__.py` | Current exports |

## Risks and Mitigations

| Risk | Severity | Mitigation |
|---|---|---|
| Circular dependency: LocalExecutionBackend needs router, router needs backend | HIGH | Use callable injection (`process_fn`) instead of router reference |
| DistributedExecutionBackend requires worker implementation to be useful | MEDIUM | Implement client-side only; document worker pattern in docstrings |
| Issue references ProcessPoolExecutor that doesn't exist | LOW | Clarify in implementation -- LocalExecutionBackend wraps sequential process() |
| ROADMAP tension -- package shouldn't own queue infrastructure | MEDIUM | Keep distributed backend optional, Protocol-based, no hard Redis/pika dep |
| Existing test_router.py tests may break if process_batch() signature changes | MEDIUM | Keep backward-compatible -- execution backend is optional param with default |

## Open Questions for PLAN

1. **Should `submit()` accept full router kwargs** (source_uri, etc.) or just file_path + config?
2. **Should `LocalExecutionBackend` support concurrent execution** via ProcessPoolExecutor, or remain sequential?
3. **Which queue system**: Redis only, RabbitMQ only, or both? Issue says "Redis/RabbitMQ" suggesting either.
4. **Worker implementation**: In scope or out of scope for this issue?

---

AGENT_RETURN: .agents/outputs/map-46-021426.md
