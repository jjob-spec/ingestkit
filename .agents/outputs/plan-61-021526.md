---
issue: 61
title: "Implement template system -- CRUD, versioning, and fingerprinting"
agent: PLAN
timestamp: 2026-02-15
status: complete
complexity: COMPLEX
stack: backend
files_to_create:
  - packages/ingestkit-forms/src/ingestkit_forms/stores/__init__.py
  - packages/ingestkit-forms/src/ingestkit_forms/stores/filesystem.py
  - packages/ingestkit-forms/tests/test_stores.py
files_to_modify:
  - packages/ingestkit-forms/src/ingestkit_forms/matcher.py
  - packages/ingestkit-forms/src/ingestkit_forms/api.py
  - packages/ingestkit-forms/tests/conftest.py
  - packages/ingestkit-forms/tests/test_matcher.py
  - packages/ingestkit-forms/tests/test_api.py
  - packages/ingestkit-forms/src/ingestkit_forms/__init__.py
---

# PLAN: Issue #61 -- Template System: CRUD, Versioning, and Fingerprinting

## Executive Summary

Implement three interconnected components: (1) `matcher.py` with layout fingerprinting (`compute_layout_fingerprint`) and similarity scoring (`compute_layout_similarity`), (2) `FileSystemTemplateStore` in `stores/filesystem.py` implementing the `FormTemplateStore` protocol with JSON persistence, tenant-scoped directories, and soft-delete via metadata, (3) `api.py` with template CRUD operations (`create_template`, `update_template`, `delete_template`, `get_template`, `list_templates`, `list_template_versions`) that compose the store and matcher. All config values from `FormProcessorConfig` are used -- no hardcoded constants.

Implementation order: matcher -> store -> API -> fixtures -> tests.

---

## File 1: `matcher.py` (MODIFY -- replace docstring stub)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/matcher.py`

### 1.1 Imports and Module Setup

```python
from __future__ import annotations

import logging
from typing import TYPE_CHECKING

from PIL import Image, ImageFilter

if TYPE_CHECKING:
    from ingestkit_forms.config import FormProcessorConfig

logger = logging.getLogger("ingestkit_forms")
```

### 1.2 Constants

```python
# Quantization thresholds (fill ratio -> level)
# Level 0 (empty):   fill_ratio < 0.05
# Level 1 (sparse):  0.05 <= fill_ratio < 0.25
# Level 2 (partial): 0.25 <= fill_ratio < 0.60
# Level 3 (dense):   fill_ratio >= 0.60
QUANT_THRESHOLDS: tuple[float, float, float] = (0.05, 0.25, 0.60)
```

### 1.3 `compute_layout_fingerprint`

```python
def compute_layout_fingerprint(
    pages: list[Image.Image],
    config: FormProcessorConfig,
) -> bytes:
    """Compute a structural layout fingerprint from pre-rendered page images.

    Algorithm (spec section 5.4):
        1. Convert each page to grayscale.
        2. Apply adaptive thresholding to isolate structural elements.
        3. Divide page into grid_cols x grid_rows grid.
        4. For each cell: compute fill ratio (dark pixels / total pixels).
        5. Quantize to 4 levels: empty(0), sparse(1), partial(2), dense(3).
        6. Concatenate per-page fingerprints (1 byte per cell).

    Args:
        pages: List of PIL.Image objects (pre-rendered page images).
        config: FormProcessorConfig with fingerprint_grid_rows, fingerprint_grid_cols.

    Returns:
        bytes: Concatenated fingerprint. Length = len(pages) * grid_rows * grid_cols.

    Raises:
        ValueError: If pages list is empty.
    """
```

**Algorithm (step by step):**

1. Validate `pages` is non-empty; raise `ValueError` if empty.
2. `grid_rows = config.fingerprint_grid_rows` (default 20)
3. `grid_cols = config.fingerprint_grid_cols` (default 16)
4. Initialize `fingerprint = bytearray()`
5. For each `page` in `pages`:
   a. `gray = page.convert("L")` -- convert to grayscale
   b. Apply adaptive thresholding: use `ImageFilter.MedianFilter(size=3)` to smooth, then convert to binary using Pillow's `point()` method with a local threshold. Specifically:
      - Apply median filter: `smoothed = gray.filter(ImageFilter.MedianFilter(size=3))`
      - Compute global Otsu-like threshold: `threshold = _compute_otsu_threshold(smoothed)`
      - Binarize: `binary = smoothed.point(lambda p: 0 if p < threshold else 255)`
      - (Dark pixels = 0, light pixels = 255 after thresholding)
   c. `width, height = binary.size`
   d. `cell_w = width / grid_cols`
   e. `cell_h = height / grid_rows`
   f. For each row `r` in `range(grid_rows)`:
      - For each col `c` in `range(grid_cols)`:
        - Crop cell region: `left = int(c * cell_w)`, `top = int(r * cell_h)`, `right = int((c + 1) * cell_w)`, `bottom = int((r + 1) * cell_h)`
        - `cell = binary.crop((left, top, right, bottom))`
        - Count dark pixels: `dark_count = sum(1 for p in cell.getdata() if p == 0)`
        - `total = cell.size[0] * cell.size[1]`
        - `fill_ratio = dark_count / total if total > 0 else 0.0`
        - Quantize: `level = _quantize_fill_ratio(fill_ratio)`
        - `fingerprint.append(level)`
6. Return `bytes(fingerprint)`

### 1.4 `_compute_otsu_threshold` (private helper)

```python
def _compute_otsu_threshold(image: Image.Image) -> int:
    """Compute Otsu's threshold for a grayscale PIL Image.

    Returns:
        int: Threshold value (0-255).
    """
```

**Algorithm:**
1. `histogram = image.histogram()` -- 256 bins
2. `total_pixels = sum(histogram)`
3. Standard Otsu implementation: iterate through all thresholds 0-255, find the threshold that maximizes inter-class variance.
4. Return the optimal threshold as `int`.

### 1.5 `_quantize_fill_ratio` (private helper)

```python
def _quantize_fill_ratio(fill_ratio: float) -> int:
    """Quantize a fill ratio to 4 levels.

    Returns:
        0 (empty), 1 (sparse), 2 (partial), or 3 (dense).
    """
    if fill_ratio < QUANT_THRESHOLDS[0]:
        return 0
    elif fill_ratio < QUANT_THRESHOLDS[1]:
        return 1
    elif fill_ratio < QUANT_THRESHOLDS[2]:
        return 2
    else:
        return 3
```

### 1.6 `compute_layout_similarity`

```python
def compute_layout_similarity(
    fp_a: bytes,
    fp_b: bytes,
    grid_cols: int,
    grid_rows: int,
) -> float:
    """Compare two layout fingerprints and return similarity score.

    Algorithm (spec section 5.4):
        1. Deserialize fingerprints into per-page grids (grid_cols * grid_rows per page).
        2. If page counts differ -> 0.0.
        3. For each cell: exact match = 1.0, off-by-one = 0.5, off-by-two+ = 0.0.
        4. Similarity = sum(cell_scores) / total_cells.

    Args:
        fp_a: First fingerprint bytes.
        fp_b: Second fingerprint bytes.
        grid_cols: Number of columns in the grid.
        grid_rows: Number of rows in the grid.

    Returns:
        float: Similarity score between 0.0 and 1.0.
    """
```

**Algorithm:**
1. `cells_per_page = grid_cols * grid_rows`
2. Validate both fingerprints have length divisible by `cells_per_page`. If not, return `0.0`.
3. `pages_a = len(fp_a) // cells_per_page`
4. `pages_b = len(fp_b) // cells_per_page`
5. If `pages_a != pages_b`, return `0.0`
6. `total_cells = len(fp_a)`
7. `score_sum = 0.0`
8. For each index `i` in `range(total_cells)`:
   - `diff = abs(fp_a[i] - fp_b[i])`
   - If `diff == 0`: `score_sum += 1.0`
   - Elif `diff == 1`: `score_sum += 0.5`
   - Else: `score_sum += 0.0`
9. Return `score_sum / total_cells` if `total_cells > 0` else `0.0`

### 1.7 `compute_layout_fingerprint_from_file` (file-based convenience)

```python
def compute_layout_fingerprint_from_file(
    file_path: str,
    config: FormProcessorConfig,
    renderer: PageRenderer | None = None,
) -> bytes:
    """Compute fingerprint from a file path.

    For image files (.jpg, .jpeg, .png, .tiff, .tif): loads directly via Pillow.
    For other formats: delegates to the provided renderer callable.

    Args:
        file_path: Path to the document.
        config: FormProcessorConfig.
        renderer: Optional callable (file_path, dpi) -> list[Image.Image].
            Required for PDF and Excel formats.

    Returns:
        bytes: Layout fingerprint.

    Raises:
        FormIngestError: With E_FORM_FINGERPRINT_FAILED if rendering fails.
    """
```

**Algorithm:**
1. Detect extension from `file_path` (use `pathlib.Path(file_path).suffix.lower()`).
2. `IMAGE_EXTENSIONS = {".jpg", ".jpeg", ".png", ".tiff", ".tif"}`
3. If extension in `IMAGE_EXTENSIONS`:
   - `img = Image.open(file_path)`
   - `pages = [img]`
4. Else if `renderer` is not None:
   - `pages = renderer(file_path, config.fingerprint_dpi)`
5. Else:
   - Raise `FormIngestError(code=FormErrorCode.E_FORM_FINGERPRINT_FAILED, message=f"No renderer available for format '{ext}'. Provide a renderer callable.", stage="fingerprint", recoverable=False)`
6. Return `compute_layout_fingerprint(pages, config)`

### 1.8 Type Alias

```python
from typing import Callable
PageRenderer = Callable[[str, int], list[Image.Image]]
```

Define at module level after imports.

---

## File 2: `stores/__init__.py` (CREATE)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/stores/__init__.py`

```python
"""Template store implementations for ingestkit-forms."""

from ingestkit_forms.stores.filesystem import FileSystemTemplateStore

__all__ = ["FileSystemTemplateStore"]
```

---

## File 3: `stores/filesystem.py` (CREATE)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/stores/filesystem.py`

### 3.1 Imports and Module Setup

```python
from __future__ import annotations

import json
import logging
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

from ingestkit_forms.errors import FormErrorCode, FormIngestError
from ingestkit_forms.models import FormTemplate

logger = logging.getLogger("ingestkit_forms")
```

### 3.2 `_TemplateMeta` Internal Model

```python
from pydantic import BaseModel, Field

class _TemplateMeta(BaseModel):
    """Internal metadata for a template tracked by the filesystem store.

    Stored as _meta.json per template_id directory.
    NOT part of the public API or the FormTemplate model.
    """
    template_id: str
    latest_version: int = 1
    deleted_versions: list[int] = Field(default_factory=list)
    all_deleted: bool = False
```

### 3.3 `FileSystemTemplateStore` Class

```python
class FileSystemTemplateStore:
    """Filesystem-based FormTemplateStore implementation.

    Directory structure:
        {base_path}/{template_id}/v{version}.json  -- template data
        {base_path}/{template_id}/_meta.json        -- deletion/version metadata

    Implements FormTemplateStore protocol (structural subtyping).
    Passes isinstance(store, FormTemplateStore) check.
    """

    def __init__(self, base_path: str) -> None:
        """Initialize the store.

        Args:
            base_path: Root directory for template storage.
                Created if it does not exist.
        """
        self._base_path = Path(base_path)
        self._base_path.mkdir(parents=True, exist_ok=True)
```

### 3.4 `save_template` Method

```python
def save_template(self, template: FormTemplate) -> None:
    """Persist a template (insert or update).

    Creates directory {base_path}/{template_id}/ if needed.
    Writes template as v{version}.json.
    Updates _meta.json with latest_version.
    """
```

**Algorithm:**
1. `template_dir = self._base_path / template.template_id`
2. `template_dir.mkdir(parents=True, exist_ok=True)`
3. Serialize template: `data = template.model_dump(mode="json")`
4. Handle `bytes` fields: `layout_fingerprint` and `thumbnail` are already serialized by `_serialize_bytes` in `model_dump(mode="json")` as hex strings.
5. Write `template_dir / f"v{template.version}.json"` with `json.dumps(data, indent=2)`
6. Load or create `_meta.json`:
   - `meta = self._load_meta(template.template_id)`
   - If `meta is None`: create new `_TemplateMeta(template_id=template.template_id, latest_version=template.version)`
   - Else: update `meta.latest_version = max(meta.latest_version, template.version)`
7. Write updated `_meta.json` via `self._save_meta(template.template_id, meta)`

### 3.5 `get_template` Method

```python
def get_template(
    self, template_id: str, version: int | None = None
) -> FormTemplate | None:
    """Retrieve a template by ID. None if not found.

    If version is None, returns the latest version.
    Returns None if the template/version is soft-deleted.
    """
```

**Algorithm:**
1. `meta = self._load_meta(template_id)`
2. If `meta is None`: return `None`
3. If `version is None`: `version = meta.latest_version`
4. If `meta.all_deleted` or `version in meta.deleted_versions`: return `None`
5. `file_path = self._base_path / template_id / f"v{version}.json"`
6. If not `file_path.exists()`: return `None`
7. Load JSON, deserialize to `FormTemplate`:
   - `data = json.loads(file_path.read_text())`
   - Deserialize `layout_fingerprint` and `thumbnail` from hex: `if data.get("layout_fingerprint"): data["layout_fingerprint"] = bytes.fromhex(data["layout_fingerprint"])`
   - Same for `thumbnail`.
   - Return `FormTemplate(**data)`

### 3.6 `list_templates` Method

```python
def list_templates(
    self,
    tenant_id: str | None = None,
    source_format: str | None = None,
    active_only: bool = True,
) -> list[FormTemplate]:
    """List templates matching the filters.

    Returns the latest version of each template.
    If active_only=True (default), excludes soft-deleted templates.
    """
```

**Algorithm:**
1. `results = []`
2. Iterate over subdirectories of `self._base_path`:
   - For each `template_dir` that is a directory:
     - `template_id = template_dir.name`
     - `meta = self._load_meta(template_id)`
     - If `meta is None`: skip
     - If `active_only` and `meta.all_deleted`: skip
     - `template = self.get_template(template_id)` -- gets latest non-deleted version
     - If `template is None`: skip
     - If `tenant_id is not None` and `template.tenant_id != tenant_id`: skip
     - If `source_format is not None` and `template.source_format.value != source_format`: skip
     - `results.append(template)`
3. Return `results`

### 3.7 `list_versions` Method

```python
def list_versions(self, template_id: str) -> list[FormTemplate]:
    """List all versions of a template, ordered by version descending.

    Includes soft-deleted versions (the caller can check deletion state
    via the store's metadata if needed).
    """
```

**Algorithm:**
1. `template_dir = self._base_path / template_id`
2. If not `template_dir.exists()`: return `[]`
3. Collect all `v*.json` files (exclude `_meta.json`).
4. For each file, load as `FormTemplate` using `self._load_template_file(file_path)`.
5. Sort by `version` descending.
6. Return the list.

### 3.8 `delete_template` Method

```python
def delete_template(
    self, template_id: str, version: int | None = None
) -> None:
    """Soft-delete a template or specific version.

    If version is None, marks all versions as deleted (sets all_deleted=True).
    If version is specified, adds that version to deleted_versions.
    Files are NOT removed from disk (audit trail preservation).
    """
```

**Algorithm:**
1. `meta = self._load_meta(template_id)`
2. If `meta is None`: raise `FormIngestError(code=FormErrorCode.E_FORM_TEMPLATE_NOT_FOUND, message=f"Template '{template_id}' not found", stage="template_store", recoverable=False)`
3. If `version is None`:
   - `meta.all_deleted = True`
4. Else:
   - Verify version file exists; if not raise `FormIngestError`
   - If `version not in meta.deleted_versions`: `meta.deleted_versions.append(version)`
   - If all versions are now deleted, set `meta.all_deleted = True`
5. `self._save_meta(template_id, meta)`

### 3.9 `get_all_fingerprints` Method

```python
def get_all_fingerprints(
    self,
    tenant_id: str | None = None,
    source_format: str | None = None,
) -> list[tuple[str, str, int, bytes]]:
    """Return (template_id, name, version, fingerprint) for all active templates.

    Used by the matcher for efficient batch comparison.
    Only returns templates with non-None layout_fingerprint.
    """
```

**Algorithm:**
1. `templates = self.list_templates(tenant_id=tenant_id, source_format=source_format, active_only=True)`
2. `results = []`
3. For each `t` in `templates`:
   - If `t.layout_fingerprint is not None`:
     - `results.append((t.template_id, t.name, t.version, t.layout_fingerprint))`
4. Return `results`

### 3.10 Private Helpers

```python
def _load_meta(self, template_id: str) -> _TemplateMeta | None:
    """Load _meta.json for a template. Returns None if not found."""
    meta_path = self._base_path / template_id / "_meta.json"
    if not meta_path.exists():
        return None
    data = json.loads(meta_path.read_text())
    return _TemplateMeta(**data)

def _save_meta(self, template_id: str, meta: _TemplateMeta) -> None:
    """Write _meta.json for a template."""
    meta_path = self._base_path / template_id / "_meta.json"
    meta_path.write_text(json.dumps(meta.model_dump(), indent=2))

def _load_template_file(self, file_path: Path) -> FormTemplate:
    """Load a single template JSON file and return a FormTemplate."""
    data = json.loads(file_path.read_text())
    # Deserialize hex-encoded bytes fields
    if data.get("layout_fingerprint"):
        data["layout_fingerprint"] = bytes.fromhex(data["layout_fingerprint"])
    if data.get("thumbnail"):
        data["thumbnail"] = bytes.fromhex(data["thumbnail"])
    return FormTemplate(**data)
```

---

## File 4: `api.py` (MODIFY -- replace docstring stub)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/api.py`

### 4.1 Imports and Module Setup

```python
from __future__ import annotations

import logging
import uuid
from datetime import datetime, timezone
from typing import TYPE_CHECKING

from ingestkit_forms.errors import FormErrorCode, FormIngestError
from ingestkit_forms.matcher import (
    PageRenderer,
    compute_layout_fingerprint_from_file,
)
from ingestkit_forms.models import (
    FormTemplate,
    FormTemplateCreateRequest,
    FormTemplateUpdateRequest,
)

if TYPE_CHECKING:
    from ingestkit_forms.config import FormProcessorConfig
    from ingestkit_forms.protocols import FormTemplateStore

logger = logging.getLogger("ingestkit_forms")
```

### 4.2 `FormTemplateAPI` Class

```python
class FormTemplateAPI:
    """Template CRUD operations for the form ingestor plugin.

    Composes a FormTemplateStore (persistence) and matcher (fingerprinting)
    to implement create, update, delete, get, list, and list_versions.
    """

    def __init__(
        self,
        store: FormTemplateStore,
        config: FormProcessorConfig,
        renderer: PageRenderer | None = None,
    ) -> None:
        """Initialize the API.

        Args:
            store: FormTemplateStore implementation for persistence.
            config: FormProcessorConfig with fingerprint and matching params.
            renderer: Optional page renderer for non-image file formats.
        """
        self._store = store
        self._config = config
        self._renderer = renderer
```

### 4.3 `create_template` Method

```python
def create_template(
    self,
    template_def: FormTemplateCreateRequest,
) -> FormTemplate:
    """Create a new template.

    Generates UUID, computes layout fingerprint from sample_file_path,
    sets version=1, persists via store.

    Returns:
        FormTemplate: The created template.

    Raises:
        FormIngestError: E_FORM_FINGERPRINT_FAILED if fingerprint computation fails.
        FormIngestError: E_FORM_TEMPLATE_STORE_UNAVAILABLE if store write fails.
    """
```

**Algorithm:**
1. `template_id = str(uuid.uuid4())`
2. Compute fingerprint:
   - `try:` `fingerprint = compute_layout_fingerprint_from_file(template_def.sample_file_path, self._config, self._renderer)`
   - `except Exception as exc:` Log warning, set `fingerprint = None`, emit warning. Do NOT fail template creation if fingerprint fails -- template can still be used with manual assignment.
3. `now = datetime.now(timezone.utc)`
4. Build `FormTemplate`:
   ```python
   template = FormTemplate(
       template_id=template_id,
       name=template_def.name,
       description=template_def.description,
       version=1,
       source_format=template_def.source_format,
       page_count=template_def.page_count,
       fields=template_def.fields,
       layout_fingerprint=fingerprint,
       created_at=now,
       updated_at=now,
       created_by=template_def.created_by,
       tenant_id=template_def.tenant_id,
   )
   ```
5. `self._store.save_template(template)`
6. Log: `logger.info("Created template '%s' (id=%s, v1)", template.name, template_id)`
7. Return `template`

### 4.4 `update_template` Method

```python
def update_template(
    self,
    template_id: str,
    template_def: FormTemplateUpdateRequest,
) -> FormTemplate:
    """Update a template, creating a new version.

    Loads the latest version, increments version, applies partial updates,
    recomputes fingerprint if new sample_file_path is provided.

    Returns:
        FormTemplate: The new version.

    Raises:
        FormIngestError: E_FORM_TEMPLATE_NOT_FOUND if template doesn't exist.
    """
```

**Algorithm:**
1. `existing = self._store.get_template(template_id)`
2. If `existing is None`: raise `FormIngestError(code=FormErrorCode.E_FORM_TEMPLATE_NOT_FOUND, ...)`
3. `new_version = existing.version + 1`
4. Apply partial updates from `template_def` (only non-None fields):
   - `name = template_def.name if template_def.name is not None else existing.name`
   - `description = template_def.description if template_def.description is not None else existing.description`
   - `page_count = template_def.page_count if template_def.page_count is not None else existing.page_count`
   - `fields = template_def.fields if template_def.fields is not None else existing.fields`
5. Recompute fingerprint if `template_def.sample_file_path` is provided:
   - `try:` `fingerprint = compute_layout_fingerprint_from_file(template_def.sample_file_path, self._config, self._renderer)`
   - `except Exception:` Keep existing fingerprint, log warning.
   - If no new `sample_file_path`: `fingerprint = existing.layout_fingerprint`
6. `now = datetime.now(timezone.utc)`
7. Build new `FormTemplate`:
   ```python
   updated = FormTemplate(
       template_id=template_id,
       name=name,
       description=description,
       version=new_version,
       source_format=existing.source_format,  # source_format is immutable
       page_count=page_count,
       fields=fields,
       layout_fingerprint=fingerprint,
       thumbnail=existing.thumbnail,
       created_at=existing.created_at,  # preserve original creation time
       updated_at=now,
       created_by=existing.created_by,
       tenant_id=existing.tenant_id,
   )
   ```
8. `self._store.save_template(updated)`
9. Log: `logger.info("Updated template '%s' (id=%s, v%d)", updated.name, template_id, new_version)`
10. Return `updated`

### 4.5 `delete_template` Method

```python
def delete_template(
    self,
    template_id: str,
    version: int | None = None,
) -> None:
    """Soft-delete a template or specific version.

    Delegates to store.delete_template(). Raises if template not found.
    """
```

**Algorithm:**
1. `self._store.delete_template(template_id, version)` -- store raises `FormIngestError` if not found
2. Log: `logger.info("Deleted template %s (version=%s)", template_id, version or "all")`

### 4.6 `get_template` Method

```python
def get_template(
    self,
    template_id: str,
    version: int | None = None,
) -> FormTemplate:
    """Get a specific template by ID.

    If version is None, returns the latest version.
    Raises E_FORM_TEMPLATE_NOT_FOUND if not found.
    """
```

**Algorithm:**
1. `template = self._store.get_template(template_id, version)`
2. If `template is None`: raise `FormIngestError(code=FormErrorCode.E_FORM_TEMPLATE_NOT_FOUND, message=f"Template '{template_id}' version {version or 'latest'} not found", stage="api", recoverable=False)`
3. Return `template`

### 4.7 `list_templates` Method

```python
def list_templates(
    self,
    tenant_id: str | None = None,
    source_format: str | None = None,
) -> list[FormTemplate]:
    """List all active templates, optionally filtered by tenant and format.

    Returns the latest version of each template.
    """
```

**Algorithm:**
1. Return `self._store.list_templates(tenant_id=tenant_id, source_format=source_format, active_only=True)`

### 4.8 `list_template_versions` Method

```python
def list_template_versions(
    self,
    template_id: str,
) -> list[FormTemplate]:
    """List all versions of a template, ordered by version descending."""
```

**Algorithm:**
1. `versions = self._store.list_versions(template_id)`
2. If `len(versions) == 0`: raise `FormIngestError(code=FormErrorCode.E_FORM_TEMPLATE_NOT_FOUND, ...)`
3. Return `versions`

---

## File 5: `conftest.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/tests/conftest.py`

### 5.1 Updates

Replace the placeholder `form_config` fixture to return an actual `FormProcessorConfig`:

```python
from ingestkit_forms.config import FormProcessorConfig

@pytest.fixture()
def form_config():
    """Return a FormProcessorConfig with all defaults."""
    return FormProcessorConfig()
```

Replace the placeholder `mock_template_store` fixture with a real in-memory mock:

```python
from ingestkit_forms.models import FormTemplate

class MockFormTemplateStore:
    """In-memory FormTemplateStore for unit testing.

    Implements the FormTemplateStore protocol without filesystem I/O.
    """

    def __init__(self):
        # {template_id: {version: FormTemplate}}
        self._templates: dict[str, dict[int, FormTemplate]] = {}
        self._deleted: dict[str, set[int]] = {}  # template_id -> set of deleted versions
        self._all_deleted: set[str] = set()  # template_ids that are fully deleted

    def save_template(self, template: FormTemplate) -> None: ...
    def get_template(self, template_id: str, version: int | None = None) -> FormTemplate | None: ...
    def list_templates(self, tenant_id=None, source_format=None, active_only=True) -> list[FormTemplate]: ...
    def list_versions(self, template_id: str) -> list[FormTemplate]: ...
    def delete_template(self, template_id: str, version: int | None = None) -> None: ...
    def get_all_fingerprints(self, tenant_id=None, source_format=None) -> list[tuple[str, str, int, bytes]]: ...
```

Implementation follows the same logic as `FileSystemTemplateStore` but uses dictionaries instead of files. Each method is straightforward (3-10 lines). The mock needs to pass `isinstance(mock, FormTemplateStore)`.

Add image fixtures:

```python
from PIL import Image

@pytest.fixture()
def blank_page_image():
    """Return a 1200x1600 white image (simulates a blank letter-size page at 150 DPI)."""
    return Image.new("L", (1200, 1600), color=255)

@pytest.fixture()
def form_like_image():
    """Return a synthetic image with structural elements (lines, boxes) for fingerprint testing."""
    from PIL import ImageDraw
    img = Image.new("L", (1200, 1600), color=255)
    draw = ImageDraw.Draw(img)
    # Draw header bar
    draw.rectangle([0, 0, 1200, 100], fill=0)
    # Draw field boxes
    for i in range(5):
        y = 200 + i * 200
        draw.rectangle([50, y, 600, y + 40], outline=0, width=2)
        draw.rectangle([650, y, 1150, y + 40], outline=0, width=2)
    # Draw footer line
    draw.line([0, 1500, 1200, 1500], fill=0, width=3)
    return img

@pytest.fixture()
def sample_image_file(tmp_path, form_like_image):
    """Save form_like_image to a .png file and return the path string."""
    path = tmp_path / "sample_form.png"
    form_like_image.save(str(path))
    return str(path)
```

---

## File 6: `test_matcher.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/tests/test_matcher.py`

### Test Cases

All tests marked `@pytest.mark.unit`.

| Test Function | What It Validates |
|---|---|
| `test_compute_fingerprint_single_page` | Fingerprint from a single `form_like_image` has length `grid_rows * grid_cols` (320 bytes). |
| `test_compute_fingerprint_blank_page` | Fingerprint of a blank white image is all zeros (empty cells). |
| `test_compute_fingerprint_multi_page` | Two-page fingerprint has length `2 * grid_rows * grid_cols` (640 bytes). |
| `test_compute_fingerprint_deterministic` | Same image produces identical fingerprint on two calls. |
| `test_compute_fingerprint_empty_pages_raises` | Empty list raises `ValueError`. |
| `test_compute_fingerprint_values_in_range` | All byte values in result are 0, 1, 2, or 3. |
| `test_compute_fingerprint_custom_grid` | Config with `grid_rows=10, grid_cols=8` produces fingerprint of length 80. |
| `test_quantize_fill_ratio` | Direct test of `_quantize_fill_ratio` with boundary values: 0.0->0, 0.04->0, 0.05->1, 0.24->1, 0.25->2, 0.59->2, 0.60->3, 1.0->3. |
| `test_similarity_identical` | Two identical fingerprints produce similarity 1.0. |
| `test_similarity_completely_different` | All-zeros vs all-threes produces 0.0. |
| `test_similarity_off_by_one` | Fingerprint where every cell is off-by-one produces 0.5. |
| `test_similarity_page_count_mismatch` | One-page vs two-page fingerprints produce 0.0. |
| `test_similarity_empty_fingerprints` | Two empty bytes produce 0.0 (edge case). |
| `test_similarity_mixed_diffs` | Mix of exact, off-by-one, off-by-two produces expected weighted score. |
| `test_fingerprint_from_file_image` | `compute_layout_fingerprint_from_file` with a .png file succeeds. |
| `test_fingerprint_from_file_unsupported_no_renderer` | .pdf without renderer raises `FormIngestError` with `E_FORM_FINGERPRINT_FAILED`. |
| `test_fingerprint_from_file_with_renderer` | .pdf with mock renderer produces fingerprint. |

---

## File 7: `test_stores.py` (CREATE)

**Full path:** `packages/ingestkit-forms/tests/test_stores.py`

### Test Cases

All tests marked `@pytest.mark.unit`. Each test creates a `FileSystemTemplateStore(tmp_path / "templates")`.

| Test Function | What It Validates |
|---|---|
| `test_protocol_compliance` | `isinstance(store, FormTemplateStore)` is `True`. |
| `test_save_and_get_template` | Save a template, get it back, all fields match. |
| `test_get_template_latest_version` | Save v1 and v2, `get_template(id)` returns v2. |
| `test_get_template_specific_version` | Save v1 and v2, `get_template(id, version=1)` returns v1. |
| `test_get_template_not_found` | `get_template("nonexistent")` returns `None`. |
| `test_list_templates_returns_latest` | Save two templates with multiple versions, `list_templates()` returns one entry per template (latest version). |
| `test_list_templates_tenant_filter` | Two templates with different `tenant_id`, filter returns correct subset. |
| `test_list_templates_format_filter` | Two templates with different `source_format`, filter returns correct subset. |
| `test_list_templates_active_only` | Delete one template, `list_templates(active_only=True)` excludes it. |
| `test_list_versions` | Save three versions, `list_versions(id)` returns all three ordered descending. |
| `test_list_versions_not_found` | `list_versions("nonexistent")` returns empty list. |
| `test_delete_all_versions` | `delete_template(id)` with no version soft-deletes all. `get_template(id)` returns `None`. |
| `test_delete_specific_version` | `delete_template(id, version=1)` marks v1 deleted. `get_template(id, version=1)` returns `None`. `get_template(id)` returns latest non-deleted version. |
| `test_delete_nonexistent_raises` | `delete_template("nonexistent")` raises `FormIngestError`. |
| `test_get_all_fingerprints` | Save templates with/without fingerprints. Only those with fingerprints appear in results. |
| `test_get_all_fingerprints_filters` | Verify `tenant_id` and `source_format` filters work. |
| `test_bytes_round_trip` | Save template with `layout_fingerprint=b'\x00\x01\x02\x03'`, retrieve, bytes match exactly. |
| `test_persistence_across_instances` | Save with one store instance, create a new `FileSystemTemplateStore` pointing to same path, retrieve succeeds. |

Helper: A `_make_template()` factory function that creates a `FormTemplate` with minimal required fields and sensible defaults.

---

## File 8: `test_api.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/tests/test_api.py`

### Test Cases

All tests marked `@pytest.mark.unit`. Uses `MockFormTemplateStore` from `conftest.py` and mocks for fingerprinting.

| Test Function | What It Validates |
|---|---|
| `test_create_template` | Creates template with valid request, verifies UUID generated, version=1, store contains template, fingerprint computed. |
| `test_create_template_fingerprint_failure_still_succeeds` | If fingerprint computation raises, template is still created with `layout_fingerprint=None`. |
| `test_update_template` | Update with new name and fields, version increments, previous version retained in store. |
| `test_update_template_with_new_sample` | Update with `sample_file_path`, fingerprint is recomputed. |
| `test_update_template_not_found` | Update on nonexistent template raises `FormIngestError` with `E_FORM_TEMPLATE_NOT_FOUND`. |
| `test_update_template_preserves_immutables` | `source_format`, `tenant_id`, `created_at`, `created_by` are NOT changed by update. |
| `test_delete_template_all` | `delete_template(id)` delegates to store. Subsequent `get_template` raises. |
| `test_delete_template_specific_version` | `delete_template(id, version=1)` delegates correctly. |
| `test_get_template_found` | Returns the template from store. |
| `test_get_template_not_found` | Raises `FormIngestError` with `E_FORM_TEMPLATE_NOT_FOUND`. |
| `test_list_templates` | Delegates to store with correct filters. |
| `test_list_template_versions` | Returns versions from store ordered descending. |
| `test_list_template_versions_not_found` | Raises `FormIngestError` if no versions exist. |

Setup pattern:
```python
@pytest.fixture()
def template_api(mock_template_store, form_config, sample_image_file):
    """Create a FormTemplateAPI with mock store and test config."""
    from ingestkit_forms.api import FormTemplateAPI
    return FormTemplateAPI(
        store=mock_template_store,
        config=form_config,
        renderer=None,  # tests use image files directly
    )
```

For fingerprint mocking in tests that need to control fingerprint behavior, use `unittest.mock.patch` on `compute_layout_fingerprint_from_file`.

---

## File 9: `__init__.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/__init__.py`

Add exports for the new public API:

```python
from ingestkit_forms.api import FormTemplateAPI
from ingestkit_forms.matcher import (
    compute_layout_fingerprint,
    compute_layout_similarity,
    compute_layout_fingerprint_from_file,
)
from ingestkit_forms.stores import FileSystemTemplateStore
```

Add to `__all__`:
```python
# API (from issue #61)
"FormTemplateAPI",
# Matcher (from issue #61)
"compute_layout_fingerprint",
"compute_layout_similarity",
"compute_layout_fingerprint_from_file",
# Stores (from issue #61)
"FileSystemTemplateStore",
```

---

## Implementation Order

1. `matcher.py` -- no dependencies on store or API
2. `stores/__init__.py` + `stores/filesystem.py` -- depends on models only
3. `api.py` -- depends on matcher + store
4. `conftest.py` -- test fixtures for all three
5. `test_matcher.py` -- test fingerprinting in isolation
6. `test_stores.py` -- test store persistence
7. `test_api.py` -- test CRUD with mock store
8. `__init__.py` -- export new public symbols

---

## Acceptance Criteria

- [ ] `matcher.py`: `compute_layout_fingerprint(pages, config)` produces `bytes` of length `pages * rows * cols`, values 0-3
- [ ] `matcher.py`: `compute_layout_similarity(fp_a, fp_b, cols, rows)` returns 0.0-1.0, page mismatch = 0.0
- [ ] `matcher.py`: `compute_layout_fingerprint_from_file()` handles images directly, raises for unsupported formats without renderer
- [ ] `matcher.py`: Fingerprint is deterministic for same input
- [ ] `matcher.py`: Config values used (not hardcoded grid dimensions)
- [ ] `stores/filesystem.py`: `FileSystemTemplateStore` implements all 6 `FormTemplateStore` protocol methods
- [ ] `stores/filesystem.py`: `isinstance(store, FormTemplateStore)` passes
- [ ] `stores/filesystem.py`: Soft-delete tracked in `_meta.json`, not in `FormTemplate` model
- [ ] `stores/filesystem.py`: `bytes` fields (fingerprint, thumbnail) round-trip via hex encoding
- [ ] `api.py`: `create_template()` generates UUID, computes fingerprint, sets version=1, persists
- [ ] `api.py`: `update_template()` increments version, applies partial updates, recomputes fingerprint if new sample
- [ ] `api.py`: `delete_template()` soft-deletes via store
- [ ] `api.py`: `get_template()` returns template or raises `E_FORM_TEMPLATE_NOT_FOUND`
- [ ] `api.py`: `list_templates()` returns latest active versions with optional filters
- [ ] `api.py`: `list_template_versions()` returns all versions ordered descending
- [ ] All new code has unit tests, no external services required
- [ ] No `ABC` base classes, only `Protocol` structural subtyping
- [ ] No hardcoded constants for grid dimensions or thresholds

---

## Verification Gates

```bash
# All unit tests pass
pytest packages/ingestkit-forms/tests -m unit -v

# New test files run specifically
pytest packages/ingestkit-forms/tests/test_matcher.py -v
pytest packages/ingestkit-forms/tests/test_stores.py -v
pytest packages/ingestkit-forms/tests/test_api.py -v

# Protocol isinstance check
python -c "from ingestkit_forms.stores.filesystem import FileSystemTemplateStore; from ingestkit_forms.protocols import FormTemplateStore; s = FileSystemTemplateStore('/tmp/test_fs_store'); print(isinstance(s, FormTemplateStore))"

# No regressions
pytest packages/ingestkit-forms/tests -v
```

---

AGENT_RETURN: .agents/outputs/plan-61-021526.md
