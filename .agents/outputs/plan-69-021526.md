---
issue: 69
agent: PLAN
date: 2026-02-15
complexity: COMPLEX
stack: backend
files_to_create: 2
files_to_modify: 4
estimated_tests: 18
---

# PLAN - Issue #69: FormRouter and Plugin API Surface

## Executive Summary

Implement `FormRouter` (the orchestrator for the form extraction pipeline) and expand the API surface with 4 new operations. The router follows the ExcelRouter pattern: DI-based constructor, single-file `extract_form()` pipeline, batch processing, and a `create_default_router()` factory. The existing `FormTemplateAPI` gains 4 methods (`render_document`, `preview_extraction`, `match_document`, `extract_form`) by composing the router internally. The `idempotency.py` stub is implemented with two key functions. All new code is tested with mock backends already present in `conftest.py`.

## Key Design Decisions

### D1: FormRouter Constructor Dependencies

The router accepts all backends via DI. Optional backends are `None`-able:

```python
FormRouter.__init__(
    template_store: FormTemplateStore,
    fingerprinter: LayoutFingerprinter,
    form_db: FormDBBackend,
    vector_store: VectorStoreBackend,
    embedder: EmbeddingBackend,
    ocr_backend: OCRBackend | None = None,
    pdf_widget_backend: PDFWidgetBackend | None = None,
    vlm_backend: VLMBackend | None = None,
    config: FormProcessorConfig | None = None,
)
```

**Rationale**: Mirrors ExcelRouter pattern. OCR/PDF/VLM are optional because Excel forms need none of them. The router constructs internal components (FormMatcher, extractors, FormDualWriter) from these backends.

### D2: Pipeline Step Sequence for `extract_form()`

The `extract_form(request: FormIngestRequest) -> FormProcessingResult` method follows spec 4.2:

1. **Compute global ingest key** -- call `compute_form_ingest_key()` (delegates to `ingestkit_core.idempotency.compute_ingest_key`).
2. **Generate ingest_run_id** -- `uuid4()`.
3. **Template resolution** -- if `request.template_id` is set: `matcher.resolve_manual_override(request)`. Otherwise: `matcher.match_document(request.file_path)` and pick top match above threshold. If no match and no template_id: return `None` (graceful fallthrough per spec 4.1 principle 8).
4. **Compute form extraction key** -- `compute_form_extraction_key(ingest_key_global, template_id, template_version)`.
5. **Detect source format** -- `detect_source_format(request.file_path)` (already in matcher.py).
6. **Select and run extractor** -- based on source format + PDF field detection (see D3).
7. **Confidence scoring** -- `compute_overall_confidence(fields, template)` + per-field `apply_confidence_actions()`.
8. **VLM fallback** -- if `vlm_backend` provided and `config.form_vlm_enabled`: `VLMFieldExtractor.apply_vlm_fallback()` on fields marked `vlm_fallback_pending`.
9. **Fail-closed check** -- if `overall_confidence < config.form_extraction_min_overall_confidence`: return result with `E_FORM_EXTRACTION_LOW_CONFIDENCE` and zero outputs.
10. **Build FormExtractionResult** -- assemble from steps above.
11. **Dual write** -- `FormDualWriter.write()` returns `(written, errors, warnings, error_details, embed_result)`.
12. **Assemble FormProcessingResult** -- combine all artifacts.

### D3: Source Detection and Extractor Selection

Implementation of spec 3.1 flow:

```python
def _select_extractor(self, file_path: str, template: FormTemplate) -> tuple[str, Callable]:
    fmt = detect_source_format(file_path)
    if fmt == SourceFormat.XLSX:
        return "cell_mapping", self._excel_extractor.extract
    if fmt == SourceFormat.PDF:
        if self._pdf_widget_backend and self._pdf_widget_backend.has_form_fields(file_path):
            return "native_fields", self._native_pdf_extractor.extract
        # Fallback: OCR for scanned/flattened PDFs
        if self._ocr_backend:
            return "ocr_overlay", self._ocr_extractor.extract
        raise FormIngestException(E_FORM_OCR_FAILED, "No OCR backend for scanned PDF")
    if fmt == SourceFormat.IMAGE:
        if self._ocr_backend:
            return "ocr_overlay", self._ocr_extractor.extract
        raise FormIngestException(E_FORM_OCR_FAILED, "No OCR backend for image")
```

Key detail: `NativePDFExtractor` already handles internal fallback to OCR (it accepts `ocr_backend` in its constructor). The router's role is selecting the *primary* extractor path. If `pdf_widget_backend` is `None`, all PDFs go through OCR.

### D4: API Surface Expansion

**Approach**: Add 4 methods directly to `FormTemplateAPI`. The class already holds `_store` and `_config`. It will also accept an optional `router: FormRouter | None` and required dependencies for the new operations.

Updated constructor:

```python
class FormTemplateAPI:
    def __init__(
        self,
        store: FormTemplateStore,
        config: FormProcessorConfig,
        renderer: PageRenderer | None = None,
        matcher: FormMatcher | None = None,      # NEW: for match_document
        router: FormRouter | None = None,         # NEW: for extract_form + preview
    ) -> None:
```

New methods:
- `render_document(file_path, page=0, dpi=150) -> bytes` -- delegates to `_rendering.get_page_image()` then converts to PNG bytes. Falls back to `self._renderer` callable for PDFs.
- `preview_extraction(file_path, template_id, template_version=None) -> ExtractionPreview` -- loads template, runs extractor via router's internal `_run_extraction()` (without dual-write), returns preview.
- `match_document(file_path, tenant_id=None) -> list[TemplateMatch]` -- delegates to `self._matcher.match_document()`.
- `extract_form(request: FormIngestRequest) -> FormProcessingResult` -- delegates to `self._router.extract_form(request)`.

**Why not a new class?** The spec defines `FormPluginAPI` as a Protocol with 10 operations. The existing `FormTemplateAPI` already has 6 of 10. Adding 4 is cleaner than splitting into two classes and maintains a single entry point for the orchestration layer.

### D5: `create_default_router()` Factory

Since no concrete backends exist yet in `ingestkit-forms`, the factory will:
1. Accept all backends as optional kwargs (same pattern as ExcelRouter factory).
2. Import from `ingestkit_forms.stores` for `FileSystemTemplateStore` (already exists).
3. For DB/vector/embedding: raise `ImportError` with clear message if not provided (no default concrete backends yet).
4. For OCR/PDF/VLM: pass `None` if not provided (gracefully optional).

```python
def create_default_router(**overrides) -> FormRouter:
    # template_store defaults to FileSystemTemplateStore
    # fingerprinter defaults to None -- requires explicit injection
    # form_db, vector_store, embedder -- REQUIRED, no defaults
    # ocr_backend, pdf_widget_backend, vlm_backend -- optional (None)
```

This is intentionally more restrictive than ExcelRouter's factory because ingestkit-forms has no concrete backend subpackage. The caller (orchestration layer) provides backends.

### D6: Idempotency Key Functions

Two functions in `idempotency.py`:

```python
def compute_form_ingest_key(
    file_path: str,
    parser_version: str,
    tenant_id: str | None = None,
    source_uri: str | None = None,
) -> IngestKey:
    """Global ingest key. Delegates to ingestkit_core.idempotency.compute_ingest_key."""
    return core_compute_ingest_key(file_path, parser_version, tenant_id, source_uri)

def compute_form_extraction_key(
    ingest_key_global: str,
    template_id: str,
    template_version: int,
) -> str:
    """Form-specific extraction key = sha256(ingest_key_global + template_id + str(template_version))."""
    return hashlib.sha256(
        f"{ingest_key_global}|{template_id}|{template_version}".encode()
    ).hexdigest()
```

Note: Issue #71 was originally scoped to implement these, but #69 needs them. Since both functions are simple (5 lines each), implementing them here avoids a blocking dependency. If #71 adds more complex logic later, it can extend these.

### D7: Graceful Fallthrough

When `extract_form()` is called without `template_id` and auto-matching returns no matches: return `None`. This signals the orchestration layer to continue to the standard pipeline. The spec (4.1 principle 8) requires "zero overhead beyond the matching check."

The return type of `FormRouter.extract_form()` is `FormProcessingResult | None`. A `None` return means "not a form -- continue standard pipeline."

### D8: FormProcessingResult Assembly

After dual-write, the result is assembled from:
- `file_path`: from request
- `ingest_key`: global ingest key string
- `ingest_run_id`: generated UUID
- `tenant_id`: from config or request
- `extraction_result`: the `FormExtractionResult` built from extraction + confidence
- `embed_result`: from dual-writer
- `chunks_created`: `len(written.vector_point_ids)`
- `tables_created`: `len(written.db_table_names)`
- `tables`: `written.db_table_names`
- `written`: `FormWrittenArtifacts` from dual-writer
- `errors`, `warnings`, `error_details`: accumulated through pipeline
- `processing_time_seconds`: `time.monotonic()` delta

## File-by-File Implementation Plan

### File 1: `packages/ingestkit-forms/src/ingestkit_forms/idempotency.py`
**Action**: Replace stub with implementation.

- Import `compute_ingest_key` from `ingestkit_core.idempotency` and `hashlib`.
- Implement `compute_form_ingest_key()` -- thin wrapper around core function.
- Implement `compute_form_extraction_key()` -- SHA-256 of `ingest_key_global|template_id|template_version`.
- ~25 lines total.

### File 2: `packages/ingestkit-forms/src/ingestkit_forms/router.py`
**Action**: Replace stub with full implementation (~300 lines).

**Class `FormRouter`**:
- Constructor (lines ~30): accept 9 DI params per D1, build internal components:
  - `FormMatcher(template_store, fingerprinter, config)`
  - `ExcelCellExtractor(config)`
  - `NativePDFExtractor(pdf_widget_backend, config, ocr_backend)` if pdf_widget_backend
  - `OCROverlayExtractor(ocr_backend, config)` if ocr_backend
  - `VLMFieldExtractor(vlm_backend, config)` if vlm_backend
  - `FormDBWriter(form_db, config)`
  - `FormChunkWriter(vector_store, embedder, config)`
  - `FormDualWriter(db_writer, chunk_writer, config)`
- `extract_form(request: FormIngestRequest) -> FormProcessingResult | None`: full pipeline per D2.
- `extract_form_batch(requests: list[FormIngestRequest]) -> list[FormProcessingResult | None]`: sequential iteration.
- `_select_extractor(file_path, template) -> tuple[str, list[ExtractedField]]`: per D3.
- `_run_extraction(file_path, template) -> tuple[str, list[ExtractedField], float]`: runs extractor, measures time.
- `_apply_confidence_and_vlm(fields, template) -> tuple[list[ExtractedField], float, list[str]]`: per-field confidence actions + VLM fallback + overall confidence.
- `_build_extraction_result(...)` -> `FormExtractionResult`: assembles from extraction data.

**Function `create_default_router`**:
- Accept `**overrides` kwargs per D5.
- Build `FileSystemTemplateStore` as default template_store.
- Require `form_db`, `vector_store`, `embedder` -- raise `ValueError` if missing.
- Wire up and return `FormRouter`.

### File 3: `packages/ingestkit-forms/src/ingestkit_forms/api.py`
**Action**: Extend `FormTemplateAPI` with 4 new methods (~120 lines added).

- Add `matcher` and `router` optional params to `__init__`.
- `render_document(file_path, page=0, dpi=150) -> bytes`:
  - Use `_rendering.get_page_image()` for images/PDFs.
  - Convert resulting PIL Image to PNG bytes via `io.BytesIO`.
  - Raise `FormIngestException` if rendering fails.
- `preview_extraction(file_path, template_id, template_version=None) -> ExtractionPreview`:
  - Require `self._router` is not None.
  - Load template via `self._store.get_template()`.
  - Call router's internal `_run_extraction()` + confidence scoring (no dual-write).
  - Return `ExtractionPreview`.
- `match_document(file_path, tenant_id=None) -> list[TemplateMatch]`:
  - Require `self._matcher` is not None.
  - Delegate to `self._matcher.match_document(file_path)`.
- `extract_form(request: FormIngestRequest) -> FormProcessingResult`:
  - Require `self._router` is not None.
  - Delegate to `self._router.extract_form(request)`.

### File 4: `packages/ingestkit-forms/src/ingestkit_forms/__init__.py`
**Action**: Add exports (~10 lines added).

Add to imports and `__all__`:
- `FormRouter` from `router`
- `create_default_router` from `router`
- `compute_form_ingest_key` from `idempotency`
- `compute_form_extraction_key` from `idempotency`

### File 5: `packages/ingestkit-forms/tests/test_router.py`
**Action**: Replace stub with full test suite (~350 lines).

Test categories:
1. **Constructor tests** (2):
   - `test_router_init_all_backends`: all backends provided, verify internal components created.
   - `test_router_init_minimal_backends`: only required backends, optional=None.

2. **Extractor selection tests** (4):
   - `test_select_extractor_xlsx`: returns `cell_mapping`.
   - `test_select_extractor_pdf_with_fields`: returns `native_fields` when `has_form_fields()` is True.
   - `test_select_extractor_pdf_without_fields`: returns `ocr_overlay` when `has_form_fields()` is False.
   - `test_select_extractor_image`: returns `ocr_overlay`.

3. **Pipeline tests** (6):
   - `test_extract_form_manual_template`: happy path with manual template_id, verify full result.
   - `test_extract_form_auto_match`: auto-matching picks template, verify match_method="auto_detect".
   - `test_extract_form_no_match_fallthrough`: no template_id, no match -> returns `None`.
   - `test_extract_form_low_confidence_fail_closed`: overall confidence below threshold -> error result.
   - `test_extract_form_vlm_fallback_triggered`: VLM-enabled config, low-confidence field -> VLM applied.
   - `test_extract_form_batch`: processes 2 requests, verify list of results.

4. **Error handling tests** (3):
   - `test_extract_form_unsupported_format`: file with `.docx` -> `E_FORM_UNSUPPORTED_FORMAT`.
   - `test_extract_form_template_not_found`: manual template_id not in store -> `E_FORM_TEMPLATE_NOT_FOUND`.
   - `test_extract_form_dual_write_error`: mock DB failure -> errors in result, result still returned.

5. **Factory tests** (2):
   - `test_create_default_router_with_backends`: pass all required backends, get router.
   - `test_create_default_router_missing_required`: omit required backend -> `ValueError`.

6. **Idempotency integration** (1):
   - `test_idempotency_keys_deterministic`: same inputs produce same keys, different template_version produces different extraction key.

**Mock strategy**: Use existing mocks from `conftest.py` (MockFormTemplateStore, MockFormDBBackend, MockVectorStoreBackend, MockEmbeddingBackend, MockOCRBackend, MockPDFWidgetBackend, MockVLMBackend, MockLayoutFingerprinter). For the extract_form pipeline tests, populate MockFormTemplateStore with a test template and mock the extractors to return canned `ExtractedField` lists. The extractors themselves are already tested in `test_extractors.py`; router tests verify orchestration, not extraction correctness.

**Key fixture**: A `form_router` fixture that builds a `FormRouter` with all mock backends:
```python
@pytest.fixture()
def form_router(mock_template_store, mock_fingerprinter, mock_form_db,
                mock_vector_store, mock_embedder, mock_ocr_backend,
                mock_pdf_widget_backend, mock_vlm_backend, form_config):
    return FormRouter(
        template_store=mock_template_store,
        fingerprinter=mock_fingerprinter,
        form_db=mock_form_db,
        vector_store=mock_vector_store,
        embedder=mock_embedder,
        ocr_backend=mock_ocr_backend,
        pdf_widget_backend=mock_pdf_widget_backend,
        vlm_backend=mock_vlm_backend,
        config=form_config,
    )
```

### File 6: `packages/ingestkit-forms/tests/test_api.py`
**Action**: Add tests for the 4 new API methods (~80 lines added).

- `test_match_document_delegates_to_matcher`
- `test_extract_form_delegates_to_router`
- `test_preview_extraction_returns_preview`
- `test_render_document_returns_png_bytes`
- `test_api_methods_raise_without_dependencies`: calling extract_form without router raises clear error.

### File 7: `packages/ingestkit-forms/tests/conftest.py`
**Action**: No new mock classes needed. All required mocks already exist. May add 1-2 convenience fixtures if needed during implementation:
- `form_router` fixture combining all mock backends (see test_router.py section above -- may live in test_router.py instead of conftest.py to avoid cross-test coupling).

## Acceptance Criteria

- [ ] `FormRouter.__init__` accepts all 9 backend dependencies via DI
- [ ] `FormRouter.extract_form()` implements the full pipeline: ingest key -> match/resolve -> extract -> confidence -> VLM -> fail-closed check -> dual-write -> result
- [ ] `FormRouter.extract_form()` returns `None` when no template matches and no manual template_id
- [ ] `FormRouter.extract_form()` returns result with `E_FORM_EXTRACTION_LOW_CONFIDENCE` when overall confidence is below threshold
- [ ] Source detection correctly routes: .xlsx->ExcelCell, .pdf+fields->NativePDF, .pdf-fields->OCR, image->OCR
- [ ] `create_default_router()` factory follows ExcelRouter pattern with explicit backend injection
- [ ] `compute_form_ingest_key()` delegates to core and returns `IngestKey`
- [ ] `compute_form_extraction_key()` produces deterministic SHA-256 from global key + template_id + version
- [ ] `FormTemplateAPI` gains `render_document`, `preview_extraction`, `match_document`, `extract_form`
- [ ] `__init__.py` exports `FormRouter`, `create_default_router`, `compute_form_ingest_key`, `compute_form_extraction_key`
- [ ] All new public methods have unit tests with mock backends
- [ ] No concrete backend implementations inside `ingestkit_forms/`
- [ ] No `ABC` classes used -- structural subtyping via `Protocol` only
- [ ] PII-safe logging: no field values logged unless `log_sample_data=True`
- [ ] All tests pass: `pytest packages/ingestkit-forms/tests -m unit`

## Verification Gates

```bash
# Unit tests (all, not just new)
pytest packages/ingestkit-forms/tests -v

# Coverage check
pytest packages/ingestkit-forms/tests --cov=ingestkit_forms --cov-report=term-missing

# Import check (no circular imports)
python -c "from ingestkit_forms import FormRouter, create_default_router, compute_form_ingest_key, compute_form_extraction_key"
```

---
AGENT_RETURN: plan-69-021526.md
