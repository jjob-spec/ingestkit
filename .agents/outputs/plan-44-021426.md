---
issue: 44
agent: PLAN
date: 2026-02-14
complexity: SIMPLE
stack: backend
spec_sections: "§12.4, §12.5"
files_to_modify:
  - packages/ingestkit-pdf/src/ingestkit_pdf/utils/ocr_engines.py
  - packages/ingestkit-pdf/tests/test_ocr_engines.py
  - packages/ingestkit-pdf/src/ingestkit_pdf/utils/__init__.py
---

# PLAN Artifact: Issue #44 -- PaddleOCR Adapter and Engine Fallback Chain

## Executive Summary

Issue #44 replaces the PaddleOCR stub in `ocr_engines.py` (lines 194-199) with a working `PaddleOCREngine` class and updates the `create_ocr_engine()` factory to return it when `paddleocr` is importable. The adapter converts PIL Images to numpy arrays, parses PaddleOCR's nested `[[[bbox, (text, conf)], ...]]` result structure, and returns `OCRPageResult` with line-level confidence. The fallback chain (PaddleOCR -> Tesseract -> `EngineUnavailableError`) is already structurally present; the change removes the artificial `raise ImportError` and wires up the real class. Unit tests use mocks (no PaddleOCR dependency); integration tests are gated behind `@pytest.mark.ocr_paddle`.

## File-by-File Implementation

---

### 1. `packages/ingestkit-pdf/src/ingestkit_pdf/utils/ocr_engines.py` (~80 lines added)

#### 1a. Add `_PADDLEOCR_LANG_MAP` dict and `_to_paddleocr_lang()` (after line 98)

Insert a new language mapping section between the Tesseract language mapping and the availability check. Mirror the pattern of `_LANGUAGE_MAP` / `_to_tesseract_lang()`.

```python
# ---------------------------------------------------------------------------
# PaddleOCR language mapping
# ---------------------------------------------------------------------------

_PADDLEOCR_LANG_MAP: dict[str, str] = {
    "zh": "ch",
    "ko": "korean",
    "ja": "japan",
    "de": "german",
}


def _to_paddleocr_lang(language: str) -> str:
    """Map ISO 639-1 language code to PaddleOCR's expected code.

    PaddleOCR uses ISO 639-1 directly for most languages, with a few
    exceptions (zh -> ch, ko -> korean, ja -> japan, de -> german).
    Unmapped codes pass through as-is.
    """
    return _PADDLEOCR_LANG_MAP.get(language, language)
```

**Design note**: The map only contains exceptions where PaddleOCR deviates from ISO 639-1. Languages like `"en"`, `"fr"`, `"es"`, `"pt"`, `"it"`, `"ru"`, `"ar"`, `"hi"` pass through unchanged because PaddleOCR accepts them directly. This is simpler and more correct than duplicating identity mappings from `language.py`.

#### 1b. Add `PaddleOCREngine` class (after `TesseractEngine`, before Factory section)

```python
# ---------------------------------------------------------------------------
# PaddleOCR adapter
# ---------------------------------------------------------------------------


class PaddleOCREngine:
    """Adapter for PaddleOCR. Optional, higher accuracy (~96.6% vs ~89%).

    PaddleOCR returns line-level text with confidence, unlike Tesseract's
    word-level output.  Each ``ProcessPoolExecutor`` worker must create its
    own instance (known PaddleOCR thread-safety issue per SPEC §12.4).
    """

    def __init__(self, lang: str = "en") -> None:
        import paddleocr as _paddleocr  # noqa: F811

        self._lang = _to_paddleocr_lang(lang)
        self._ocr = _paddleocr.PaddleOCR(
            lang=self._lang,
            use_angle_cls=True,
            show_log=False,
        )

    def recognize(self, image: Image.Image, language: str) -> OCRPageResult:
        """Run PaddleOCR on an image.

        Parameters
        ----------
        image:
            PIL Image to recognize.
        language:
            ISO 639-1 language code.  Mapped to PaddleOCR format internally.
            Overrides the instance default if provided.
        """
        import numpy as np

        paddle_lang = _to_paddleocr_lang(language) if language else self._lang

        # Re-create engine if language differs from init (PaddleOCR is lang-bound)
        if paddle_lang != self._lang:
            import paddleocr as _paddleocr

            ocr = _paddleocr.PaddleOCR(
                lang=paddle_lang,
                use_angle_cls=True,
                show_log=False,
            )
        else:
            ocr = self._ocr

        img_array = np.array(image)
        result = ocr.ocr(img_array, cls=True)

        # Parse nested structure: result = [[line1, line2, ...]]
        # Each line = [bounding_box, (text, confidence)]
        # result can be None or [[None]] for empty pages
        lines: list[str] = []
        confidences: list[float] = []

        if result is not None:
            for page_lines in result:
                if page_lines is None:
                    continue
                for line in page_lines:
                    if line is None:
                        continue
                    # line = [bbox, (text, conf)]
                    text_conf = line[1]
                    text_val = text_conf[0]
                    conf_val = text_conf[1]
                    if text_val.strip():
                        lines.append(text_val.strip())
                        confidences.append(float(conf_val))

        full_text = "\n".join(lines)
        avg_confidence = (
            sum(confidences) / len(confidences) if confidences else 0.0
        )

        return OCRPageResult(
            text=full_text,
            confidence=avg_confidence,
            word_confidences=confidences if confidences else None,
            language_detected=None,
        )

    def name(self) -> str:
        """Return the engine name."""
        return "paddleocr"
```

**Key design decisions**:

1. **`import paddleocr` in `__init__`**: If `paddleocr` is not installed, `__init__` raises `ImportError`, which the factory catches for fallback. This is the same lazy-import pattern as `TesseractEngine` with `pytesseract`.

2. **`import numpy` in `recognize`**: Deferred import keeps the module importable without numpy at load time (though numpy is a transitive dep via pandas).

3. **Language re-creation**: PaddleOCR instances are bound to a language at creation time. If `recognize()` is called with a different language than `__init__`, we create a temporary instance. This is safe because each worker has its own engine (per SPEC §12.4).

4. **Line joining with `\n`**: PaddleOCR returns line-level text (not words), so lines are joined with newlines, not spaces (unlike Tesseract which joins words with spaces).

5. **`word_confidences` stores line-level confidences**: The Protocol field name is `word_confidences` but PaddleOCR operates at line granularity. Per MAP decision D5, we repurpose this field for line-level confidences.

6. **`show_log=False`**: Suppresses PaddleOCR's verbose internal logging per MAP decision D5.

7. **`cls=True` in `ocr.ocr()`**: Enables text angle classification, matching `use_angle_cls=True` in the constructor.

#### 1c. Update `create_ocr_engine()` factory (replace lines 194-199)

Replace the stub that artificially raises `ImportError`:

**Before** (lines 194-199):
```python
if config.ocr_engine == OCREngine.PADDLEOCR:
    try:
        import paddleocr  # noqa: F401
        # PaddleOCREngine adapter not yet implemented (future issue)
        raise ImportError("PaddleOCREngine adapter not yet implemented")
    except ImportError:
```

**After**:
```python
if config.ocr_engine == OCREngine.PADDLEOCR:
    try:
        return PaddleOCREngine(lang=config.ocr_language), warnings
    except ImportError:
```

This is a 3-line replacement. The `PaddleOCREngine.__init__()` does `import paddleocr`, so if the package is missing, `ImportError` propagates naturally. The existing `except ImportError` block with `W_OCR_ENGINE_FALLBACK` warning and Tesseract fallthrough remains unchanged.

---

### 2. `packages/ingestkit-pdf/src/ingestkit_pdf/utils/__init__.py` (~2 lines changed)

Add `PaddleOCREngine` to both the import and `__all__`:

**Import line** (update line 11-17):
```python
from ingestkit_pdf.utils.ocr_engines import (
    EngineUnavailableError,
    OCREngineInterface,
    OCRPageResult,
    PaddleOCREngine,
    TesseractEngine,
    create_ocr_engine,
)
```

**`__all__` list** (add between `"OCRPageResult"` and `"PageRenderer"`):
```python
    "PaddleOCREngine",
```

---

### 3. `packages/ingestkit-pdf/tests/test_ocr_engines.py` (~150 lines added)

#### 3a. Update imports (line 13-22)

Add `PaddleOCREngine`, `_PADDLEOCR_LANG_MAP`, and `_to_paddleocr_lang` to imports:

```python
from ingestkit_pdf.utils.ocr_engines import (
    EngineUnavailableError,
    OCREngineInterface,
    OCRPageResult,
    PaddleOCREngine,
    TesseractEngine,
    _LANGUAGE_MAP,
    _PADDLEOCR_LANG_MAP,
    _tesseract_available,
    _to_paddleocr_lang,
    _to_tesseract_lang,
    create_ocr_engine,
)
```

#### 3b. Add `TestPaddleOCRLanguageMapping` class (~25 lines)

Insert after `TestLanguageMapping`, marked `@pytest.mark.unit`:

```python
@pytest.mark.unit
class TestPaddleOCRLanguageMapping:
    """Tests for _to_paddleocr_lang() and _PADDLEOCR_LANG_MAP."""

    def test_chinese_maps_to_ch(self) -> None:
        assert _to_paddleocr_lang("zh") == "ch"

    def test_korean_maps_to_korean(self) -> None:
        assert _to_paddleocr_lang("ko") == "korean"

    def test_japanese_maps_to_japan(self) -> None:
        assert _to_paddleocr_lang("ja") == "japan"

    def test_german_maps_to_german(self) -> None:
        assert _to_paddleocr_lang("de") == "german"

    def test_english_passes_through(self) -> None:
        assert _to_paddleocr_lang("en") == "en"

    def test_french_passes_through(self) -> None:
        assert _to_paddleocr_lang("fr") == "fr"

    def test_unknown_code_passes_through(self) -> None:
        assert _to_paddleocr_lang("xyz") == "xyz"

    def test_map_only_contains_exceptions(self) -> None:
        """Map should only contain codes where PaddleOCR deviates from ISO 639-1."""
        assert "en" not in _PADDLEOCR_LANG_MAP
        assert "fr" not in _PADDLEOCR_LANG_MAP
```

#### 3c. Add `TestPaddleOCREngine` class (~90 lines)

Insert after `TestTesseractEngine`, marked `@pytest.mark.unit`. All tests mock `paddleocr` and `numpy` -- no real PaddleOCR dependency.

Helper function for building mock PaddleOCR results:

```python
def _mock_paddleocr_result(
    lines: list[tuple[str, float]],
) -> list[list[list]]:
    """Build a mock PaddleOCR ocr() return value.

    PaddleOCR returns: [[[bbox, (text, conf)], ...]]
    """
    page_lines = []
    for text, conf in lines:
        bbox = [[0, 0], [100, 0], [100, 20], [0, 20]]  # dummy bbox
        page_lines.append([bbox, (text, conf)])
    return [page_lines]
```

Test class:

```python
@pytest.mark.unit
class TestPaddleOCREngine:
    """Tests for PaddleOCREngine adapter (mock-based, no real PaddleOCR)."""

    @pytest.fixture()
    def mock_paddleocr(self) -> MagicMock:
        """Mock the paddleocr module and its PaddleOCR class."""
        mock_module = MagicMock()
        mock_ocr_instance = MagicMock()
        mock_module.PaddleOCR.return_value = mock_ocr_instance
        with patch.dict(sys.modules, {"paddleocr": mock_module}):
            yield mock_module

    @pytest.fixture()
    def mock_numpy(self) -> MagicMock:
        """Mock numpy.array for PIL-to-ndarray conversion."""
        mock_np = MagicMock()
        mock_np.array.return_value = MagicMock()  # fake ndarray
        with patch.dict(sys.modules, {"numpy": mock_np}):
            yield mock_np

    def test_name_returns_paddleocr(self, mock_paddleocr: MagicMock) -> None:
        engine = PaddleOCREngine()
        assert engine.name() == "paddleocr"

    def test_init_creates_paddleocr_instance(self, mock_paddleocr: MagicMock) -> None:
        PaddleOCREngine(lang="en")
        mock_paddleocr.PaddleOCR.assert_called_once_with(
            lang="en", use_angle_cls=True, show_log=False,
        )

    def test_init_maps_language(self, mock_paddleocr: MagicMock) -> None:
        PaddleOCREngine(lang="zh")
        mock_paddleocr.PaddleOCR.assert_called_once_with(
            lang="ch", use_angle_cls=True, show_log=False,
        )

    def test_init_raises_import_error_when_not_installed(self) -> None:
        """Without paddleocr in sys.modules, __init__ raises ImportError."""
        saved = sys.modules.pop("paddleocr", None)
        try:
            original_import = (
                __builtins__.__import__
                if hasattr(__builtins__, "__import__")
                else __import__
            )

            def _fake_import(name: str, *args: Any, **kwargs: Any) -> Any:
                if name == "paddleocr":
                    raise ImportError("mocked missing")
                return original_import(name, *args, **kwargs)

            with patch("builtins.__import__", side_effect=_fake_import):
                with pytest.raises(ImportError):
                    PaddleOCREngine()
        finally:
            if saved is not None:
                sys.modules["paddleocr"] = saved

    def test_recognize_basic(
        self, mock_paddleocr: MagicMock, mock_numpy: MagicMock,
    ) -> None:
        engine = PaddleOCREngine()
        ocr_instance = mock_paddleocr.PaddleOCR.return_value
        ocr_instance.ocr.return_value = _mock_paddleocr_result([
            ("Hello world", 0.95),
            ("Second line", 0.88),
        ])

        image = MagicMock()
        result = engine.recognize(image, language="en")

        assert result.text == "Hello world\nSecond line"
        assert result.confidence == pytest.approx(0.915)
        assert result.word_confidences == [0.95, 0.88]
        mock_numpy.array.assert_called_once_with(image)

    def test_recognize_empty_page_none_result(
        self, mock_paddleocr: MagicMock, mock_numpy: MagicMock,
    ) -> None:
        engine = PaddleOCREngine()
        ocr_instance = mock_paddleocr.PaddleOCR.return_value
        ocr_instance.ocr.return_value = None

        result = engine.recognize(MagicMock(), language="en")

        assert result.text == ""
        assert result.confidence == 0.0
        assert result.word_confidences is None

    def test_recognize_empty_page_nested_none(
        self, mock_paddleocr: MagicMock, mock_numpy: MagicMock,
    ) -> None:
        engine = PaddleOCREngine()
        ocr_instance = mock_paddleocr.PaddleOCR.return_value
        ocr_instance.ocr.return_value = [[None]]

        result = engine.recognize(MagicMock(), language="en")

        assert result.text == ""
        assert result.confidence == 0.0

    def test_recognize_empty_list_result(
        self, mock_paddleocr: MagicMock, mock_numpy: MagicMock,
    ) -> None:
        engine = PaddleOCREngine()
        ocr_instance = mock_paddleocr.PaddleOCR.return_value
        ocr_instance.ocr.return_value = [[]]

        result = engine.recognize(MagicMock(), language="en")

        assert result.text == ""
        assert result.confidence == 0.0

    def test_recognize_filters_whitespace_only_lines(
        self, mock_paddleocr: MagicMock, mock_numpy: MagicMock,
    ) -> None:
        engine = PaddleOCREngine()
        ocr_instance = mock_paddleocr.PaddleOCR.return_value
        ocr_instance.ocr.return_value = _mock_paddleocr_result([
            ("Hello", 0.9),
            ("  ", 0.5),
            ("World", 0.8),
        ])

        result = engine.recognize(MagicMock(), language="en")

        assert result.text == "Hello\nWorld"
        assert len(result.word_confidences) == 2

    def test_recognize_maps_language(
        self, mock_paddleocr: MagicMock, mock_numpy: MagicMock,
    ) -> None:
        """When recognize() language differs from init, a new OCR instance is created."""
        engine = PaddleOCREngine(lang="en")
        ocr_instance = mock_paddleocr.PaddleOCR.return_value
        ocr_instance.ocr.return_value = _mock_paddleocr_result([("text", 0.9)])

        engine.recognize(MagicMock(), language="zh")

        # Second call to PaddleOCR() for the different language
        calls = mock_paddleocr.PaddleOCR.call_args_list
        assert len(calls) == 2
        assert calls[1][1]["lang"] == "ch"

    def test_confidence_already_0_to_1(
        self, mock_paddleocr: MagicMock, mock_numpy: MagicMock,
    ) -> None:
        """PaddleOCR confidence is already 0-1 (unlike Tesseract's 0-100)."""
        engine = PaddleOCREngine()
        ocr_instance = mock_paddleocr.PaddleOCR.return_value
        ocr_instance.ocr.return_value = _mock_paddleocr_result([
            ("word", 0.966),
        ])

        result = engine.recognize(MagicMock(), language="en")

        assert result.word_confidences == [0.966]
        assert result.confidence == pytest.approx(0.966)

    def test_satisfies_protocol(self, mock_paddleocr: MagicMock) -> None:
        engine = PaddleOCREngine()
        assert isinstance(engine, OCREngineInterface)

    def test_default_lang_is_en(self, mock_paddleocr: MagicMock) -> None:
        engine = PaddleOCREngine()
        assert engine._lang == "en"
```

#### 3d. Update `TestOCREngineInterface` (add 1 test)

Add test that `PaddleOCREngine` satisfies the Protocol:

```python
def test_paddleocr_engine_satisfies_protocol(self) -> None:
    mock_module = MagicMock()
    mock_module.PaddleOCR.return_value = MagicMock()
    with patch.dict(sys.modules, {"paddleocr": mock_module}):
        engine = PaddleOCREngine()
        assert isinstance(engine, OCREngineInterface)
```

#### 3e. Update `TestCreateOCREngine` (add 1 test)

Add test that factory returns `PaddleOCREngine` when paddleocr is importable:

```python
@patch("ingestkit_pdf.utils.ocr_engines._tesseract_available", return_value=True)
def test_paddleocr_config_returns_paddleocr_engine_when_available(
    self, mock_avail: MagicMock,
) -> None:
    mock_module = MagicMock()
    mock_module.PaddleOCR.return_value = MagicMock()
    with patch.dict(sys.modules, {"paddleocr": mock_module}):
        config = _make_config(ocr_engine=OCREngine.PADDLEOCR)
        engine, warnings = create_ocr_engine(config)
        assert isinstance(engine, PaddleOCREngine)
        assert warnings == []
```

#### 3f. Add integration test class (~15 lines, gated)

```python
@pytest.mark.ocr_paddle
class TestPaddleOCREngineIntegration:
    """Integration tests requiring real PaddleOCR installation.

    Run with: pytest -m ocr_paddle
    Skip in CI unless PaddleOCR is installed.
    """

    def test_recognize_simple_image(self) -> None:
        """Smoke test: recognize text from a simple synthetic image."""
        from PIL import Image, ImageDraw, ImageFont

        img = Image.new("RGB", (200, 50), color="white")
        draw = ImageDraw.Draw(img)
        draw.text((10, 10), "Hello", fill="black")

        engine = PaddleOCREngine(lang="en")
        result = engine.recognize(img, language="en")

        assert isinstance(result, OCRPageResult)
        assert result.confidence > 0.0
        assert len(result.text) > 0
```

---

## Acceptance Criteria

- [ ] `PaddleOCREngine` class exists in `ocr_engines.py` with `__init__`, `recognize`, and `name` methods matching SPEC §12.4 signatures
- [ ] `_PADDLEOCR_LANG_MAP` dict maps zh->ch, ko->korean, ja->japan, de->german; all other codes pass through
- [ ] `_to_paddleocr_lang()` function converts ISO 639-1 to PaddleOCR codes
- [ ] `PaddleOCREngine.__init__` does `import paddleocr` (raises `ImportError` if missing) and creates `PaddleOCR(lang=..., use_angle_cls=True, show_log=False)`
- [ ] `PaddleOCREngine.recognize()` converts PIL Image to numpy array, calls `ocr.ocr()`, parses nested result structure
- [ ] Empty/None OCR results produce `OCRPageResult(text="", confidence=0.0, word_confidences=None)`
- [ ] Lines joined with `\n` (not spaces); whitespace-only lines filtered out
- [ ] Confidence values are 0.0-1.0 (PaddleOCR native, no scaling)
- [ ] `PaddleOCREngine.name()` returns `"paddleocr"`
- [ ] `PaddleOCREngine` satisfies `OCREngineInterface` Protocol
- [ ] `create_ocr_engine()` returns `PaddleOCREngine` when `config.ocr_engine == OCREngine.PADDLEOCR` and paddleocr is importable
- [ ] `create_ocr_engine()` falls back to Tesseract with `W_OCR_ENGINE_FALLBACK` warning when PaddleOCR is requested but not installed (existing behavior preserved)
- [ ] `PaddleOCREngine` exported from `utils/__init__.py` and added to `__all__`
- [ ] All existing tests pass (zero regressions)
- [ ] New unit tests (`@pytest.mark.unit`) pass without PaddleOCR installed
- [ ] Integration tests gated behind `@pytest.mark.ocr_paddle`

---

AGENT_RETURN: .agents/outputs/plan-44-021426.md
