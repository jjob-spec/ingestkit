# MAP: Issue #68 — Implement dual-write output (DB rows and RAG chunks)

## 1. Codebase Investigation Summary

### 1.1 Spec Requirements (§8.0–§8.5, §13.2)

The spec defines five major subsystems for dual-write output:

**§8.0 Dual-Write Consistency Model:**
- `DualWriteMode` enum: `BEST_EFFORT` (retain partial writes) vs `STRICT_ATOMIC` (rollback on any failure)
- Behavior matrix: 4 combinations of DB/Vector success/failure with distinct behavior per mode
- Retry semantics: each backend retried up to `backend_max_retries` with exponential backoff (`backend_backoff_base`)
- Rollback retried up to `backend_max_retries`; if rollback fails, emit `W_FORM_ROLLBACK_FAILED`

**§8.1 Structured DB Rows:**
- Table naming: `{form_db_table_prefix}{template_name_slug}` (e.g., `form_leave_request`)
- One canonical table per template family (all versions share one table)
- Schema generation: `FieldType` -> SQL type mapping (TEXT, REAL, INTEGER, etc.)
- 10 metadata columns always present: `_form_id`, `_template_id`, `_template_version`, `_source_uri`, `_ingest_key`, `_ingest_run_id`, `_tenant_id`, `_extracted_at`, `_overall_confidence`, `_extraction_method`
- Schema evolution: `ALTER TABLE ADD COLUMN` for new fields; columns never dropped
- Upsert semantics: `INSERT OR REPLACE` on `_form_id`

**§8.2 RAG Chunk Serialization:**
- Text format: header (template name, version, date) + field name/value pairs
- Splitting: single chunk if <= `chunk_max_fields` (default 20); split by page if exceeded
- None values serialized as `[not extracted]`; checkboxes as Yes/No

**§8.3–8.4 Chunk Metadata & Payload:**
- `FormChunkMetadata` extends `BaseChunkMetadata` with 11 form-specific fields
- `FormChunkPayload`: id, text, vector, metadata

**§8.5 Rollback Protocol:**
- Delete vector points first (less critical, faster), then DB rows
- Both steps retried; idempotent delete semantics on both backends
- `RollbackResult` model with `fully_rolled_back` flag

**§13.2 PII / Redaction:**
- `redact_patterns`: list of regex; matching substrings replaced with `[REDACTED]`
- `redact_target`: `BOTH` | `CHUNKS_ONLY` | `DB_ONLY`
- Applied after extraction, before persistence
- Raw values exist only in-memory during processing

### 1.2 Current File State

| File | State | Contents |
|------|-------|----------|
| `output/db_writer.py` | **Stub** — docstring only (6 lines) | Empty module |
| `output/chunk_writer.py` | **Stub** — docstring only (6 lines) | Empty module |
| `output/__init__.py` | Exists | Subpackage docstring only |
| `models.py` | **Complete** | `DualWriteMode`, `FormChunkMetadata`, `FormChunkPayload`, `FormWrittenArtifacts`, `RollbackResult`, `FormProcessingResult`, all field types and extraction models |
| `protocols.py` | **Complete** | Re-exports `StructuredDBBackend`, `VectorStoreBackend`, `EmbeddingBackend` from core |
| `config.py` | **Complete** | `FormProcessorConfig` with `form_db_table_prefix`, `chunk_max_fields`, `dual_write_mode`, `backend_max_retries`, `backend_backoff_base`, `redact_patterns`, `redact_target` |
| `errors.py` | **Complete** | `FormErrorCode` with `E_FORM_DB_WRITE_FAILED`, `E_FORM_CHUNK_WRITE_FAILED`, `E_FORM_DB_SCHEMA_EVOLUTION_FAILED`, `E_FORM_DUAL_WRITE_PARTIAL`, `W_FORM_ROLLBACK_FAILED`, `W_FORM_PARTIAL_WRITE`, `W_FORM_SCHEMA_EVOLVED` |
| `tests/test_output.py` | **Stub** — docstring only | Empty test file |
| `tests/conftest.py` | **Partial** | Has mock backends for template store, OCR, PDF widgets, fingerprinter; does NOT have mock `StructuredDBBackend`, `VectorStoreBackend`, or `EmbeddingBackend` |

### 1.3 Existing Patterns (ingestkit-excel reference)

`StructuredDBProcessor` in `packages/ingestkit-excel/src/ingestkit_excel/processors/structured_db.py` provides the reference implementation for:
- Backend injection via constructor (`__init__` takes `structured_db`, `vector_store`, `embedder`, `config`)
- Schema description generation and embedding
- Chunk creation with `ChunkPayload` and `ChunkMetadata`
- `WrittenArtifacts` tracking (`vector_point_ids`, `db_table_names`)
- Per-sheet error handling with error classification
- Batch embedding with `embedding_batch_size`

### 1.4 Protocol Gaps

The current `StructuredDBBackend` protocol (from `ingestkit_core`) has these methods:
- `create_table_from_dataframe(table_name, df)` — writes a DataFrame
- `drop_table(table_name)`
- `table_exists(table_name) -> bool`
- `get_table_schema(table_name) -> dict`
- `get_connection_uri() -> str`

**Missing for form DB writer:**
- No `execute_sql()` or `add_column()` method for schema evolution (`ALTER TABLE ADD COLUMN`)
- No `upsert_row()` method for individual row upsert with `INSERT OR REPLACE` semantics
- No `delete_by_form_id()` for rollback

The `VectorStoreBackend` protocol already has `delete_by_ids()` which is needed for rollback.

**Decision needed:** Either extend `StructuredDBBackend` in `ingestkit_core` with new methods, or add a form-specific `FormDBBackend` protocol in `ingestkit_forms/protocols.py` that extends the base.

### 1.5 Model Completeness

All data models are already defined in `models.py`:
- `FormChunkMetadata` inherits from `BaseChunkMetadata` (has all 11 form-specific fields)
- `FormChunkPayload` (id, text, vector, metadata)
- `FormWrittenArtifacts` extends `WrittenArtifacts` with `db_row_ids: list[str]`
- `RollbackResult` (vector_points_deleted, db_rows_deleted, errors, fully_rolled_back)
- `FieldType` enum (TEXT, NUMBER, DATE, CHECKBOX, RADIO, SIGNATURE, DROPDOWN)

All error codes are defined in `errors.py`.

All config parameters are defined in `config.py`.

## 2. Implementation Topology

### 2.1 Files to Create/Modify

| File | Action | Estimated Lines |
|------|--------|-----------------|
| `output/db_writer.py` | **Implement** from stub | ~250 |
| `output/chunk_writer.py` | **Implement** from stub | ~200 |
| `output/dual_writer.py` | **Create** — orchestrates DB + chunk writes with consistency model | ~250 |
| `output/__init__.py` | **Update** — export public API | ~15 |
| `protocols.py` | **Extend** — add `execute_sql`, `upsert_row`, `delete_rows` to DB protocol or create form-specific extension | ~30 |
| `tests/test_output.py` | **Implement** — comprehensive tests | ~500 |
| `tests/conftest.py` | **Extend** — add mock DB, vector, embedding backends | ~100 |

**Total estimated: ~1,345 lines**

### 2.2 Component Breakdown

#### Component A: DB Writer (`output/db_writer.py`)

Functions/classes to implement:

1. **`slugify_template_name(name: str) -> str`** — convert template name to DB-safe slug (lowercase, replace spaces/special chars with underscore, collapse, strip)

2. **`get_table_name(config: FormProcessorConfig, template: FormTemplate) -> str`** — `{form_db_table_prefix}{slug}`

3. **`FIELD_TYPE_TO_SQL: dict[FieldType, str]`** — mapping constant:
   - TEXT -> "TEXT", NUMBER -> "REAL", DATE -> "TEXT", CHECKBOX -> "INTEGER", RADIO -> "TEXT", SIGNATURE -> "INTEGER", DROPDOWN -> "TEXT"

4. **`METADATA_COLUMNS: dict[str, str]`** — the 10 metadata columns with SQL types

5. **`generate_table_schema(template: FormTemplate) -> dict[str, str]`** — combine metadata columns + field columns from template

6. **`evolve_table_schema(db, table_name, old_template, new_template) -> list[str]`** — compute set difference of field names, issue ALTER TABLE ADD COLUMN for each new field, return list of added column names

7. **`build_row_dict(extraction: FormExtractionResult, config: FormProcessorConfig, ingest_key: str, ingest_run_id: str) -> dict[str, Any]`** — assemble a row dict from extraction result (metadata columns + field values)

8. **`class FormDBWriter`**:
   - `__init__(self, db: StructuredDBBackend, config: FormProcessorConfig)`
   - `ensure_table(self, template: FormTemplate) -> str` — create table if not exists, return table name
   - `evolve_schema(self, table_name: str, old_template: FormTemplate, new_template: FormTemplate) -> list[str]`
   - `write_row(self, table_name: str, extraction: FormExtractionResult, ingest_key: str, ingest_run_id: str) -> str` — returns `_form_id`
   - Retry logic with `backend_max_retries` and `backend_backoff_base`

#### Component B: Chunk Writer (`output/chunk_writer.py`)

1. **`serialize_form_to_text(extraction: FormExtractionResult, fields: list[ExtractedField]) -> str`** — produce the text chunk format per §8.2

2. **`split_fields_into_chunks(extraction: FormExtractionResult, chunk_max_fields: int) -> list[list[ExtractedField]]`** — split by page if > chunk_max_fields, else single chunk

3. **`build_chunk_metadata(extraction, chunk_fields, chunk_index, chunk_hash, ingest_key, ingest_run_id, config) -> FormChunkMetadata`**

4. **`class FormChunkWriter`**:
   - `__init__(self, vector_store: VectorStoreBackend, embedder: EmbeddingBackend, config: FormProcessorConfig)`
   - `write_chunks(self, extraction: FormExtractionResult, ingest_key: str, ingest_run_id: str) -> tuple[list[str], EmbedStageResult]` — serialize, embed, upsert; returns (vector_point_ids, embed_result)
   - Retry logic with `backend_max_retries` and `backend_backoff_base`

#### Component C: Dual Writer (`output/dual_writer.py`)

1. **`apply_redaction(value: str, patterns: list[re.Pattern], target: str, destination: str) -> str`** — apply redact_patterns based on redact_target

2. **`redact_extraction(extraction: FormExtractionResult, config: FormProcessorConfig, destination: str) -> FormExtractionResult`** — deep copy extraction and redact field values per target

3. **`class FormDualWriter`**:
   - `__init__(self, db_writer: FormDBWriter, chunk_writer: FormChunkWriter, config: FormProcessorConfig)`
   - `write(self, extraction: FormExtractionResult, template: FormTemplate, ingest_key: str, ingest_run_id: str) -> tuple[FormWrittenArtifacts, list[str], list[str], list[FormIngestError], EmbedStageResult | None]`
     - Apply redaction per destination (db vs chunks)
     - Write DB row
     - Write chunks
     - Handle failure per `dual_write_mode`
     - Return (written, errors, warnings, error_details, embed_result)

4. **`rollback_written_artifacts(written: FormWrittenArtifacts, vector_backend: VectorStoreBackend | None, db_backend: StructuredDBBackend | None, config: FormProcessorConfig) -> RollbackResult`** — module-level function per spec §8.5

### 2.3 Protocol Extension Strategy

The `StructuredDBBackend` needs these additional methods for forms:
- `execute_sql(sql: str, params: tuple | None = None) -> None` — for `CREATE TABLE`, `ALTER TABLE`, `INSERT OR REPLACE`
- `get_table_columns(table_name: str) -> list[str]` — for schema evolution diff (or reuse `get_table_schema`)
- `delete_rows(table_name: str, column: str, values: list[str]) -> int` — for rollback (`DELETE WHERE _form_id IN (...)`)

**Recommended approach:** Add a `FormDBBackend` protocol in `ingestkit_forms/protocols.py` that includes these methods. This avoids modifying `ingestkit_core` and keeps form-specific concerns isolated. Concrete backends (SQLite, PostgreSQL) implement both `StructuredDBBackend` and `FormDBBackend`.

Alternatively, the db_writer can work with the existing `StructuredDBBackend` by:
- Using `create_table_from_dataframe` with a single-row DataFrame for upsert
- Using `get_table_schema` for schema evolution diff
- But this is awkward for `ALTER TABLE ADD COLUMN` and `DELETE WHERE`

**Recommended: extend the core `StructuredDBBackend` with `execute_sql` and `delete_rows`**, since these are general-purpose DB operations that other packages may need. This is a minor, backward-compatible addition.

## 3. Dependency Graph

```
protocols.py (extend StructuredDBBackend or add FormDBBackend)
    |
    v
output/db_writer.py  +  output/chunk_writer.py
    \                   /
     \                 /
      v               v
    output/dual_writer.py
          |
          v
    output/__init__.py (exports)
          |
          v
    tests/conftest.py (mock backends)
          |
          v
    tests/test_output.py
```

**Implementation order:**
1. Protocol extension (if needed)
2. `db_writer.py` and `chunk_writer.py` (independent, can be parallel)
3. `dual_writer.py` (depends on both writers)
4. `__init__.py` updates
5. Test infrastructure (mock backends in conftest)
6. `test_output.py`

## 4. Risk Analysis

| Risk | Severity | Mitigation |
|------|----------|------------|
| `StructuredDBBackend` protocol lacks `execute_sql` / `delete_rows` | **HIGH** — blocks DB writer and rollback | Extend core protocol or add form-specific protocol. Decision must be made before implementation. |
| Redaction must happen before persistence but after extraction — ordering bug potential | **MEDIUM** | Create redacted copies of extraction result; never mutate the original. Clear test coverage. |
| Schema evolution race condition (two concurrent writers evolving same table) | **LOW** (single-process on-prem) | Document that concurrent schema evolution is not supported. |
| Rollback of `create_table_from_dataframe` for upsert is non-trivial | **MEDIUM** | Use `_form_id`-based delete rather than table drop for rollback. |

## 5. Test Plan

### Unit Tests (`test_output.py`)

**DB Writer tests (~15 tests):**
- `test_slugify_template_name` — various names (spaces, special chars, unicode)
- `test_get_table_name` — prefix + slug concatenation
- `test_field_type_to_sql_mapping` — all 7 FieldType values
- `test_generate_table_schema` — metadata columns + field columns
- `test_generate_table_schema_all_field_types` — every FieldType maps correctly
- `test_build_row_dict` — correct keys and values from extraction
- `test_build_row_dict_none_values` — None fields handled
- `test_build_row_dict_checkbox_signature_coercion` — bool->int for checkbox/signature
- `test_evolve_table_schema_new_fields` — detects and adds new columns
- `test_evolve_table_schema_no_changes` — returns empty list
- `test_evolve_table_schema_removed_fields_preserved` — never drops columns
- `test_write_row_success` — happy path
- `test_write_row_retry_on_failure` — retries with backoff
- `test_write_row_exhausts_retries` — raises after max retries

**Chunk Writer tests (~12 tests):**
- `test_serialize_single_chunk` — format matches spec §8.2
- `test_serialize_none_values` — `[not extracted]`
- `test_serialize_checkbox_yes_no` — boolean -> Yes/No
- `test_split_fields_single_chunk` — <= chunk_max_fields
- `test_split_fields_multi_chunk` — > chunk_max_fields, split by page
- `test_build_chunk_metadata` — all form-specific fields present
- `test_write_chunks_success` — happy path with embedding
- `test_write_chunks_retry` — retries on failure
- `test_chunk_id_deterministic` — same input -> same chunk ID

**Dual Writer tests (~15 tests):**
- `test_dual_write_both_success` — happy path
- `test_best_effort_db_fail_vector_success` — retains vector points
- `test_best_effort_vector_fail_db_success` — retains DB row
- `test_best_effort_both_fail` — zero artifacts
- `test_strict_atomic_db_fail_vector_success` — rollback vector
- `test_strict_atomic_vector_fail_db_success` — rollback DB
- `test_strict_atomic_both_fail` — zero artifacts, no rollback needed
- `test_strict_atomic_rollback_failure` — W_FORM_ROLLBACK_FAILED warning
- `test_redaction_both` — values redacted in DB and chunks
- `test_redaction_chunks_only` — DB raw, chunks redacted
- `test_redaction_db_only` — DB redacted, chunks raw
- `test_redaction_no_patterns` — no redaction applied
- `test_rollback_vector_first_then_db` — verify order
- `test_rollback_idempotent` — safe to retry

**Conftest additions:**
- `MockStructuredDBBackend` — in-memory dict-based, supports table creation, schema queries, row operations
- `MockVectorStoreBackend` — in-memory, supports upsert/delete/ensure_collection
- `MockEmbeddingBackend` — returns deterministic vectors

## 6. Key Decisions for Implementer

1. **Protocol extension:** Add `execute_sql(sql, params)` and `delete_rows(table_name, column, values)` to `StructuredDBBackend` in `ingestkit_core/protocols.py`. This is the cleanest approach since rollback and schema evolution are general concerns.

2. **Redaction strategy:** Create `redact_extraction()` that returns a deep copy with redacted values. Call it twice if `redact_target` is BOTH, once with the appropriate destination otherwise. Never mutate the original `FormExtractionResult`.

3. **Retry implementation:** Use a simple retry loop with `time.sleep(backoff_base * 2**attempt)`. Do not add tenacity or other retry libraries — keep dependencies minimal.

4. **Table creation:** Use `execute_sql` with `CREATE TABLE IF NOT EXISTS` for initial creation, then `ALTER TABLE ADD COLUMN` for evolution. Do NOT use `create_table_from_dataframe` for form rows since forms write individual rows, not DataFrames.

5. **Chunk ID generation:** Use `uuid.uuid5(NAMESPACE_URL, f"{ingest_key}:{chunk_hash}")` — matches the pattern from ingestkit-excel's `StructuredDBProcessor`.

AGENT_RETURN: .agents/outputs/map-68-021526.md
