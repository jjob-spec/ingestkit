# MAP-PLAN â€” Issue #11: Concrete Backends

## Executive Summary

This issue implements the five concrete backend modules specified in SPEC.md section 12: `QdrantVectorStore` (vector store via `qdrant-client`), `SQLiteStructuredDB` (structured DB via `sqlite3` + pandas), `OllamaLLM` and `OllamaEmbedding` (LLM/embedding via Ollama HTTP API with `httpx`), plus two stub backends (`MilvusVectorStore`, `PostgresStructuredDB`). Each concrete backend must satisfy its corresponding `Protocol` from `ingestkit_core.protocols` using structural subtyping -- no inheritance from the protocols themselves. All backends live under `src/ingestkit_excel/backends/` and are covered by unit tests using mocks (no external services required).

## Investigation Findings

### Protocol Signatures (from `ingestkit_core/protocols.py`)

**VectorStoreBackend:**
```python
def upsert_chunks(self, collection: str, chunks: list[ChunkPayload]) -> int
def ensure_collection(self, collection: str, vector_size: int) -> None
def create_payload_index(self, collection: str, field: str, field_type: str) -> None
def delete_by_ids(self, collection: str, ids: list[str]) -> int
```

**StructuredDBBackend:**
```python
def create_table_from_dataframe(self, table_name: str, df: pd.DataFrame) -> None
def drop_table(self, table_name: str) -> None
def table_exists(self, table_name: str) -> bool
def get_table_schema(self, table_name: str) -> dict
def get_connection_uri(self) -> str
```

**LLMBackend:**
```python
def classify(self, prompt: str, model: str, temperature: float = 0.1, timeout: float | None = None) -> dict
def generate(self, prompt: str, model: str, temperature: float = 0.7, timeout: float | None = None) -> str
```

**EmbeddingBackend:**
```python
def embed(self, texts: list[str], timeout: float | None = None) -> list[list[float]]
def dimension(self) -> int
```

### Config Parameters (from `config.py`)

| Parameter | Default | Used By |
|-----------|---------|---------|
| `backend_timeout_seconds` | 30.0 | All backends |
| `backend_max_retries` | 2 | Qdrant, Ollama |
| `backend_backoff_base` | 1.0 | Qdrant, Ollama |
| `embedding_model` | `"nomic-embed-text"` | OllamaEmbedding |
| `embedding_dimension` | 768 | OllamaEmbedding |
| `embedding_batch_size` | 64 | OllamaEmbedding |
| `default_collection` | `"helpdesk"` | QdrantVectorStore |
| `classification_model` | `"qwen2.5:7b"` | OllamaLLM |

### Error Codes (from `errors.py`)

| Code | Used By |
|------|---------|
| `E_LLM_TIMEOUT` | OllamaLLM connection failure |
| `E_LLM_MALFORMED_JSON` | OllamaLLM classify() parse failure |
| `E_LLM_SCHEMA_INVALID` | OllamaLLM classify() schema validation failure |
| `E_BACKEND_VECTOR_TIMEOUT` | QdrantVectorStore timeout |
| `E_BACKEND_VECTOR_CONNECT` | QdrantVectorStore connection failure |
| `E_BACKEND_DB_TIMEOUT` | SQLiteStructuredDB timeout |
| `E_BACKEND_DB_CONNECT` | SQLiteStructuredDB connection failure |
| `E_BACKEND_EMBED_TIMEOUT` | OllamaEmbedding timeout |
| `E_BACKEND_EMBED_CONNECT` | OllamaEmbedding connection failure |

### ChunkPayload Structure (from `ingestkit_core/models.py`)

```python
class ChunkPayload(BaseModel):
    id: str
    text: str
    vector: list[float]
    metadata: BaseChunkMetadata
```

`BaseChunkMetadata` fields: `source_uri`, `source_format`, `ingestion_method`, `parser_version`, `chunk_index`, `chunk_hash`, `ingest_key`, `ingest_run_id`, `tenant_id`, `table_name`, `row_count`, `columns`, `section_title`.

### Dependencies (from `pyproject.toml`)

- `qdrant-client>=1.7` -- optional dependency under `[qdrant]` extra
- `httpx>=0.27` -- optional dependency under `[ollama]` extra
- `sqlite3` -- stdlib, no extra needed
- `pandas>=2.0` -- core dependency, already available

### Existing Test Patterns

Tests use class-based organization (`TestSomething`), mock backends as simple classes (not `MagicMock`), factory functions (`_make_*`) for test data, `@pytest.mark.unit` marker, `@patch` decorator for external calls, and `conftest.py` for shared fixtures.

## Implementation Plan

### File 1: `src/ingestkit_excel/backends/__init__.py`

```python
"""Concrete backend implementations for the ingestkit-excel pipeline.

This package provides reference implementations of the four backend protocols:
- QdrantVectorStore (VectorStoreBackend)
- SQLiteStructuredDB (StructuredDBBackend)
- OllamaLLM (LLMBackend)
- OllamaEmbedding (EmbeddingBackend)

Stub implementations (MilvusVectorStore, PostgresStructuredDB) raise
NotImplementedError for all methods.
"""

from ingestkit_excel.backends.milvus import MilvusVectorStore
from ingestkit_excel.backends.ollama import OllamaEmbedding, OllamaLLM
from ingestkit_excel.backends.postgres import PostgresStructuredDB
from ingestkit_excel.backends.qdrant import QdrantVectorStore
from ingestkit_excel.backends.sqlite import SQLiteStructuredDB

__all__ = [
    "QdrantVectorStore",
    "SQLiteStructuredDB",
    "OllamaLLM",
    "OllamaEmbedding",
    "MilvusVectorStore",
    "PostgresStructuredDB",
]
```

### File 2: `src/ingestkit_excel/backends/qdrant.py` (QdrantVectorStore)

**Class: `QdrantVectorStore`**

Constructor parameters:
- `url: str = "localhost"` -- Qdrant host
- `port: int = 6333` -- Qdrant port
- `timeout: float = 30.0` -- Default timeout (from config)
- `max_retries: int = 2` -- Retry limit (from config)
- `backoff_base: float = 1.0` -- Base for exponential backoff

Internal state:
- `self._client: QdrantClient` -- lazily or eagerly initialized

Methods:

1. **`ensure_collection(collection: str, vector_size: int) -> None`**
   - Import `qdrant_client.models` for `Distance`, `VectorParams`
   - Check if collection exists via `self._client.collection_exists(collection)`
   - If not, create with `self._client.create_collection(collection, vectors_config=VectorParams(size=vector_size, distance=Distance.COSINE))`
   - Wrap in `_with_retry()` helper

2. **`upsert_chunks(collection: str, chunks: list[ChunkPayload]) -> int`**
   - Convert each `ChunkPayload` to a `PointStruct(id=chunk.id, vector=chunk.vector, payload=chunk.metadata.model_dump())`
   - Also add `"text": chunk.text` to the payload
   - Call `self._client.upsert(collection_name=collection, points=points)`
   - Return `len(chunks)`
   - Wrap in `_with_retry()`

3. **`create_payload_index(collection: str, field: str, field_type: str) -> None`**
   - Map `field_type` string to `qdrant_client.models.PayloadSchemaType` (keyword, integer, etc.)
   - Call `self._client.create_payload_index(collection_name=collection, field_name=field, field_schema=schema_type)`
   - Wrap in `_with_retry()`

4. **`delete_by_ids(collection: str, ids: list[str]) -> int`**
   - Call `self._client.delete(collection_name=collection, points_selector=PointIdsList(points=ids))`
   - Return `len(ids)`
   - Wrap in `_with_retry()`

5. **`_with_retry(fn, *args, **kwargs)`** (private helper)
   - For i in range(max_retries + 1):
     - Try fn(*args, **kwargs)
     - On timeout/connection error: sleep `backoff_base * 2**i`, retry
     - On last attempt: raise `IngestError` with `E_BACKEND_VECTOR_TIMEOUT` or `E_BACKEND_VECTOR_CONNECT`

Import guard: wrap `import qdrant_client` in try/except, raise `ImportError` with install hint if missing.

Logging: Use `logger = logging.getLogger("ingestkit_excel")`.

### File 3: `src/ingestkit_excel/backends/sqlite.py` (SQLiteStructuredDB)

**Class: `SQLiteStructuredDB`**

Constructor parameters:
- `db_path: str = ":memory:"` -- Path to SQLite file (or `:memory:`)

Internal state:
- `self._db_path: str`
- `self._conn: sqlite3.Connection` -- eagerly connected in __init__

Methods:

1. **`create_table_from_dataframe(table_name: str, df: pd.DataFrame) -> None`**
   - Call `df.to_sql(table_name, self._conn, if_exists="replace", index=False)`

2. **`drop_table(table_name: str) -> None`**
   - Execute `DROP TABLE IF EXISTS {table_name}` (with proper sanitization)

3. **`table_exists(table_name: str) -> bool`**
   - Execute `SELECT name FROM sqlite_master WHERE type='table' AND name=?`
   - Return `bool(cursor.fetchone())`

4. **`get_table_schema(table_name: str) -> dict`**
   - Execute `PRAGMA table_info({table_name})`
   - Return `{row[1]: row[2] for row in cursor.fetchall()}` (name: type)

5. **`get_connection_uri(self) -> str`**
   - Return `f"sqlite:///{self._db_path}"` (or `"sqlite://"` for `:memory:`)

No retry logic needed for SQLite (local, no network). Add `close()` method for resource cleanup.

### File 4: `src/ingestkit_excel/backends/ollama.py` (OllamaLLM + OllamaEmbedding)

**Class: `OllamaLLM`**

Constructor parameters:
- `base_url: str = "http://localhost:11434"` -- Ollama API base URL
- `timeout: float = 30.0` -- Default timeout
- `max_retries: int = 2` -- Retry limit for connection failures
- `backoff_base: float = 1.0` -- Base for exponential backoff

Methods:

1. **`classify(prompt: str, model: str, temperature: float = 0.1, timeout: float | None = None) -> dict`**
   - POST to `{base_url}/api/generate` with `{"model": model, "prompt": prompt, "stream": false, "options": {"temperature": temperature}}`
   - Timeout: `timeout or self._timeout`
   - Parse JSON from `response["response"]` field
   - On `json.JSONDecodeError`: retry once with a correction hint appended to prompt ("Please respond with valid JSON only.")
   - On second failure: raise `IngestError` with `E_LLM_MALFORMED_JSON`
   - On `httpx.TimeoutException`: raise `IngestError` with `E_LLM_TIMEOUT`
   - On `httpx.ConnectError`: raise `IngestError` with `E_LLM_TIMEOUT`
   - Return the parsed dict

2. **`generate(prompt: str, model: str, temperature: float = 0.7, timeout: float | None = None) -> str`**
   - POST to `{base_url}/api/generate` with `{"model": model, "prompt": prompt, "stream": false, "options": {"temperature": temperature}}`
   - Return `response["response"]` as raw text
   - On timeout/connect: raise `IngestError` with `E_LLM_TIMEOUT`

3. **`_post(endpoint: str, payload: dict, timeout: float) -> dict`** (private)
   - `httpx.post(self._base_url + endpoint, json=payload, timeout=timeout)`
   - Return `response.json()`

Import guard: wrap `import httpx` in try/except with install hint.

**Class: `OllamaEmbedding`**

Constructor parameters:
- `model: str = "nomic-embed-text"` -- Embedding model name
- `base_url: str = "http://localhost:11434"` -- Ollama API base URL
- `timeout: float = 30.0` -- Default timeout
- `vector_dimension: int = 768` -- Expected vector dimension

Methods:

1. **`embed(texts: list[str], timeout: float | None = None) -> list[list[float]]`**
   - POST to `{base_url}/api/embed` with `{"model": self._model, "input": texts}`
   - Timeout: `timeout or self._timeout`
   - Return `response["embeddings"]`
   - On timeout/connect: raise `IngestError` with `E_BACKEND_EMBED_TIMEOUT` or `E_BACKEND_EMBED_CONNECT`

2. **`dimension(self) -> int`**
   - Return `self._vector_dimension`

Import guard: same httpx check as OllamaLLM (shared module).

### File 5: `src/ingestkit_excel/backends/milvus.py` (MilvusVectorStore stub)

```python
"""Stub implementation of VectorStoreBackend for Milvus.

To implement, see backends/qdrant.py for the reference VectorStoreBackend.
"""

from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ingestkit_core.models import ChunkPayload


class MilvusVectorStore:
    """Milvus vector store backend (not yet implemented)."""

    def upsert_chunks(self, collection: str, chunks: list[ChunkPayload]) -> int:
        raise NotImplementedError("MilvusVectorStore not yet implemented. See backends/qdrant.py for reference.")

    def ensure_collection(self, collection: str, vector_size: int) -> None:
        raise NotImplementedError("MilvusVectorStore not yet implemented. See backends/qdrant.py for reference.")

    def create_payload_index(self, collection: str, field: str, field_type: str) -> None:
        raise NotImplementedError("MilvusVectorStore not yet implemented. See backends/qdrant.py for reference.")

    def delete_by_ids(self, collection: str, ids: list[str]) -> int:
        raise NotImplementedError("MilvusVectorStore not yet implemented. See backends/qdrant.py for reference.")
```

### File 6: `src/ingestkit_excel/backends/postgres.py` (PostgresStructuredDB stub)

```python
"""Stub implementation of StructuredDBBackend for PostgreSQL.

To implement, see backends/sqlite.py for the reference StructuredDBBackend.
"""

from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import pandas as pd


class PostgresStructuredDB:
    """PostgreSQL structured database backend (not yet implemented)."""

    def create_table_from_dataframe(self, table_name: str, df: pd.DataFrame) -> None:
        raise NotImplementedError("PostgresStructuredDB not yet implemented. See backends/sqlite.py for reference.")

    def drop_table(self, table_name: str) -> None:
        raise NotImplementedError("PostgresStructuredDB not yet implemented. See backends/sqlite.py for reference.")

    def table_exists(self, table_name: str) -> bool:
        raise NotImplementedError("PostgresStructuredDB not yet implemented. See backends/sqlite.py for reference.")

    def get_table_schema(self, table_name: str) -> dict:
        raise NotImplementedError("PostgresStructuredDB not yet implemented. See backends/sqlite.py for reference.")

    def get_connection_uri(self) -> str:
        raise NotImplementedError("PostgresStructuredDB not yet implemented. See backends/sqlite.py for reference.")
```

### File 7: `tests/test_backends.py`

**Test Organization:**

```
class TestSQLiteStructuredDB:
    # Tests using real sqlite3 (in-memory) -- no mocking needed
    test_create_table_from_dataframe_basic
    test_create_table_from_dataframe_replace_existing
    test_drop_table
    test_drop_table_nonexistent_no_error
    test_table_exists_true
    test_table_exists_false
    test_get_table_schema_returns_column_types
    test_get_connection_uri_file
    test_get_connection_uri_memory
    test_protocol_conformance  # isinstance(db, StructuredDBBackend)

class TestQdrantVectorStore:
    # Tests using mock qdrant_client.QdrantClient
    test_ensure_collection_creates_when_missing
    test_ensure_collection_skips_when_exists
    test_upsert_chunks_converts_to_points
    test_upsert_chunks_returns_count
    test_upsert_chunks_includes_text_in_payload
    test_create_payload_index_keyword
    test_create_payload_index_integer
    test_delete_by_ids_returns_count
    test_retry_on_timeout
    test_retry_exhausted_raises_error
    test_protocol_conformance  # isinstance(store, VectorStoreBackend)

class TestOllamaLLM:
    # Tests using mock httpx responses
    test_classify_valid_json_response
    test_classify_retries_on_malformed_json
    test_classify_raises_after_second_malformed_json
    test_classify_timeout_raises_error
    test_classify_connect_error_raises
    test_generate_returns_raw_text
    test_generate_timeout_raises_error
    test_protocol_conformance  # isinstance(llm, LLMBackend)

class TestOllamaEmbedding:
    # Tests using mock httpx responses
    test_embed_returns_vectors
    test_embed_batch_of_texts
    test_embed_timeout_raises_error
    test_embed_connect_error_raises
    test_dimension_returns_configured_value
    test_protocol_conformance  # isinstance(emb, EmbeddingBackend)

class TestMilvusVectorStoreStub:
    test_all_methods_raise_not_implemented
    test_protocol_conformance  # isinstance(store, VectorStoreBackend)

class TestPostgresStructuredDBStub:
    test_all_methods_raise_not_implemented
    test_protocol_conformance  # isinstance(db, StructuredDBBackend)
```

**Key testing patterns:**
- SQLite tests use real in-memory SQLite (no mocking -- it is a stdlib module)
- Qdrant tests mock `qdrant_client.QdrantClient` using `unittest.mock.patch`
- Ollama tests mock `httpx.Client.post` or use `unittest.mock.patch` on the `_post` helper
- All protocol conformance tests use `isinstance` checks against the `@runtime_checkable` protocols
- All test classes marked with `@pytest.mark.unit`
- Factory helpers for `ChunkPayload` test data

### File 8: `__init__.py` Updates

Add backend imports to `src/ingestkit_excel/__init__.py`:

```python
# Add after existing imports:
from ingestkit_excel.backends import (
    MilvusVectorStore,
    OllamaEmbedding,
    OllamaLLM,
    PostgresStructuredDB,
    QdrantVectorStore,
    SQLiteStructuredDB,
)

# Add to __all__:
    # Backends
    "QdrantVectorStore",
    "SQLiteStructuredDB",
    "OllamaLLM",
    "OllamaEmbedding",
    "MilvusVectorStore",
    "PostgresStructuredDB",
```

## Acceptance Criteria

- [ ] `backends/__init__.py` exports all 6 backend classes
- [ ] `QdrantVectorStore` implements all 4 `VectorStoreBackend` methods with retry/backoff
- [ ] `SQLiteStructuredDB` implements all 5 `StructuredDBBackend` methods using sqlite3 + pandas
- [ ] `OllamaLLM` implements `classify` (with JSON retry) and `generate` using httpx
- [ ] `OllamaEmbedding` implements `embed` and `dimension` using httpx
- [ ] `MilvusVectorStore` raises `NotImplementedError` for all methods
- [ ] `PostgresStructuredDB` raises `NotImplementedError` for all methods
- [ ] All backends pass `isinstance` checks against their respective `@runtime_checkable` protocols
- [ ] All backends use proper error codes from `errors.py` on failure
- [ ] Qdrant and Ollama backends have import guards with helpful error messages
- [ ] Unit tests cover all public methods with no external service dependencies
- [ ] Package-level `__init__.py` exports all backend classes
- [ ] All existing tests still pass (no regressions)
- [ ] Logger name is `ingestkit_excel` (PII-safe logging)

## Verification Gates

```bash
# 1. Run only the new backend tests
pytest packages/ingestkit-excel/tests/test_backends.py -v -m unit

# 2. Run full test suite to check for regressions
pytest packages/ingestkit-excel/tests -v

# 3. Verify protocol conformance (in test suite)
# isinstance checks are embedded in test_backends.py

# 4. Verify imports work
python -c "from ingestkit_excel.backends import QdrantVectorStore, SQLiteStructuredDB, OllamaLLM, OllamaEmbedding, MilvusVectorStore, PostgresStructuredDB; print('All imports OK')"

# 5. Verify package-level exports
python -c "from ingestkit_excel import QdrantVectorStore, SQLiteStructuredDB, OllamaLLM, OllamaEmbedding; print('Package exports OK')"
```

## Implementation Order

1. `backends/__init__.py` (empty initially, fill as files are created)
2. `backends/sqlite.py` (simplest -- no optional deps, real sqlite3 for testing)
3. `backends/qdrant.py` (optional dep, mocked in tests)
4. `backends/ollama.py` (optional dep, mocked in tests)
5. `backends/milvus.py` (stub)
6. `backends/postgres.py` (stub)
7. `tests/test_backends.py` (all test classes)
8. Update `__init__.py` for package-level exports
