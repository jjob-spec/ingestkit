---
issue: 32
agent: MAP-PLAN
date: 2026-02-14
complexity: SIMPLE
stack: backend
spec_sections: "§15.1, §15.2, §15.3, §15.4"
files_to_create:
  - packages/ingestkit-pdf/src/ingestkit_pdf/utils/chunker.py
  - packages/ingestkit-pdf/tests/test_chunker.py
files_to_modify: []
---

# MAP-PLAN: Issue #32 — Configurable Text Chunking (`utils/chunker.py`)

## Executive Summary

Implement `PDFChunker` in `packages/ingestkit-pdf/src/ingestkit_pdf/utils/chunker.py` -- a configurable text chunking utility that uses recursive character splitting with hierarchical boundaries, respects document structure (headings and tables), and attaches rich metadata to each chunk. The chunker is a pure-function utility with no backend dependencies, making it straightforward to implement and test.

---

## Investigation Findings

### 1. Spec Requirements (SPEC.md §15.1--§15.4)

**§15.1 Default Strategy** -- Recursive character splitting with heading-aware boundaries:
- Split hierarchy: `\n## ` -> `\n### ` -> `\n\n` -> `. ` -> ` `
- Target chunk size: `config.chunk_size_tokens` (default 512)
- Overlap: `config.chunk_overlap_tokens` (default 50 tokens, ~10%)
- Respect heading boundaries when `config.chunk_respect_headings=True`

**§15.2 Table-Aware Chunking**:
- Tables never split mid-table when `config.chunk_respect_tables=True`
- Oversized tables kept as single chunk rather than broken

**§15.3 Metadata Attachment** -- each chunk carries:
- `page_numbers` -- which pages the chunk spans
- `heading_path` -- heading ancestry at chunk's position
- `content_type` -- narrative, table, list, form_field, etc.
- `chunk_index` -- 0-based position within document
- `chunk_hash` -- SHA-256 of chunk text

**§15.4 Public Interface**:
```python
class PDFChunker:
    def __init__(self, config: PDFProcessorConfig): ...
    def chunk(self, text: str, headings: list[tuple[int, str, int]],
              page_boundaries: list[int]) -> list[dict]: ...
```

### 2. Config Parameters (config.py lines 90-94)

Already implemented in `PDFProcessorConfig`:
| Parameter | Type | Default |
|-----------|------|---------|
| `chunk_size_tokens` | `int` | `512` |
| `chunk_overlap_tokens` | `int` | `50` |
| `chunk_respect_headings` | `bool` | `True` |
| `chunk_respect_tables` | `bool` | `True` |

No config changes needed.

### 3. Models Available (models.py)

- `ContentType` enum (line 84): `NARRATIVE`, `TABLE`, `LIST`, `HEADING`, `FORM_FIELD`, `IMAGE_DESCRIPTION`, `FOOTER`, `HEADER`
- `PDFChunkMetadata` (line 230): has `page_numbers`, `heading_path`, `content_type` fields -- the chunker produces raw dicts that callers wrap in this model.

### 4. Token Counting

The spec says "tokens" but does not mandate a specific tokenizer. The spec has no mention of tiktoken, sentencepiece, or any specific tokenizer library. Using the simple heuristic `len(text) / 4` (chars / 4 approximates tokens) is appropriate. This is consistent with the issue description which says: "Token counting can use a simple heuristic (chars / 4 ~ tokens) unless the spec mandates a specific tokenizer."

### 5. Table Detection in Text

Tables in the text input need to be identified. The spec mentions tables are "never split mid-table" but does not specify how tables are marked in the text. The standard approach: tables will be delimited by markdown table syntax (lines starting with `|` or containing `|---|`). The chunker should detect contiguous lines matching table patterns and treat them as atomic blocks.

### 6. Existing Test Patterns

- Tests use `pytest` with class-based organization (`class TestDefaults:`, etc.)
- Tests import directly from package (`from ingestkit_pdf.config import PDFProcessorConfig`)
- `conftest.py` is currently empty (placeholder for future fixtures)
- No external services needed for unit tests

### 7. Error Handling

`ErrorCode.E_PROCESS_CHUNK` exists in `errors.py` for chunk processing errors. The chunker itself should not raise -- it should handle edge cases gracefully (empty text returns empty list, etc.).

---

## Implementation Plan

### File 1: `packages/ingestkit-pdf/src/ingestkit_pdf/utils/chunker.py`

```
Module: chunker.py
Purpose: Configurable text chunking with structural awareness
Dependencies: hashlib (stdlib), ingestkit_pdf.config.PDFProcessorConfig
```

#### Helper: `_estimate_tokens(text: str) -> int`
- Returns `max(1, len(text) // 4)`
- Simple heuristic: 4 chars per token

#### Helper: `_compute_chunk_hash(text: str) -> str`
- Returns `hashlib.sha256(text.encode("utf-8")).hexdigest()`

#### Helper: `_detect_content_type(text: str) -> str`
- Detect if text is a table (contains lines with `|` delimiters), list (lines starting with `- `, `* `, `1. `), form_field (lines with `[ ]`, `[x]`, or `___`), or narrative (default).
- Returns a `ContentType` value string: `"narrative"`, `"table"`, `"list"`, `"form_field"`

#### Helper: `_find_page_for_position(position: int, page_boundaries: list[int]) -> int`
- Given a character position in the full text, determine which page it falls on.
- `page_boundaries` is a list of character offsets where each page starts.
- Returns the 1-based page number.

#### Helper: `_get_page_numbers(start: int, end: int, page_boundaries: list[int]) -> list[int]`
- Returns the list of page numbers that a chunk spanning `[start, end)` covers.
- Uses `_find_page_for_position` for start and end.

#### Helper: `_get_heading_path(position: int, headings: list[tuple[int, str, int]]) -> list[str]`
- `headings` is `list[tuple[int, str, int]]` = `(level, title, char_offset)`.
- Walk through headings in order. For each heading with `char_offset <= position`, track it in a stack by level. Higher-level headings clear lower levels.
- Return the current heading ancestry as `list[str]`.

#### Helper: `_split_recursive(text: str, separators: list[str], chunk_size_chars: int) -> list[str]`
- Core recursive splitting logic.
- If `_estimate_tokens(text) <= chunk_size_tokens` (converted to chars), return `[text]`.
- Try the first separator in `separators`. Split text on it.
- Merge adjacent pieces to stay under `chunk_size_chars`.
- If a piece is still too large, recurse with remaining separators.
- If no separators left and text is still too large, hard-split at `chunk_size_chars` boundary.

#### Helper: `_extract_tables(text: str) -> list[tuple[int, int]]`
- Scan text for contiguous blocks of markdown table lines (lines containing `|`).
- Return list of `(start_offset, end_offset)` for each table region.

#### Class: `PDFChunker`

**`__init__(self, config: PDFProcessorConfig)`**
- Store config reference.
- Precompute `self._chunk_size_chars = config.chunk_size_tokens * 4`
- Precompute `self._overlap_chars = config.chunk_overlap_tokens * 4`
- Define `self._separators = ["\n## ", "\n### ", "\n\n", ". ", " "]`

**`chunk(self, text: str, headings: list[tuple[int, str, int]], page_boundaries: list[int]) -> list[dict]`**

Algorithm:
1. If `text` is empty or whitespace-only, return `[]`.
2. If `config.chunk_respect_tables` is True:
   a. Identify table regions via `_extract_tables(text)`.
   b. Split text into segments: non-table text and table blocks.
   c. For non-table segments, apply recursive splitting.
   d. Table blocks are kept as single atomic chunks (even if oversized).
   e. Reassemble in document order.
3. If `config.chunk_respect_tables` is False:
   a. Apply recursive splitting to entire text.
4. If `config.chunk_respect_headings` is True:
   a. When splitting, heading-level separators (`\n## `, `\n### `) act as hard boundaries -- never merge across them.
5. Apply overlap: for each chunk after the first, prepend `overlap_chars` characters from the end of the previous chunk.
6. For each chunk, compute metadata:
   - `text`: the chunk text (stripped of leading/trailing whitespace)
   - `page_numbers`: via `_get_page_numbers(start_offset, end_offset, page_boundaries)`
   - `heading_path`: via `_get_heading_path(start_offset, headings)`
   - `content_type`: via `_detect_content_type(chunk_text)`
   - `chunk_index`: 0-based sequential index
   - `chunk_hash`: via `_compute_chunk_hash(chunk_text)`
7. Return list of dicts.

**Return format:**
```python
[
    {
        "text": "chunk content...",
        "page_numbers": [1, 2],
        "heading_path": ["Chapter 1", "Section 1.1"],
        "content_type": "narrative",
        "chunk_index": 0,
        "chunk_hash": "a1b2c3..."
    },
    ...
]
```

### File 2: `packages/ingestkit-pdf/tests/test_chunker.py`

See Test Plan below.

---

## Test Plan

### File: `packages/ingestkit-pdf/tests/test_chunker.py`

All tests are unit tests (`@pytest.mark.unit` not needed -- default). No external services.

#### Class: `TestTokenEstimation`

| Test | Input | Expected |
|------|-------|----------|
| `test_empty_string` | `""` | `1` (min 1) |
| `test_short_string` | `"hello"` | `1` (5 // 4 = 1) |
| `test_known_length` | `"a" * 2048` | `512` |

#### Class: `TestChunkHash`

| Test | Input | Expected |
|------|-------|----------|
| `test_deterministic` | Same text twice | Same SHA-256 hash |
| `test_different_text` | Two different texts | Different hashes |

#### Class: `TestContentTypeDetection`

| Test | Input | Expected |
|------|-------|----------|
| `test_narrative` | Plain paragraph | `"narrative"` |
| `test_table` | Lines with `\|` delimiters | `"table"` |
| `test_list_dash` | Lines starting with `- ` | `"list"` |
| `test_list_numbered` | Lines starting with `1. ` | `"list"` |
| `test_form_field` | Lines with `[ ]` or `[x]` | `"form_field"` |

#### Class: `TestHeadingPath`

| Test | Input | Expected |
|------|-------|----------|
| `test_no_headings` | Empty headings list | `[]` |
| `test_single_heading` | One h2 before position | `["Section A"]` |
| `test_nested_headings` | h2 then h3 before position | `["Section A", "Subsection A.1"]` |
| `test_heading_reset` | h2, h3, then new h2 -- position after second h2 | `["Section B"]` (h3 cleared) |

#### Class: `TestPageNumbers`

| Test | Input | Expected |
|------|-------|----------|
| `test_single_page` | Chunk within one page | `[1]` |
| `test_spanning_pages` | Chunk crossing page boundary | `[1, 2]` |
| `test_empty_boundaries` | Empty page_boundaries | `[1]` (default to page 1) |

#### Class: `TestBasicChunking`

| Test | Input | Expected |
|------|-------|----------|
| `test_empty_text` | `""` | `[]` |
| `test_whitespace_only` | `"   \n  "` | `[]` |
| `test_short_text_single_chunk` | Text under chunk_size | Single chunk returned |
| `test_text_splits_on_paragraphs` | Two paragraphs > chunk_size | 2+ chunks, split at `\n\n` |
| `test_text_splits_on_sentences` | Long paragraph > chunk_size | Splits at `. ` |
| `test_text_splits_on_words` | Long sentence > chunk_size | Splits at ` ` |
| `test_chunk_index_sequential` | Multi-chunk text | `chunk_index` values are 0, 1, 2, ... |
| `test_chunk_hash_present` | Any chunk | Each chunk has a 64-char hex `chunk_hash` |

#### Class: `TestOverlap`

| Test | Input | Expected |
|------|-------|----------|
| `test_overlap_applied` | Multi-chunk text with overlap=50 | Second chunk starts with text from end of first chunk |
| `test_no_overlap_on_first_chunk` | Multi-chunk text | First chunk has no prefix from prior chunk |
| `test_zero_overlap` | `chunk_overlap_tokens=0` | No overlap between chunks |

#### Class: `TestHeadingRespect`

| Test | Input | Expected |
|------|-------|----------|
| `test_heading_boundary_not_crossed` | Text with `\n## ` heading, `chunk_respect_headings=True` | Chunks do not cross heading boundary |
| `test_heading_boundary_ignored_when_disabled` | Same text, `chunk_respect_headings=False` | Heading is not a hard boundary |
| `test_heading_path_propagated` | Text with headings | Each chunk's `heading_path` reflects its position |

#### Class: `TestTableAwareChunking`

| Test | Input | Expected |
|------|-------|----------|
| `test_table_not_split` | Text containing markdown table, `chunk_respect_tables=True` | Table is a single chunk |
| `test_oversized_table_kept_whole` | Table larger than `chunk_size_tokens` | Single chunk (oversized), not split |
| `test_table_content_type` | Chunk that is a table | `content_type == "table"` |
| `test_table_splitting_when_disabled` | Same table, `chunk_respect_tables=False` | Table may be split |
| `test_mixed_text_and_tables` | Narrative, then table, then narrative | 3+ chunks in order; table chunk is atomic |

#### Class: `TestPageBoundaries`

| Test | Input | Expected |
|------|-------|----------|
| `test_page_numbers_correct` | Text with known page boundaries | Each chunk's `page_numbers` matches expected pages |
| `test_chunk_spanning_pages` | Chunk that crosses a page boundary | `page_numbers` includes both pages |

#### Class: `TestConfigIntegration`

| Test | Input | Expected |
|------|-------|----------|
| `test_custom_chunk_size` | `chunk_size_tokens=256` | More, smaller chunks |
| `test_large_chunk_size` | `chunk_size_tokens=4096` on small text | Single chunk |
| `test_default_config` | Default `PDFProcessorConfig()` | Works without errors |

---

## Acceptance Criteria

- [ ] `PDFChunker` class exists at `packages/ingestkit-pdf/src/ingestkit_pdf/utils/chunker.py`
- [ ] `__init__(self, config: PDFProcessorConfig)` accepts config
- [ ] `chunk()` method signature matches §15.4: `(text, headings, page_boundaries) -> list[dict]`
- [ ] Recursive splitting follows hierarchy: `\n## ` -> `\n### ` -> `\n\n` -> `. ` -> ` `
- [ ] Target chunk size uses `config.chunk_size_tokens` (default 512)
- [ ] Overlap uses `config.chunk_overlap_tokens` (default 50)
- [ ] Heading boundaries respected when `config.chunk_respect_headings=True`
- [ ] Tables never split mid-table when `config.chunk_respect_tables=True`
- [ ] Oversized tables kept as single chunk (not broken)
- [ ] Each chunk dict contains: `text`, `page_numbers`, `heading_path`, `content_type`, `chunk_index`, `chunk_hash`
- [ ] `chunk_hash` is SHA-256 of chunk text
- [ ] `chunk_index` is 0-based sequential
- [ ] `content_type` correctly identifies narrative, table, list, form_field
- [ ] `heading_path` reflects heading ancestry at chunk position
- [ ] `page_numbers` correctly maps to page boundaries
- [ ] Token counting uses `len(text) // 4` heuristic
- [ ] Empty/whitespace input returns `[]`
- [ ] All tests in `test_chunker.py` pass
- [ ] No regressions in existing tests
- [ ] No external service dependencies in tests
- [ ] Logger name is `ingestkit_pdf` (if logging is added)
- [ ] No raw text in logs unless `config.log_chunk_previews=True`
