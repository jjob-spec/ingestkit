---
issue: 4
agent: MAP-PLAN
date: 2026-02-10
complexity: TRIVIAL
stack: backend
files_identified: 2
---

# MAP-PLAN - Issue #4

## Summary

Issue #4 requires implementing the `compute_ingest_key()` function in a new `idempotency.py` module that generates deterministic deduplication keys for Excel file ingestion. The function must compute a SHA-256 hash of the raw file bytes, derive a canonical absolute path for the source URI, and combine these with the parser version and optional tenant ID into an `IngestKey` model. The `IngestKey.key` property (already implemented in `models.py`) then produces a composite SHA-256 hex string. This is a trivial backend implementation with well-defined acceptance criteria focused on deterministic key generation behavior.

The implementation will create a single new file (`src/ingestkit_excel/idempotency.py`) containing one function and leverage the existing `IngestKey` model from `models.py`. The function must ensure identical files with identical parser versions produce identical keys, while any change to content, parser version, or tenant ID produces different keys. The package provides the key for deduplication but does NOT enforce the deduplication policy - that responsibility belongs to the caller.

## VERIFICATION STEPS (MANDATORY)

1. **Specification**: Read SPEC.md §6 (Idempotency) lines 489-520. The specification defines the key derivation contract: content_hash (SHA-256 of file bytes), source_uri (canonical absolute path), parser_version, and optional tenant_id. The package provides the key but does not enforce dedup policy.

2. **Code Verification**: Read `models.py` lines 85-104. The `IngestKey` model already exists with four fields (content_hash, source_uri, parser_version, tenant_id) and a `key` property that computes the composite SHA-256 hash by joining components with "|" and hashing the result. The model implementation is complete and correct per spec.

3. **Approach Decision**: Create a new `idempotency.py` module with a single function `compute_ingest_key(file_path, parser_version, tenant_id=None, source_uri=None)`. The function will: (1) read file bytes and compute SHA-256 hash, (2) derive canonical absolute path from file_path or use source_uri override, (3) construct and return an IngestKey instance. The existing `IngestKey.key` property handles composite key generation.

4. **Impact Analysis**: Minimal impact. This is a net-new module with no dependencies on other code. The function is pure (no side effects beyond file reading) and the IngestKey model is already complete. No modifications to existing files required. Test file `tests/test_idempotency.py` will be created separately.

5. **Completeness**: All components identified. Single function implementation in new module, leveraging existing IngestKey model. Spec section §6 fully addresses requirements. No ambiguities in acceptance criteria.

## INVESTIGATION

### Affected Files

**Files to create:**
1. `/home/jjob/projects/ingestkit/packages/ingestkit-excel/src/ingestkit_excel/idempotency.py` (NEW)
   - Single function: `compute_ingest_key(file_path, parser_version, tenant_id=None, source_uri=None) -> IngestKey`
   - Compute SHA-256 of raw file bytes
   - Derive canonical absolute path (or accept source_uri override)
   - Return IngestKey instance

**Files already complete:**
1. `/home/jjob/projects/ingestkit/packages/ingestkit-excel/src/ingestkit_excel/models.py` (lines 85-104)
   - IngestKey model fully implemented
   - `key` property correctly computes composite SHA-256 hash
   - No changes required

**Files to be created by subsequent issue:**
1. `/home/jjob/projects/ingestkit/packages/ingestkit-excel/tests/test_idempotency.py` (deferred to test implementation issue)

### Risks

**Risk: None** - This is a trivial implementation with:
- Single pure function with deterministic behavior
- Well-defined inputs and outputs
- Existing model handles composite key logic
- No external dependencies beyond stdlib hashlib and pathlib
- Clear acceptance criteria with binary pass/fail outcomes

**Mitigation: N/A** - No significant risks identified.

## PLAN

### File-by-File Steps

#### Step 1: Create `src/ingestkit_excel/idempotency.py`

**Purpose:** Implement deterministic ingest key computation function.

**Implementation details:**
1. Import required modules: `hashlib`, `pathlib.Path`, and `IngestKey` from models
2. Define function signature matching spec: `compute_ingest_key(file_path: str, parser_version: str, tenant_id: str | None = None, source_uri: str | None = None) -> IngestKey`
3. Implement function body:
   - Read raw file bytes from `file_path`
   - Compute SHA-256 hex digest of bytes for `content_hash`
   - Derive `source_uri`: use override if provided, otherwise resolve to canonical absolute path using `Path(file_path).resolve().as_posix()` or `as_uri()` for consistency
   - Construct and return `IngestKey(content_hash=..., source_uri=..., parser_version=..., tenant_id=...)`
4. Add module docstring explaining purpose and usage contract
5. Add function docstring with parameter descriptions and return type

**Key considerations:**
- Use `.resolve()` to handle symlinks and relative paths for canonical path
- Consider using `.as_uri()` (file:// URI format) or `.as_posix()` (absolute path) for `source_uri` - spec shows both formats in examples, but SPEC.md line 507 uses "canonical absolute path or URI"
- SHA-256 must be of raw bytes, not decoded text (binary mode read)
- Function should be pure with no side effects beyond file I/O

**Error handling:**
- Let FileNotFoundError propagate naturally if file doesn't exist
- Let IOError propagate for unreadable files
- No special error handling needed per spec

#### Step 2: Verification (read-only, part of implementation)

**Purpose:** Confirm implementation matches spec requirements.

**Checklist:**
- Function signature matches spec (line 498-502)
- content_hash is SHA-256 of raw file bytes
- source_uri derives canonical absolute path (or accepts override)
- parser_version passed through unchanged
- tenant_id passed through unchanged (optional)
- Returns IngestKey instance
- IngestKey.key property generates composite SHA-256 (already verified in models.py)

### Acceptance Criteria

From issue requirements and SPEC.md §6.3 (lines 514-519):

1. **Identical files produce identical keys**: Same file_path + same parser_version → same IngestKey.key
2. **Modified files produce different keys**: Different content → different content_hash → different IngestKey.key
3. **Different parser_version produces different keys**: Same file + different parser_version → different IngestKey.key
4. **tenant_id changes key when present**: Same file + parser_version with/without tenant_id → different IngestKey.key
5. **IngestKey.key is a hex string**: The composite key property returns a hexadecimal SHA-256 digest (64 characters)
6. **pytest tests/test_idempotency.py -q passes**: All acceptance criteria tests pass (deferred to test implementation issue)

### Verification Gates

**Gate 1: Implementation complete**
- File `src/ingestkit_excel/idempotency.py` created
- Function `compute_ingest_key()` implemented
- No syntax errors
- Imports resolve correctly

**Gate 2: Static verification (read-only)**
- Function signature matches spec
- SHA-256 hash computation uses raw bytes
- source_uri derivation uses canonical absolute path
- Returns correct IngestKey instance
- Module docstring present
- Function docstring present

**Gate 3: Test verification (deferred)**
- Unit tests in `tests/test_idempotency.py` pass
- All 6 acceptance criteria validated
- Edge cases covered (nonexistent file, permission errors, symlinks)

---

**IMPLEMENTATION NOTES:**

The function will be implemented as:

```python
def compute_ingest_key(
    file_path: str,
    parser_version: str,
    tenant_id: str | None = None,
    source_uri: str | None = None,
) -> IngestKey:
    """Compute a deterministic ingest key for deduplication.

    Args:
        file_path: Path to the Excel file to hash
        parser_version: Parser version string (e.g., "ingestkit_excel:1.0.0")
        tenant_id: Optional tenant identifier for multi-tenant scenarios
        source_uri: Optional override for source_uri (defaults to canonical path)

    Returns:
        IngestKey instance with content_hash, source_uri, parser_version, tenant_id

    Raises:
        FileNotFoundError: If file_path does not exist
        IOError: If file cannot be read
    """
    # 1. Compute content hash
    with open(file_path, "rb") as f:
        content_bytes = f.read()
    content_hash = hashlib.sha256(content_bytes).hexdigest()

    # 2. Derive source URI (canonical absolute path or override)
    if source_uri is None:
        source_uri = Path(file_path).resolve().as_posix()

    # 3. Return IngestKey instance
    return IngestKey(
        content_hash=content_hash,
        source_uri=source_uri,
        parser_version=parser_version,
        tenant_id=tenant_id,
    )
```

**Design decision: Use `.as_posix()` instead of `.as_uri()`**
- Spec examples show both formats but line 507 prioritizes "canonical absolute path"
- `.as_posix()` produces `/home/user/file.xlsx` (cross-platform POSIX path)
- `.as_uri()` produces `file:///home/user/file.xlsx` (URI format)
- Choose `.as_posix()` for simplicity and consistency with SPEC.md line 507 wording
- source_uri override parameter allows caller to use either format if needed

---

AGENT_RETURN: map-plan-4-021026.md
