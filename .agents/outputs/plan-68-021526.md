---
issue: 68
agent: PLAN
date: 2026-02-15
complexity: COMPLEX
stack: backend
spec_sections: "§8.0-8.5, §13.2"
estimated_lines: ~1,350
files_to_modify: 7
files_to_create: 1
---

# PLAN: Issue #68 — Implement dual-write output (DB rows and RAG chunks)

## Executive Summary

Implement the dual-write output system for ingestkit-forms that produces both structured DB rows and RAG-ready vector chunks from extracted form data. The system supports two consistency modes (best-effort and strict-atomic), configurable PII redaction scoped by destination, schema evolution for template version changes, and rollback of partially-written artifacts. The critical protocol gap (StructuredDBBackend lacks `execute_sql`/`delete_rows`) is resolved by adding a form-specific `FormDBBackend` protocol in `ingestkit_forms/protocols.py`.

## Key Design Decisions

### D1: Protocol Extension Strategy — `FormDBBackend` in `ingestkit_forms/protocols.py`

**Decision:** Add a new `FormDBBackend` protocol in `ingestkit_forms/protocols.py` rather than modifying `ingestkit_core`.

**Rationale:**
- The needed methods (`execute_sql`, `upsert_row`, `delete_rows`) are form-specific operations (individual row upsert, schema evolution via ALTER TABLE)
- `ingestkit_core.StructuredDBBackend` is designed around DataFrame-based bulk writes — the form writer needs row-level operations
- Avoids cross-package breaking changes; other packages (`ingestkit-excel`) don't need these methods
- Concrete backends can implement both protocols (structural subtyping makes this seamless)
- Consistent with the project pattern: form-specific protocols already exist in `ingestkit_forms/protocols.py` (FormTemplateStore, OCRBackend, etc.)

**Protocol definition:**
```python
@runtime_checkable
class FormDBBackend(Protocol):
    def execute_sql(self, sql: str, params: tuple | None = None) -> None: ...
    def get_table_columns(self, table_name: str) -> list[str]: ...
    def delete_rows(self, table_name: str, column: str, values: list[str]) -> int: ...
    def table_exists(self, table_name: str) -> bool: ...
    def get_connection_uri(self) -> str: ...
```

### D2: Retry Logic — Simple loop with `time.sleep`

No external retry library. Use `time.sleep(backoff_base * 2**attempt)` in a for-loop, matching the reference pattern in ingestkit-excel. Retries are capped at `config.backend_max_retries`.

### D3: Redaction — Deep copy, never mutate original

`redact_extraction()` returns a deep copy of `FormExtractionResult` with field values redacted. Called separately for DB and chunk destinations based on `redact_target`. The original extraction result is never modified.

### D4: Table Naming — `slugify_template_name` + prefix

`slugify_template_name("Leave Request")` -> `"leave_request"`, then prepend `config.form_db_table_prefix` -> `"form_leave_request"`. Same `clean_name` approach as ingestkit-excel's `structured_db.py`.

### D5: Chunk ID — `uuid.uuid5` for determinism

`uuid.uuid5(NAMESPACE_URL, f"{ingest_key}:{chunk_hash}")` — identical pattern to ingestkit-excel's `StructuredDBProcessor`.

### D6: Dual Writer Architecture — Orchestrator class

`FormDualWriter` orchestrates DB + chunk writes. It does NOT inherit from either writer. It takes `FormDBWriter` and `FormChunkWriter` as constructor arguments (dependency injection). This keeps each component independently testable.

---

## Implementation Plan

### Step 1: Extend `protocols.py` — Add `FormDBBackend`

**File:** `packages/ingestkit-forms/src/ingestkit_forms/protocols.py`
**Action:** Add new protocol and update `__all__`

Add `FormDBBackend` protocol after the existing re-exports section (after line 20), with these methods:

1. `execute_sql(sql: str, params: tuple | None = None) -> None` — for CREATE TABLE, ALTER TABLE, INSERT OR REPLACE
2. `get_table_columns(table_name: str) -> list[str]` — for schema evolution diff (returns column names of existing table)
3. `delete_rows(table_name: str, column: str, values: list[str]) -> int` — for rollback (DELETE WHERE column IN (...)), returns count deleted
4. `table_exists(table_name: str) -> bool` — check if table exists (mirrors core protocol)
5. `get_connection_uri() -> str` — connection URI for metadata (mirrors core protocol)

Add `"FormDBBackend"` to `__all__`.

**Estimated lines added:** ~25

---

### Step 2: Implement `output/db_writer.py`

**File:** `packages/ingestkit-forms/src/ingestkit_forms/output/db_writer.py`
**Action:** Replace stub with full implementation

#### 2a: Module-level constants and helpers

**`FIELD_TYPE_TO_SQL: dict[str, str]`** — mapping from `FieldType` values to SQL types:
```python
FIELD_TYPE_TO_SQL = {
    FieldType.TEXT: "TEXT",
    FieldType.NUMBER: "REAL",
    FieldType.DATE: "TEXT",
    FieldType.CHECKBOX: "INTEGER",
    FieldType.RADIO: "TEXT",
    FieldType.SIGNATURE: "INTEGER",
    FieldType.DROPDOWN: "TEXT",
}
```

**`METADATA_COLUMNS: dict[str, str]`** — the 10 metadata columns per spec §8.1:
```python
METADATA_COLUMNS = {
    "_form_id": "TEXT PRIMARY KEY",
    "_template_id": "TEXT",
    "_template_version": "INTEGER",
    "_source_uri": "TEXT",
    "_ingest_key": "TEXT",
    "_ingest_run_id": "TEXT",
    "_tenant_id": "TEXT",
    "_extracted_at": "TEXT",
    "_overall_confidence": "REAL",
    "_extraction_method": "TEXT",
}
```

**`slugify_template_name(name: str) -> str`:**
- Lowercase
- Replace non-alphanumeric/underscore with underscore
- Collapse consecutive underscores
- Strip leading/trailing underscores
- Same logic as `clean_name` in ingestkit-excel's `structured_db.py`

**`get_table_name(config: FormProcessorConfig, template: FormTemplate) -> str`:**
- Returns `f"{config.form_db_table_prefix}{slugify_template_name(template.name)}"`

**`generate_table_schema(template: FormTemplate) -> dict[str, str]`:**
- Start with `METADATA_COLUMNS` copy
- For each field in `template.fields`: add `field.field_name -> FIELD_TYPE_TO_SQL[field.field_type]`
- Return combined dict

**`build_row_dict(extraction: FormExtractionResult, config: FormProcessorConfig, ingest_key: str, ingest_run_id: str) -> dict[str, Any]`:**
- Populate metadata columns from extraction result:
  - `_form_id` = `extraction.form_id`
  - `_template_id` = `extraction.template_id`
  - `_template_version` = `extraction.template_version`
  - `_source_uri` = `extraction.source_uri`
  - `_ingest_key` = `ingest_key`
  - `_ingest_run_id` = `ingest_run_id`
  - `_tenant_id` = `config.tenant_id`
  - `_extracted_at` = `datetime.now(timezone.utc).isoformat()`
  - `_overall_confidence` = `extraction.overall_confidence`
  - `_extraction_method` = `extraction.extraction_method`
- For each field in `extraction.fields`:
  - If `field.field_type` is CHECKBOX: convert bool to int (True->1, False->0, None->None)
  - If `field.field_type` is SIGNATURE: convert bool to int (same)
  - Otherwise: use `field.value` directly
  - Key is `field.field_name`

#### 2b: `FormDBWriter` class

```python
class FormDBWriter:
    def __init__(self, db: FormDBBackend, config: FormProcessorConfig) -> None:
        self._db = db
        self._config = config

    def ensure_table(self, template: FormTemplate) -> str:
        """Create table if not exists. Returns table name."""

    def evolve_schema(self, table_name: str, new_template: FormTemplate) -> list[str]:
        """Add columns for new fields. Returns list of added column names."""

    def write_row(self, table_name: str, extraction: FormExtractionResult,
                  ingest_key: str, ingest_run_id: str) -> str:
        """Write a single form row. Returns _form_id."""
```

**`ensure_table(template)`:**
1. Compute `table_name = get_table_name(self._config, template)`
2. If `self._db.table_exists(table_name)` is True: check for schema evolution (new fields in template not in existing columns), call `evolve_schema` if needed
3. Else: generate schema, build `CREATE TABLE IF NOT EXISTS` SQL, call `self._db.execute_sql(sql)`
4. Return `table_name`

**`evolve_schema(table_name, new_template)`:**
1. Get existing columns: `self._db.get_table_columns(table_name)`
2. Compute new field names not in existing columns
3. For each new field: `ALTER TABLE {table_name} ADD COLUMN {field_name} {sql_type}`
4. Emit `W_FORM_SCHEMA_EVOLVED` warning via logger
5. Return list of added column names
6. Wrap in try/except: on failure, raise `FormIngestException` with `E_FORM_DB_SCHEMA_EVOLUTION_FAILED`

**`write_row(table_name, extraction, ingest_key, ingest_run_id)`:**
1. Build row dict via `build_row_dict(extraction, self._config, ingest_key, ingest_run_id)`
2. Build `INSERT OR REPLACE INTO {table_name} ({columns}) VALUES ({placeholders})` SQL
3. Retry loop: up to `config.backend_max_retries + 1` attempts
   - Call `self._db.execute_sql(sql, params)`
   - On success: return `extraction.form_id`
   - On failure: `time.sleep(config.backend_backoff_base * 2**attempt)`, continue
4. After retries exhausted: raise `FormIngestException` with `E_FORM_DB_WRITE_FAILED`

**Estimated lines:** ~250

---

### Step 3: Implement `output/chunk_writer.py`

**File:** `packages/ingestkit-forms/src/ingestkit_forms/output/chunk_writer.py`
**Action:** Replace stub with full implementation

#### 3a: Module-level helpers

**`serialize_field_value(field: ExtractedField) -> str`:**
- If `field.value is None`: return `"[not extracted]"`
- If `field.field_type` is CHECKBOX or SIGNATURE: return `"Yes"` if truthy, `"No"` otherwise
- Otherwise: return `str(field.value)`

**`serialize_form_to_text(extraction: FormExtractionResult, fields: list[ExtractedField]) -> str`:**
- Header: `f"Form: {extraction.template_name} (v{extraction.template_version})"`
- Date line: `f"Date Extracted: {datetime.now(timezone.utc).strftime('%Y-%m-%d')}"`
- Blank line
- For each field: `f"{field.field_label}: {serialize_field_value(field)}"`
- Join with newlines

**`split_fields_into_chunks(fields: list[ExtractedField], chunk_max_fields: int) -> list[list[ExtractedField]]`:**
- If `len(fields) <= chunk_max_fields`: return `[fields]`
- Otherwise: group fields by `field.page_number` (preserving order), return list of groups
- If a single page exceeds `chunk_max_fields`, keep it as one chunk (don't split within a page)

**`build_chunk_metadata(...)` -> `FormChunkMetadata`:**
- Standard fields from `BaseChunkMetadata`: `source_uri`, `source_format`, `ingestion_method="form_extraction"`, `parser_version`, `chunk_index`, `chunk_hash`, `ingest_key`, `ingest_run_id`, `tenant_id`
- Form-specific fields from extraction: `template_id`, `template_name`, `template_version`, `form_id`, `field_names`, `extraction_method`, `overall_confidence`, `per_field_confidence`, `form_date`, `page_numbers`, `match_method`
- `form_date`: scan fields for first DATE-type field with a non-None value
- `page_numbers`: unique sorted page numbers from chunk fields

#### 3b: `FormChunkWriter` class

```python
class FormChunkWriter:
    def __init__(self, vector_store: VectorStoreBackend, embedder: EmbeddingBackend,
                 config: FormProcessorConfig) -> None:
        self._vector_store = vector_store
        self._embedder = embedder
        self._config = config

    def write_chunks(self, extraction: FormExtractionResult, source_uri: str,
                     ingest_key: str, ingest_run_id: str) -> tuple[list[str], EmbedStageResult]:
        """Serialize, embed, and upsert form chunks. Returns (vector_point_ids, embed_result)."""
```

**`write_chunks(...)` flow:**
1. Split fields: `split_fields_into_chunks(extraction.fields, config.chunk_max_fields)`
2. Ensure collection: `self._vector_store.ensure_collection(config.default_collection, self._embedder.dimension())`
3. For each chunk group:
   a. Serialize text: `serialize_form_to_text(extraction, chunk_fields)`
   b. Compute `chunk_hash = hashlib.sha256(text.encode()).hexdigest()`
   c. Compute `chunk_id = str(uuid.uuid5(uuid.NAMESPACE_URL, f"{ingest_key}:{chunk_hash}"))`
   d. Build `FormChunkMetadata`
   e. Create `FormChunkPayload(id=chunk_id, text=text, vector=[], metadata=metadata)`
4. Batch embed all chunk texts: retry loop with `config.backend_max_retries`
   - `vectors = self._embedder.embed(texts, timeout=config.backend_timeout_seconds)`
   - On failure: sleep and retry
   - After retries exhausted: raise `FormIngestException` with `E_FORM_CHUNK_WRITE_FAILED`
5. Assign vectors to payloads
6. Upsert chunks to vector store: retry loop
   - `self._vector_store.upsert_chunks(config.default_collection, payloads)`
   - On failure: sleep and retry
7. Return `(vector_point_ids, EmbedStageResult(...))`

**Estimated lines:** ~200

---

### Step 4: Implement `output/dual_writer.py` (NEW FILE)

**File:** `packages/ingestkit-forms/src/ingestkit_forms/output/dual_writer.py`
**Action:** Create new file

#### 4a: Redaction helpers

**`apply_redaction(value: str, patterns: list[re.Pattern]) -> str`:**
- For each compiled pattern: `value = pattern.sub("[REDACTED]", value)`
- Return modified value

**`redact_extraction(extraction: FormExtractionResult, config: FormProcessorConfig, destination: str) -> FormExtractionResult`:**
- If no `config.redact_patterns`: return extraction unchanged (no copy needed)
- Check `config.redact_target` vs `destination` ("db" or "chunks"):
  - If target is "both": always redact
  - If target is "chunks_only" and destination is "db": return unchanged
  - If target is "db_only" and destination is "chunks": return unchanged
- Deep copy extraction via `extraction.model_copy(deep=True)`
- Compile patterns: `[re.compile(p) for p in config.redact_patterns]`
- For each field in copy: if `field.value` is a string, apply redaction
- Return modified copy

#### 4b: `FormDualWriter` class

```python
class FormDualWriter:
    def __init__(self, db_writer: FormDBWriter, chunk_writer: FormChunkWriter,
                 config: FormProcessorConfig) -> None:
        self._db_writer = db_writer
        self._chunk_writer = chunk_writer
        self._config = config
```

**`write(extraction, template, source_uri, ingest_key, ingest_run_id) -> FormWrittenArtifacts`:**

Flow:
1. Initialize: `written = FormWrittenArtifacts(vector_collection=config.default_collection)`, `errors = []`, `warnings = []`, `error_details = []`, `embed_result = None`
2. **DB Write:**
   a. Redact for DB: `db_extraction = redact_extraction(extraction, config, "db")`
   b. Try:
      - `table_name = self._db_writer.ensure_table(template)`
      - `form_id = self._db_writer.write_row(table_name, db_extraction, ingest_key, ingest_run_id)`
      - `written.db_table_names.append(table_name)`
      - `written.db_row_ids.append(form_id)`
      - `db_success = True`
   c. Except: record error, `db_success = False`
3. **Chunk Write:**
   a. Redact for chunks: `chunk_extraction = redact_extraction(extraction, config, "chunks")`
   b. Try:
      - `point_ids, embed_result = self._chunk_writer.write_chunks(chunk_extraction, source_uri, ingest_key, ingest_run_id)`
      - `written.vector_point_ids.extend(point_ids)`
      - `chunk_success = True`
   c. Except: record error, `chunk_success = False`
4. **Consistency enforcement:**
   - If `config.dual_write_mode == "strict_atomic"`:
     - If `db_success and not chunk_success`: rollback DB row
     - If `chunk_success and not db_success`: rollback vector points
     - On rollback failure: append `W_FORM_ROLLBACK_FAILED` warning
     - On rollback: clear the written artifacts for the rolled-back side
   - If `config.dual_write_mode == "best_effort"`:
     - If partial: append `W_FORM_PARTIAL_WRITE` warning and `E_FORM_DUAL_WRITE_PARTIAL` error detail
5. Return `(written, errors, warnings, error_details, embed_result)`

#### 4c: Module-level rollback function

**`rollback_written_artifacts(written: FormWrittenArtifacts, vector_backend: VectorStoreBackend | None, db_backend: FormDBBackend | None, config: FormProcessorConfig) -> RollbackResult`:**

Per spec §8.5:
1. Initialize `result = RollbackResult()`
2. **Delete vector points first** (if any and vector_backend provided):
   - Retry loop up to `config.backend_max_retries + 1`
   - `count = vector_backend.delete_by_ids(written.vector_collection, written.vector_point_ids)`
   - `result.vector_points_deleted = count`
   - On failure after retries: record error, `result.fully_rolled_back = False`
3. **Delete DB rows second** (if any and db_backend provided):
   - For each table in `written.db_table_names`:
     - Retry loop
     - `count = db_backend.delete_rows(table_name, "_form_id", written.db_row_ids)`
     - `result.db_rows_deleted += count`
   - On failure after retries: record error, `result.fully_rolled_back = False`
4. Return `result`

**Estimated lines:** ~250

---

### Step 5: Update `output/__init__.py`

**File:** `packages/ingestkit-forms/src/ingestkit_forms/output/__init__.py`
**Action:** Add public exports

```python
from ingestkit_forms.output.chunk_writer import FormChunkWriter
from ingestkit_forms.output.db_writer import FormDBWriter
from ingestkit_forms.output.dual_writer import FormDualWriter, rollback_written_artifacts

__all__ = [
    "FormDBWriter",
    "FormChunkWriter",
    "FormDualWriter",
    "rollback_written_artifacts",
]
```

**Estimated lines:** ~15

---

### Step 6: Add mock backends to `tests/conftest.py`

**File:** `packages/ingestkit-forms/tests/conftest.py`
**Action:** Add mock backends for DB, vector store, and embedder

#### `MockFormDBBackend`

In-memory dict-of-dicts backend:
- `_tables: dict[str, dict[str, str]]` — table schemas (column -> type)
- `_rows: dict[str, list[dict]]` — table rows
- `execute_sql(sql, params)` — parse and execute CREATE TABLE, ALTER TABLE, INSERT OR REPLACE
  - Implementation: simple string parsing to determine operation, store in memory structures
  - For CREATE TABLE: parse column names/types, store in `_tables`
  - For ALTER TABLE ADD COLUMN: add column to `_tables[table_name]`
  - For INSERT OR REPLACE: parse column values, upsert by `_form_id` in `_rows`
- `get_table_columns(table_name)` — return keys from `_tables[table_name]`
- `delete_rows(table_name, column, values)` — filter rows, return count deleted
- `table_exists(table_name)` — return `table_name in self._tables`
- `get_connection_uri()` — return `"mock://memory"`
- Add attributes to track calls for assertion: `execute_sql_calls`, `delete_rows_calls`

#### `MockVectorStoreBackend`

In-memory backend:
- `_collections: dict[str, dict[str, Any]]` — collection -> {id: payload}
- `upsert_chunks(collection, chunks)` — store chunks by id
- `ensure_collection(collection, vector_size)` — create empty dict
- `create_payload_index(collection, field, field_type)` — no-op
- `delete_by_ids(collection, ids)` — delete and return count
- Add `upsert_calls`, `delete_calls` tracking attributes

#### `MockEmbeddingBackend`

- `embed(texts, timeout)` — return deterministic vectors: `[[0.1] * dimension] * len(texts)`
- `dimension()` — return `768` (or configurable)
- Add `embed_calls` tracking attribute

#### Fixtures

```python
@pytest.fixture()
def mock_form_db():
    return MockFormDBBackend()

@pytest.fixture()
def mock_vector_store():
    return MockVectorStoreBackend()

@pytest.fixture()
def mock_embedder():
    return MockEmbeddingBackend()
```

Also add a helper to create `FormExtractionResult` test instances:

```python
def make_extraction_result(
    fields: list[ExtractedField] | None = None,
    template_name: str = "Test Template",
    ...
) -> FormExtractionResult:
    ...
```

**Estimated lines added:** ~120

---

### Step 7: Implement `tests/test_output.py`

**File:** `packages/ingestkit-forms/tests/test_output.py`
**Action:** Replace stub with comprehensive tests

All tests marked with `@pytest.mark.unit`.

#### DB Writer tests (~15 tests)

| Test | What it verifies |
|------|-----------------|
| `test_slugify_template_name_basic` | "Leave Request" -> "leave_request" |
| `test_slugify_template_name_special_chars` | "W-4 (2026)" -> "w_4_2026" |
| `test_slugify_template_name_unicode` | Handles non-ASCII gracefully |
| `test_get_table_name` | prefix + slug concatenation |
| `test_field_type_to_sql_all_types` | All 7 FieldType values map correctly |
| `test_generate_table_schema` | 10 metadata columns + field columns |
| `test_build_row_dict_happy_path` | Correct keys, values, metadata |
| `test_build_row_dict_none_values` | None fields included as None |
| `test_build_row_dict_checkbox_coercion` | True->1, False->0 |
| `test_build_row_dict_signature_coercion` | True->1, False->0 |
| `test_ensure_table_creates_new` | CREATE TABLE SQL issued |
| `test_ensure_table_existing_with_evolution` | ALTER TABLE ADD COLUMN for new fields |
| `test_evolve_schema_no_changes` | Returns empty list when no new fields |
| `test_write_row_success` | Row written, form_id returned |
| `test_write_row_retry_then_success` | Fails once then succeeds |
| `test_write_row_exhausts_retries` | Raises FormIngestException after max retries |

#### Chunk Writer tests (~12 tests)

| Test | What it verifies |
|------|-----------------|
| `test_serialize_field_value_text` | Plain text pass-through |
| `test_serialize_field_value_none` | Returns "[not extracted]" |
| `test_serialize_field_value_checkbox_yes` | True -> "Yes" |
| `test_serialize_field_value_checkbox_no` | False -> "No" |
| `test_serialize_form_to_text_format` | Header + field pairs per §8.2 |
| `test_split_fields_single_chunk` | <= chunk_max_fields -> single chunk |
| `test_split_fields_multi_page` | > chunk_max_fields splits by page |
| `test_build_chunk_metadata_fields` | All 11 form-specific fields present |
| `test_build_chunk_metadata_form_date` | Extracts date from DATE field |
| `test_write_chunks_happy_path` | Embeds, upserts, returns IDs |
| `test_write_chunks_retry` | Retries on embed failure |
| `test_chunk_id_deterministic` | Same input -> same chunk ID |

#### Dual Writer tests (~15 tests)

| Test | What it verifies |
|------|-----------------|
| `test_dual_write_both_success` | Both artifacts populated, no errors |
| `test_best_effort_db_fail_vector_success` | Vector points retained, DB error recorded |
| `test_best_effort_vector_fail_db_success` | DB row retained, chunk error recorded |
| `test_best_effort_both_fail` | Zero artifacts, both errors |
| `test_strict_atomic_db_fail_vector_success` | Vector points rolled back |
| `test_strict_atomic_vector_fail_db_success` | DB row rolled back |
| `test_strict_atomic_both_fail` | Zero artifacts, no rollback needed |
| `test_strict_atomic_rollback_failure` | W_FORM_ROLLBACK_FAILED emitted |
| `test_redaction_both_targets` | Values redacted in DB and chunks |
| `test_redaction_chunks_only` | DB has raw values, chunks redacted |
| `test_redaction_db_only` | DB redacted, chunks have raw values |
| `test_redaction_no_patterns` | No redaction when patterns empty |
| `test_redaction_preserves_original` | Original extraction not mutated |
| `test_rollback_vector_first_then_db` | Verify order via call tracking |
| `test_rollback_idempotent` | Safe to call with empty artifacts |

**Estimated lines:** ~500

---

## Dependency Graph and Implementation Order

```
Step 1: protocols.py (FormDBBackend)          [no deps]
    |
    v
Step 2: output/db_writer.py                   [depends on: protocols.py, models.py, config.py, errors.py]
Step 3: output/chunk_writer.py                 [depends on: protocols.py, models.py, config.py, errors.py]
    |         |
    v         v
Step 4: output/dual_writer.py                 [depends on: db_writer, chunk_writer, models.py, config.py]
    |
    v
Step 5: output/__init__.py                    [depends on: all writers]
    |
    v
Step 6: tests/conftest.py (mock backends)     [depends on: protocols.py]
    |
    v
Step 7: tests/test_output.py                  [depends on: all implementation + conftest]
```

Steps 2 and 3 are independent and can be implemented in parallel.

---

## Files Summary

| # | File | Action | Est. Lines |
|---|------|--------|------------|
| 1 | `packages/ingestkit-forms/src/ingestkit_forms/protocols.py` | Extend | +25 |
| 2 | `packages/ingestkit-forms/src/ingestkit_forms/output/db_writer.py` | Implement | ~250 |
| 3 | `packages/ingestkit-forms/src/ingestkit_forms/output/chunk_writer.py` | Implement | ~200 |
| 4 | `packages/ingestkit-forms/src/ingestkit_forms/output/dual_writer.py` | **Create** | ~250 |
| 5 | `packages/ingestkit-forms/src/ingestkit_forms/output/__init__.py` | Update | ~15 |
| 6 | `packages/ingestkit-forms/tests/conftest.py` | Extend | +120 |
| 7 | `packages/ingestkit-forms/tests/test_output.py` | Implement | ~500 |
| | **Total** | | **~1,360** |

---

## Acceptance Criteria

- [ ] `FormDBBackend` protocol added to `protocols.py` with `execute_sql`, `get_table_columns`, `delete_rows`, `table_exists`, `get_connection_uri`
- [ ] DB rows written with correct schema: 10 metadata columns + field columns per §8.1
- [ ] `slugify_template_name` converts template name to DB-safe slug
- [ ] Schema evolution adds nullable columns via ALTER TABLE without dropping existing columns
- [ ] Upsert semantics: INSERT OR REPLACE on `_form_id`
- [ ] Chunks serialized per §8.2 format: header (name, version, date) + field label/value pairs
- [ ] None values serialized as `[not extracted]`; checkboxes as Yes/No
- [ ] Splitting: single chunk if <= `chunk_max_fields`, split by page if exceeded
- [ ] `FormChunkMetadata` contains all 11 form-specific fields per §8.3
- [ ] Chunk IDs are deterministic via `uuid.uuid5(NAMESPACE_URL, "{ingest_key}:{chunk_hash}")`
- [ ] Best-effort mode retains partial writes on single-backend failure
- [ ] Strict-atomic mode rolls back successful write when other backend fails
- [ ] Rollback order: vector points first, then DB rows (per §8.5)
- [ ] Rollback retried up to `backend_max_retries`; `W_FORM_ROLLBACK_FAILED` on rollback failure
- [ ] Redaction applied per `redact_target` (both/chunks_only/db_only)
- [ ] Redaction uses deep copy; original `FormExtractionResult` never mutated
- [ ] Retry logic: `time.sleep(backoff_base * 2**attempt)` up to `backend_max_retries`
- [ ] All public functions have unit tests (42 tests total)
- [ ] Mock backends in conftest: `MockFormDBBackend`, `MockVectorStoreBackend`, `MockEmbeddingBackend`
- [ ] No regressions in existing tests

---

## Risk Mitigations

| Risk | Severity | Mitigation |
|------|----------|------------|
| `MockFormDBBackend` SQL parsing too complex | MEDIUM | Keep it simple: regex-match on `CREATE TABLE`, `ALTER TABLE`, `INSERT OR REPLACE` prefixes. Don't build a full SQL parser. Store data in dicts keyed by table/form_id. |
| Redaction ordering bug (raw values persisted) | MEDIUM | Test explicitly: verify mock DB/vector store received redacted values, not raw. Test that original extraction is unchanged after writes. |
| Schema evolution + write race condition | LOW | Single-process on-prem. Document limitation. No mitigation needed for v1. |
| Retry sleep slowing tests | LOW | Set `backend_max_retries=1` and `backend_backoff_base=0.0` in test config to avoid real delays. |

---

## Verification Gates (for PROVE)

```bash
# Unit tests
pytest packages/ingestkit-forms/tests/test_output.py -v -m unit

# All forms tests (check no regressions)
pytest packages/ingestkit-forms/tests/ -v

# Import check (verify exports work)
python -c "from ingestkit_forms.output import FormDBWriter, FormChunkWriter, FormDualWriter, rollback_written_artifacts; print('OK')"
```

AGENT_RETURN: .agents/outputs/plan-68-021526.md
