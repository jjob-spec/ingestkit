---
issue: 28
agent: MAP
date: 2026-02-14
complexity: medium
stack: [python, pydantic, pytest]
files_to_create:
  - packages/ingestkit-pdf/src/ingestkit_pdf/inspector.py
  - packages/ingestkit-pdf/tests/test_inspector.py
files_to_modify: []
---

# MAP Artifact: Issue #28 -- Tier 1 Rule-Based PDF Inspector

## Executive Summary

Implement `PDFInspector` in `packages/ingestkit-pdf/src/ingestkit_pdf/inspector.py` -- a rule-based per-page structural classifier that handles ~80% of PDF files without any LLM call. The inspector evaluates 7 signals per page from the `DocumentProfile`, classifies each page as text-native / scanned / complex, then aggregates to a document-level `ClassificationResult`. The existing Excel inspector (`ExcelInspector`) provides a well-established pattern to follow, adapted from sheet-level to page-level granularity.

## Investigation Findings

### 1. SPEC Requirements (Section 9.1-9.4)

**Location:** `packages/ingestkit-pdf/SPEC.md` lines 890-928

**Purpose (9.1):** Classify pages without LLM. Fast, deterministic, handles ~80% of files. Zero external dependencies. Always produces a result. Foundation of LLM outage resilience (section 5.2).

**7 Per-Page Signals (9.2):**

| # | Signal | Text-native (Type A) | Scanned (Type B) | Complex (Type C) |
|---|--------|---------------------|-------------------|------------------|
| 1 | Text chars/page | >= 200 (`min_chars_per_page`) | < 50 | Variable |
| 2 | Image coverage ratio | < 0.3 (`max_image_coverage_for_text`) | > 0.7 | Variable |
| 3 | Font count | >= 1 (`min_font_count_for_digital`) | 0 or near-0 | Variable |
| 4 | Table count | 0 | 0 | >= 1 (`min_table_count_for_complex`) |
| 5 | Multi-column layout | No | No | Yes |
| 6 | Form fields | No | No | Yes |
| 7 | Page consistency | All same type | All same type | Mixed |

**Decision Logic (9.3):**
- Per page:
  - chars >= 200, low image coverage, fonts present, no tables --> text-native (high confidence)
  - chars < 50, high image coverage, 0 fonts --> scanned (high confidence)
  - tables detected, multi-column, form fields, or mixed signals --> complex (high confidence)
  - Borderline --> escalate to Tier 2
- Per document:
  - All pages agree --> classify as that type
  - Pages disagree --> classify as complex, record per-page types

**Public Interface (9.4):**
```python
class PDFInspector:
    def __init__(self, config: PDFProcessorConfig): ...
    def classify(self, profile: DocumentProfile) -> ClassificationResult: ...
```

### 2. Existing Pattern: Excel Inspector

**File:** `packages/ingestkit-excel/src/ingestkit_excel/inspector.py` (220 lines)

The Excel inspector follows this structure:
- `ExcelInspector.__init__(config)` -- stores config
- `ExcelInspector.classify(profile: FileProfile) -> ClassificationResult` -- public API
  1. Edge case: no sheets --> inconclusive (confidence 0.0)
  2. Classify each sheet independently via `_classify_sheet()`
  3. Build aggregated signals dict
  4. Check for inconclusive sheets --> if any, whole file is inconclusive
  5. Check agreement: all same type --> that type; disagree --> hybrid
- `ExcelInspector._classify_sheet(sheet)` -- evaluates 5 binary signals, counts Type A vs Type B
- `ExcelInspector._evaluate_signals(sheet)` -- returns dict of 5 boolean signals

**Key difference for PDF:** The Excel inspector uses a binary signal model (each signal leans Type A or Type B). The PDF inspector has a *three-way* classification per page (text-native, scanned, complex), which requires different decision logic. Signals 1-3 distinguish text-native vs scanned, while signals 4-6 detect complex. Signal 7 is document-level aggregation.

### 3. Models Available

**File:** `packages/ingestkit-pdf/src/ingestkit_pdf/models.py`

All models needed are already implemented:

- **`PageProfile`** -- has all 7 signal fields: `text_length`, `image_coverage_ratio`, `font_count`, `table_count`, `is_multi_column`, `has_form_fields`, `page_type`
- **`DocumentProfile`** -- has `pages: list[PageProfile]`, `page_count`, `page_type_distribution`, `file_path`
- **`ClassificationResult`** -- output model with `pdf_type: PDFType`, `confidence: float`, `tier_used: ClassificationTier`, `reasoning: str`, `per_page_types: dict[int, PageType]`, `signals: dict[str, Any] | None`, `degraded: bool`
- **`PDFType`** -- `TEXT_NATIVE`, `SCANNED`, `COMPLEX`
- **`PageType`** -- `TEXT`, `SCANNED`, `TABLE_HEAVY`, `FORM`, `MIXED`, `BLANK`, `VECTOR_ONLY`, `TOC`
- **`ClassificationTier`** -- imported from `ingestkit_core.models`, values: `RULE_BASED`, `LLM_BASIC`, `LLM_REASONING`

### 4. Config Thresholds Available

**File:** `packages/ingestkit-pdf/src/ingestkit_pdf/config.py`

Relevant Tier 1 fields in `PDFProcessorConfig`:

| Field | Default | Usage |
|-------|---------|-------|
| `min_chars_per_page` | 200 | Signal 1: text-native threshold |
| `max_image_coverage_for_text` | 0.3 | Signal 2: text-native ceiling |
| `min_font_count_for_digital` | 1 | Signal 3: text-native threshold |
| `min_table_count_for_complex` | 1 | Signal 4: complex threshold |
| `tier1_high_confidence_signals` | 4 | High confidence signal agreement count |
| `tier1_medium_confidence_signals` | 3 | Medium confidence signal agreement count |

**Missing config fields (hardcoded in SPEC):**
- `max_chars_for_scanned` -- SPEC says "< 50" (hardcoded constant)
- `min_image_coverage_for_scanned` -- SPEC says "> 0.7" (hardcoded constant)

### 5. Error/Warning Codes

**File:** `packages/ingestkit-pdf/src/ingestkit_pdf/errors.py`

Relevant codes:
- `E_CLASSIFY_INCONCLUSIVE` -- classification could not determine type
- `W_PAGE_SKIPPED_BLANK` -- empty/near-empty page
- `W_PAGE_SKIPPED_TOC` -- table of contents page
- `W_PAGE_SKIPPED_VECTOR_ONLY` -- vector-only page
- `W_CLASSIFICATION_DEGRADED` -- LLM tiers were unavailable (not used by Tier 1 directly)

### 6. Test Infrastructure

**File:** `packages/ingestkit-pdf/tests/conftest.py` -- currently minimal (placeholder comment)

Existing test files show the pattern:
- Import from `ingestkit_pdf.*` directly
- Use class-based test organization (`class TestDefaults:`, etc.)
- Test file uses `from __future__ import annotations`

The Excel test_inspector.py (659 lines) provides the test structure blueprint:
- Helper functions: `_make_sheet_profile(**overrides)`, `_make_file_profile(sheets, **overrides)`
- Test classes: `TestSignalEvaluation`, `TestSingleSheetClassification`, `TestMultiSheetAgreement`, `TestMultiSheetDisagreement`, `TestInconclusiveEscalation`, `TestEmptyProfile`, `TestClassificationResultFields`, `TestCustomConfig`, `TestBoundaryValues`

## Key Decisions for PLAN

### Decision 1: Three-Way Per-Page Classification Logic

The Excel inspector uses a binary model (Type A count vs Type B count). The PDF inspector needs a three-way model. Proposed approach:

1. First check for "complex" indicators (tables, multi-column, form fields) -- if any present, page is complex.
2. Then check text-native indicators (chars >= 200, low image coverage, fonts present) -- if all present, page is text-native.
3. Then check scanned indicators (chars < 50, high image coverage, 0 fonts) -- if all present, page is scanned.
4. If none of the above match cleanly, mark page as borderline (for Tier 2 escalation).

### Decision 2: Scanned Thresholds -- Hardcode vs Config

The SPEC specifies `< 50 chars` and `> 0.7 image coverage` for scanned detection, but these are not in `PDFProcessorConfig`. Two options:
- **Option A:** Define as module-level constants in `inspector.py` (e.g., `_MAX_CHARS_FOR_SCANNED = 50`, `_MIN_IMAGE_COVERAGE_FOR_SCANNED = 0.7`).
- **Option B:** Add new fields to `PDFProcessorConfig`.

**Recommendation:** Option A. The SPEC does not list these as configurable parameters in section 6, and adding config fields would change an already-implemented module. Use named constants for clarity.

### Decision 3: Confidence Calculation

The Excel inspector uses signal counting (4+ of 5 signals = high 0.9, 3+ = medium 0.7). For PDF:
- Per-page confidence: based on how strongly signals agree on the classification (all signals agree = high, most agree = medium, mixed = low/borderline).
- Per-document confidence: minimum of all page confidences (same pattern as Excel).

### Decision 4: Handling Special Page Types

`PageType` includes `BLANK`, `VECTOR_ONLY`, and `TOC`. The inspector should:
- Detect blank pages (very low text, low image coverage) and classify as `PageType.BLANK`.
- Skip blank/TOC/vector-only pages when computing document-level classification agreement.
- These pages don't contribute to the text-native vs scanned vs complex decision.

### Decision 5: Per-Page Types in ClassificationResult

`ClassificationResult.per_page_types` is `dict[int, PageType]` (page number to PageType). The inspector should populate this for every page, not just when pages disagree (unlike Excel which only sets `per_sheet_types` on hybrid).

### Decision 6: Signal 7 (Page Consistency)

Signal 7 is not a per-page signal but a document-level aggregation rule. It should be applied in the document-level `classify()` method, not in per-page evaluation. If pages of different types are found, the document is classified as `COMPLEX`.

## Dependency Analysis

### Import Dependencies (all already exist)

```python
from ingestkit_pdf.config import PDFProcessorConfig
from ingestkit_pdf.models import (
    ClassificationResult,
    ClassificationTier,  # re-exported from ingestkit_core
    DocumentProfile,
    PageProfile,
    PageType,
    PDFType,
)
```

No new dependencies needed. No external packages required.

### Downstream Consumers

The `ClassificationResult` output will be consumed by:
- `PDFRouter` (not yet implemented) -- routes to Path A/B/C based on `pdf_type`
- `llm_classifier.py` (not yet implemented) -- receives documents that Tier 1 marks as borderline

## File Inventory

### Files That Exist

| File | Status | Relevance |
|------|--------|-----------|
| `packages/ingestkit-pdf/src/ingestkit_pdf/models.py` | Complete | All models needed are defined |
| `packages/ingestkit-pdf/src/ingestkit_pdf/config.py` | Complete | All Tier 1 thresholds defined |
| `packages/ingestkit-pdf/src/ingestkit_pdf/errors.py` | Complete | Error codes available |
| `packages/ingestkit-pdf/src/ingestkit_pdf/__init__.py` | Minimal | May need `PDFInspector` export later |
| `packages/ingestkit-pdf/tests/conftest.py` | Placeholder | Needs `PageProfile` / `DocumentProfile` fixtures |
| `packages/ingestkit-excel/src/ingestkit_excel/inspector.py` | Reference | Pattern to follow (adapted for PDF) |
| `packages/ingestkit-excel/tests/test_inspector.py` | Reference | Test structure to follow |

### Files to Create

| File | Purpose | Estimated Size |
|------|---------|---------------|
| `packages/ingestkit-pdf/src/ingestkit_pdf/inspector.py` | Tier 1 rule-based PDF inspector | ~250 lines |
| `packages/ingestkit-pdf/tests/test_inspector.py` | Full test suite | ~600 lines |

### Files to Potentially Modify

| File | Change |
|------|--------|
| `packages/ingestkit-pdf/tests/conftest.py` | Add shared helper fixtures for `PageProfile` / `DocumentProfile` construction |

## Test Plan Outline

Following the Excel test structure, the PDF test suite should cover:

1. **TestPerPageSignalEvaluation** -- verify each of the 7 signals individually
2. **TestPerPageClassification** -- text-native (high conf), scanned (high conf), complex (high conf), borderline
3. **TestDocumentLevelAgreement** -- all pages text-native, all scanned, all complex
4. **TestDocumentLevelDisagreement** -- mixed pages --> complex
5. **TestSpecialPages** -- blank pages, TOC pages, vector-only pages (should not affect classification)
6. **TestInconclusiveEscalation** -- borderline signals, confidence = 0.0
7. **TestEmptyProfile** -- no pages at all
8. **TestClassificationResultFields** -- all output fields correctly populated
9. **TestCustomConfig** -- custom thresholds respected
10. **TestBoundaryValues** -- exact threshold boundaries
11. **TestConfidenceCalculation** -- min confidence across pages, document-level confidence
