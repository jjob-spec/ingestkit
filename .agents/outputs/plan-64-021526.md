---
issue: 64
title: "Implement OCR overlay extraction for scanned/image forms"
agent: plan
timestamp: 2026-02-15
status: complete
branch: feature/issue-64-ocr-overlay-extractor
complexity: COMPLEX
stack: backend
files_to_create:
  - packages/ingestkit-forms/src/ingestkit_forms/extractors/_preprocessing.py
  - packages/ingestkit-forms/src/ingestkit_forms/extractors/_rendering.py
files_to_modify:
  - packages/ingestkit-forms/src/ingestkit_forms/extractors/ocr_overlay.py
  - packages/ingestkit-forms/src/ingestkit_forms/extractors/__init__.py
  - packages/ingestkit-forms/tests/test_extractors.py
  - packages/ingestkit-forms/pyproject.toml
---

# PLAN: Issue #64 -- OCR Overlay Extraction for Scanned/Image Forms

## Executive Summary

Implement `OCROverlayExtractor` per spec section 7.2: render PDF pages or load images, crop each template field region, apply field-type-specific preprocessing (deskew, CLAHE, noise reduction, binarization), run per-field OCR via the `OCRBackend` protocol, and handle non-text fields (checkbox fill ratio, signature ink ratio) locally. The implementation spans three source modules (preprocessing, rendering, core extractor), one test file, and minor updates to exports and dependencies. All OCR access is protocol-mediated; no concrete engine is imported.

## Execution Order

```
1. _preprocessing.py  (new, independent)
2. _rendering.py      (new, independent -- parallel with 1)
3. ocr_overlay.py     (depends on 1 + 2)
4. __init__.py        (trivial export update, after 3)
5. pyproject.toml     (add numpy to deps)
6. test_extractors.py (depends on all above)
```

---

## File 1: `_preprocessing.py` (CREATE)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/extractors/_preprocessing.py`

### 1.1 Module Docstring and Imports

```python
"""Image preprocessing pipeline for OCR field extraction.

Implements the preprocessing steps from spec section 7.2:
deskew, CLAHE contrast enhancement, bilateral noise reduction,
adaptive thresholding, and field-type-specific pipelines.

Private module -- not exported from the extractors package.
"""
from __future__ import annotations

import logging
import math

import numpy as np
from PIL import Image, ImageFilter, ImageOps

from ingestkit_forms.models import FieldType

logger = logging.getLogger("ingestkit_forms")
```

### 1.2 `deskew(image: Image.Image, max_angle: float = 15.0) -> Image.Image`

Correct rotation up to +/-15 degrees using projection profile analysis on a binarized copy.

**Algorithm:**
1. Convert to grayscale, apply Otsu threshold (via `ImageOps.autocontrast` + threshold at 128).
2. Convert to numpy array.
3. For angles in `np.arange(-max_angle, max_angle + 0.5, 0.5)`:
   - Rotate array (using `scipy.ndimage.rotate` is too heavy; instead use Pillow `image.rotate(angle, expand=False, fillcolor=255)`).
   - Compute horizontal projection profile (sum of dark pixels per row).
   - Score = variance of projection profile (higher = more aligned).
4. Select angle with maximum score.
5. Rotate original image by the best angle, fill white.
6. Return corrected image.

**Edge cases:**
- If image is smaller than 20x20 px, return unchanged (too small to deskew).
- If best angle is < 0.5 degrees absolute, skip rotation (already aligned).

### 1.3 `enhance_contrast(image: Image.Image, clip_limit: float = 2.0, tile_size: int = 8) -> Image.Image`

CLAHE (Contrast Limited Adaptive Histogram Equalization) via numpy.

**Algorithm:**
1. Convert to grayscale if not already.
2. Convert to numpy array `(H, W)`.
3. Divide into `tile_size x tile_size` grid of tiles.
4. For each tile: compute histogram (256 bins), clip histogram at `clip_limit * (tile_pixels / 256)`, redistribute clipped pixels uniformly, compute CDF.
5. For each pixel: bilinear interpolation between the 4 nearest tile CDFs.
6. Convert back to PIL Image.

**Fallback:** If numpy operations fail for any reason, fall back to `ImageOps.autocontrast(image, cutoff=1)` and log a warning.

### 1.4 `reduce_noise(image: Image.Image) -> Image.Image`

Bilateral-like noise reduction preserving edges.

**Algorithm:**
1. Convert to grayscale numpy array.
2. Implement a simplified bilateral filter:
   - For each pixel, apply a weighted average over a 5x5 neighborhood.
   - Spatial weight: Gaussian with sigma_s=2.
   - Intensity weight: Gaussian with sigma_r=25.
3. Convert back to PIL Image.

**Fallback:** If the numpy bilateral is too slow (image > 4000x4000), fall back to `ImageFilter.MedianFilter(size=3)` and log a debug message.

**Performance note:** The bilateral filter is applied only to cropped field regions (typically 100-500px wide), not full pages. This keeps runtime well under the 2s per-field target.

### 1.5 `adaptive_threshold(image: Image.Image, block_size: int = 11, c_offset: int = 2) -> Image.Image`

Binarization via adaptive thresholding.

**Algorithm:**
1. Convert to grayscale numpy array.
2. For each pixel, compute the mean of a `block_size x block_size` neighborhood (use `np.lib.stride_tricks` or a convolution for efficiency).
3. Pixel is white (255) if `value > local_mean - c_offset`, else black (0).
4. Convert back to PIL Image (mode "1" or "L").

### 1.6 `preprocess_for_ocr(image: Image.Image, field_type: FieldType) -> Image.Image`

Orchestrate the full pipeline per field type (spec section 7.2 step 2c).

```python
def preprocess_for_ocr(image: Image.Image, field_type: FieldType) -> Image.Image:
    """Apply field-type-specific preprocessing pipeline.

    TEXT/NUMBER/DATE: deskew -> CLAHE contrast -> bilateral noise reduction -> binarize
    CHECKBOX/RADIO/SIGNATURE: adaptive_threshold only (binary analysis)
    """
    if field_type in (FieldType.TEXT, FieldType.NUMBER, FieldType.DATE):
        image = deskew(image)
        image = enhance_contrast(image)
        image = reduce_noise(image)
        image = adaptive_threshold(image)
    elif field_type in (FieldType.CHECKBOX, FieldType.RADIO, FieldType.SIGNATURE):
        image = adaptive_threshold(image)
    # DROPDOWN: no preprocessing (should not reach OCR overlay)
    return image
```

### 1.7 `compute_fill_ratio(image: Image.Image) -> float`

Dark pixel ratio for checkbox/radio detection (spec section 7.2 step 2e).

```python
def compute_fill_ratio(image: Image.Image) -> float:
    """Compute ratio of dark pixels to total pixels.

    Used for CHECKBOX and RADIO field type detection.
    Returns float in [0.0, 1.0].
    """
    gray = image.convert("L")
    arr = np.asarray(gray)
    # Threshold at 128: below = dark
    dark_pixels = np.sum(arr < 128)
    total_pixels = arr.size
    if total_pixels == 0:
        return 0.0
    return float(dark_pixels / total_pixels)
```

### 1.8 `compute_ink_ratio(image: Image.Image) -> float`

Ink ratio for signature detection (spec section 7.2 step 2f). Same implementation as `compute_fill_ratio` but with a separate function for semantic clarity and potential future divergence (e.g., connected component analysis for v2).

```python
def compute_ink_ratio(image: Image.Image) -> float:
    """Compute ratio of ink (dark) pixels to total pixels.

    Used for SIGNATURE field detection. Currently identical to
    compute_fill_ratio; separated for semantic clarity and future
    connected-component enhancements.
    """
    return compute_fill_ratio(image)
```

---

## File 2: `_rendering.py` (CREATE)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/extractors/_rendering.py`

### 2.1 Module Docstring and Imports

```python
"""Page rendering for OCR extraction: PDF and image loading.

Handles PDF-to-image rendering via PyMuPDF (optional) and direct image
loading via Pillow. Includes security checks per spec section 13.4.

Private module -- not exported from the extractors package.
"""
from __future__ import annotations

import logging
import os

from PIL import Image

from ingestkit_forms.errors import FormErrorCode, FormIngestError

logger = logging.getLogger("ingestkit_forms")

# Security constants (spec section 13.4)
MAX_IMAGE_DIMENSION = 10_000  # pixels
MAX_DECOMPRESSION_RATIO = 100
```

### 2.2 `validate_image_safety(file_path: str, max_dimension: int = MAX_IMAGE_DIMENSION) -> None`

Check decompression bomb and resolution limits before loading.

```python
def validate_image_safety(
    file_path: str,
    max_dimension: int = MAX_IMAGE_DIMENSION,
) -> None:
    """Validate image file safety before full loading.

    Checks:
    1. Resolution limit: width and height <= max_dimension (default 10000px).
    2. Decompression bomb: decompressed_size / compressed_size <= 100.

    Raises:
        FormIngestError with E_FORM_FILE_CORRUPT on violation.
    """
    compressed_size = os.path.getsize(file_path)
    if compressed_size == 0:
        raise FormIngestError(
            code=FormErrorCode.E_FORM_FILE_CORRUPT,
            message=f"File is empty: {file_path}",
            stage="rendering",
            recoverable=False,
        )

    # Use Pillow to read header only (no full decompression)
    with Image.open(file_path) as img:
        width, height = img.size
        if width > max_dimension or height > max_dimension:
            raise FormIngestError(
                code=FormErrorCode.E_FORM_FILE_CORRUPT,
                message=(
                    f"Image dimensions {width}x{height} exceed limit "
                    f"{max_dimension}x{max_dimension}."
                ),
                stage="rendering",
                recoverable=False,
            )
        # Estimate decompressed size: width * height * channels * bytes_per_channel
        channels = len(img.getbands())
        decompressed_estimate = width * height * channels
        if compressed_size > 0 and decompressed_estimate / compressed_size > MAX_DECOMPRESSION_RATIO:
            raise FormIngestError(
                code=FormErrorCode.E_FORM_FILE_CORRUPT,
                message=(
                    f"Decompression ratio {decompressed_estimate / compressed_size:.1f} "
                    f"exceeds limit {MAX_DECOMPRESSION_RATIO}. Possible decompression bomb."
                ),
                stage="rendering",
                recoverable=False,
            )
```

### 2.3 `load_image_file(file_path: str, max_dpi: int = 300) -> Image.Image`

Load an image file (JPEG, PNG, TIFF), validated for safety.

```python
def load_image_file(file_path: str, max_dpi: int = 300) -> Image.Image:
    """Load an image file and validate safety.

    Supported formats: JPEG, PNG, TIFF (spec section 3.1).
    Resizes if image resolution significantly exceeds target DPI.

    Returns:
        PIL Image in RGB mode.
    """
    validate_image_safety(file_path)
    img = Image.open(file_path)
    img.load()  # Force full load after validation
    if img.mode != "RGB":
        img = img.convert("RGB")
    return img
```

### 2.4 `render_pdf_page(file_path: str, page: int, dpi: int = 300) -> Image.Image`

Render a single PDF page to a PIL Image using PyMuPDF.

```python
def render_pdf_page(file_path: str, page: int, dpi: int = 300) -> Image.Image:
    """Render a PDF page to a PIL Image at the specified DPI.

    Requires PyMuPDF (fitz). Raises FormIngestError with
    E_FORM_UNSUPPORTED_FORMAT if PyMuPDF is not installed.

    Args:
        file_path: Path to the PDF file.
        page: 0-indexed page number.
        dpi: Target rendering resolution.

    Returns:
        PIL Image in RGB mode.
    """
    try:
        import fitz  # PyMuPDF
    except ImportError:
        raise FormIngestError(
            code=FormErrorCode.E_FORM_UNSUPPORTED_FORMAT,
            message=(
                "PyMuPDF is required for PDF page rendering. "
                "Install with: pip install 'ingestkit-forms[pdf]'"
            ),
            stage="rendering",
            recoverable=False,
        )

    doc = fitz.open(file_path)
    try:
        if page >= len(doc):
            raise FormIngestError(
                code=FormErrorCode.E_FORM_EXTRACTION_FAILED,
                message=f"Page {page} does not exist in PDF with {len(doc)} pages.",
                stage="rendering",
                page_number=page,
                recoverable=False,
            )
        pdf_page = doc[page]
        zoom = dpi / 72.0  # PDF default is 72 DPI
        mat = fitz.Matrix(zoom, zoom)
        pix = pdf_page.get_pixmap(matrix=mat)
        img = Image.frombytes("RGB", (pix.width, pix.height), pix.samples)
    finally:
        doc.close()

    # Validate rendered dimensions
    if img.width > MAX_IMAGE_DIMENSION or img.height > MAX_IMAGE_DIMENSION:
        raise FormIngestError(
            code=FormErrorCode.E_FORM_FILE_CORRUPT,
            message=(
                f"Rendered page dimensions {img.width}x{img.height} exceed limit "
                f"{MAX_IMAGE_DIMENSION}x{MAX_IMAGE_DIMENSION}. Reduce DPI."
            ),
            stage="rendering",
            page_number=page,
            recoverable=False,
        )

    return img
```

### 2.5 `get_page_image(file_path: str, page: int, dpi: int = 300) -> Image.Image`

Unified entry point: detects PDF vs image, dispatches to the correct loader.

```python
_IMAGE_EXTENSIONS = {".jpg", ".jpeg", ".png", ".tiff", ".tif"}
_PDF_EXTENSIONS = {".pdf"}

def get_page_image(file_path: str, page: int, dpi: int = 300) -> Image.Image:
    """Load a page image from a PDF or image file.

    For PDF files, renders the specified page at the target DPI.
    For image files, loads directly (page parameter must be 0).

    Args:
        file_path: Path to the document.
        page: 0-indexed page number.
        dpi: Target DPI for PDF rendering.

    Returns:
        PIL Image in RGB mode.
    """
    ext = os.path.splitext(file_path)[1].lower()

    if ext in _PDF_EXTENSIONS:
        return render_pdf_page(file_path, page, dpi)
    elif ext in _IMAGE_EXTENSIONS:
        if page != 0:
            raise FormIngestError(
                code=FormErrorCode.E_FORM_EXTRACTION_FAILED,
                message=f"Image files only have page 0, but page {page} was requested.",
                stage="rendering",
                page_number=page,
                recoverable=False,
            )
        return load_image_file(file_path, max_dpi=dpi)
    else:
        raise FormIngestError(
            code=FormErrorCode.E_FORM_UNSUPPORTED_FORMAT,
            message=f"Unsupported file extension '{ext}'. Expected PDF or image.",
            stage="rendering",
            recoverable=False,
        )
```

---

## File 3: `ocr_overlay.py` (MODIFY -- replace stub)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/extractors/ocr_overlay.py`

### 3.1 Module Docstring and Imports

```python
"""OCROverlayExtractor: render + template overlay + per-field OCR.

Renders PDF pages or processes scanned images, overlays the template
field regions, and runs OCR on each field's bounding box.
See spec section 7.2.
"""
from __future__ import annotations

import io
import logging
import re
import signal
import time
from typing import TYPE_CHECKING

from ingestkit_forms.errors import FormErrorCode, FormIngestError
from ingestkit_forms.extractors._preprocessing import (
    compute_fill_ratio,
    compute_ink_ratio,
    preprocess_for_ocr,
)
from ingestkit_forms.extractors._rendering import get_page_image
from ingestkit_forms.models import BoundingBox, ExtractedField, FieldType

if TYPE_CHECKING:
    from PIL import Image

    from ingestkit_forms.config import FormProcessorConfig
    from ingestkit_forms.models import FieldMapping, FormTemplate
    from ingestkit_forms.protocols import OCRBackend

logger = logging.getLogger("ingestkit_forms")
```

### 3.2 Private Helper: `_build_ocr_config`

```python
def _build_ocr_config(
    field_type: FieldType,
    engine_name: str,
    extraction_hint: str | None = None,
) -> str | None:
    """Build engine-specific OCR config string for a field type.

    Args:
        field_type: The field's data type.
        engine_name: OCR engine identifier ('tesseract' or 'paddleocr').
        extraction_hint: Optional hint from the field mapping.

    Returns:
        Engine-specific config string, or None for default config.
    """
    if engine_name == "tesseract":
        if field_type == FieldType.NUMBER:
            return "--psm 7 -c tessedit_char_whitelist=0123456789.-"
        elif field_type in (FieldType.TEXT, FieldType.DATE):
            return "--psm 7"
        return None
    elif engine_name == "paddleocr":
        # PaddleOCR config handled via its API, not CLI strings
        if field_type == FieldType.NUMBER:
            return "rec_char_type=EN"
        return None
    return None
```

### 3.3 Private Helper: `_regex_match_with_timeout`

ReDoS protection per spec section 13.5.

```python
_REGEX_TIMEOUT_SECONDS = 1.0

def _regex_match_with_timeout(
    pattern: str,
    value: str,
    timeout: float = _REGEX_TIMEOUT_SECONDS,
) -> bool | None:
    """Match a regex pattern with timeout protection against ReDoS.

    Returns:
        True if matches, False if no match, None if timeout.
    """
    import threading

    result: list[bool] = []

    def _match() -> None:
        try:
            result.append(bool(re.match(pattern, value)))
        except re.error:
            result.append(False)

    thread = threading.Thread(target=_match, daemon=True)
    thread.start()
    thread.join(timeout=timeout)

    if not result:
        # Timeout occurred
        return None
    return result[0]
```

### 3.4 Private Helper: `_crop_field_region`

```python
def _crop_field_region(
    page_image: Image.Image,
    region: BoundingBox,
) -> Image.Image:
    """Crop a field region from a page image using normalized bbox.

    Converts normalized (0.0-1.0) coordinates to pixel coordinates
    and crops the region.

    Spec section 7.2 step 2a:
        px_x = region.x * page_width_px
        px_y = region.y * page_height_px
        px_w = region.width * page_width_px
        px_h = region.height * page_height_px
    """
    page_w, page_h = page_image.size
    px_x = int(region.x * page_w)
    px_y = int(region.y * page_h)
    px_w = int(region.width * page_w)
    px_h = int(region.height * page_h)

    # Clamp to image bounds
    px_x = max(0, min(px_x, page_w - 1))
    px_y = max(0, min(px_y, page_h - 1))
    right = min(px_x + px_w, page_w)
    bottom = min(px_y + px_h, page_h)

    return page_image.crop((px_x, px_y, right, bottom))
```

### 3.5 Private Helper: `_image_to_png_bytes`

```python
def _image_to_png_bytes(image: Image.Image) -> bytes:
    """Convert PIL Image to PNG-encoded bytes for OCR backend."""
    buf = io.BytesIO()
    image.save(buf, format="PNG")
    return buf.getvalue()
```

### 3.6 Private Helper: `_post_process_value`

```python
def _post_process_value(
    raw_text: str,
    field_type: FieldType,
    extraction_hint: str | None = None,
) -> str:
    """Post-process raw OCR text per field type.

    - TEXT: strip whitespace
    - NUMBER: strip non-numeric chars (keep digits, '.', '-', ',')
    - DATE: strip whitespace, apply date hint if present
    """
    text = raw_text.strip()
    if field_type == FieldType.NUMBER:
        # Keep only digits, decimal point, minus, comma
        text = re.sub(r"[^\d.\-,]", "", text)
    elif field_type == FieldType.DATE:
        # Strip extra whitespace; date formatting left to caller
        text = " ".join(text.split())
    return text
```

### 3.7 `OCROverlayExtractor` Class

```python
class OCROverlayExtractor:
    """Extract field values by rendering document pages and OCR-ing each field region.

    Per spec section 7.2. All OCR access is via the OCRBackend protocol.
    """

    def __init__(
        self,
        ocr_backend: OCRBackend,
        config: FormProcessorConfig,
    ) -> None:
        self._ocr = ocr_backend
        self._config = config

    def extract(
        self,
        file_path: str,
        template: FormTemplate,
    ) -> list[ExtractedField]:
        """Extract all field values from a document using OCR overlay.

        Groups template fields by page_number, renders each page once,
        then processes each field on that page.

        Args:
            file_path: Path to the PDF or image file.
            template: Form template with field mappings.

        Returns:
            List of ExtractedField objects, one per template field.

        Raises:
            FormIngestError: If the entire extraction fails (e.g., file unreadable).
        """
        results: list[ExtractedField] = []

        # Group fields by page number
        fields_by_page: dict[int, list[FieldMapping]] = {}
        for field in template.fields:
            fields_by_page.setdefault(field.page_number, []).append(field)

        for page_num in sorted(fields_by_page.keys()):
            page_fields = fields_by_page[page_num]

            # Render page image (once per page for efficiency)
            try:
                page_image = get_page_image(
                    file_path, page_num, dpi=self._config.form_ocr_dpi
                )
            except FormIngestError:
                # Page rendering failed -- skip all fields on this page
                logger.warning(
                    "Page %d rendering failed for %s, skipping %d fields",
                    page_num, file_path, len(page_fields),
                )
                for field in page_fields:
                    results.append(self._failed_field(
                        field, FormErrorCode.E_FORM_EXTRACTION_FAILED,
                        f"Page {page_num} rendering failed",
                    ))
                continue

            # Process each field on this page
            for field in page_fields:
                extracted = self._extract_single_field(page_image, field)
                results.append(extracted)

            # Release page image memory after processing all fields
            del page_image

        return results
```

### 3.8 `_extract_single_field` Method

```python
    def _extract_single_field(
        self,
        page_image: Image.Image,
        field: FieldMapping,
    ) -> ExtractedField:
        """Extract a single field from a page image.

        Dispatches to field-type-specific logic: OCR for text types,
        fill/ink ratio for visual types.
        """
        warnings: list[str] = []

        if field.region is None:
            return self._failed_field(
                field, FormErrorCode.E_FORM_EXTRACTION_FAILED,
                "Field has no bounding box region",
            )

        # Crop field region
        crop = _crop_field_region(page_image, field.region)

        try:
            if field.field_type in (FieldType.TEXT, FieldType.NUMBER, FieldType.DATE):
                value, confidence, raw_value = self._extract_text_field(crop, field)
            elif field.field_type in (FieldType.CHECKBOX, FieldType.RADIO):
                value, confidence, raw_value = self._extract_checkbox_field(crop)
            elif field.field_type == FieldType.SIGNATURE:
                value, confidence, raw_value = self._extract_signature_field(crop)
            else:
                # DROPDOWN or unknown -- fail closed
                return self._failed_field(
                    field, FormErrorCode.E_FORM_OCR_FAILED,
                    f"Unsupported field type for OCR: {field.field_type.value}",
                )
        except FormIngestError as e:
            logger.warning(
                "Field '%s' extraction failed: %s", field.field_name, e.message
            )
            return self._failed_field(field, e.code, e.message)
        except Exception as e:
            logger.warning(
                "Field '%s' extraction error: %s", field.field_name, str(e)
            )
            return self._failed_field(
                field, FormErrorCode.E_FORM_OCR_FAILED, str(e),
            )

        # Apply min confidence threshold
        if confidence < self._config.form_extraction_min_field_confidence:
            warnings.append(FormErrorCode.W_FORM_FIELD_LOW_CONFIDENCE.value)

        # Apply validation pattern (spec section 7.2 step 3)
        validation_passed: bool | None = None
        if field.validation_pattern and value is not None and isinstance(value, str):
            match_result = _regex_match_with_timeout(field.validation_pattern, value)
            if match_result is None:
                # Regex timed out (ReDoS protection)
                warnings.append(FormErrorCode.W_FORM_FIELD_VALIDATION_FAILED.value)
                validation_passed = False
                value = None
                confidence = 0.0
            elif match_result:
                validation_passed = True
            else:
                validation_passed = False
                warnings.append(FormErrorCode.W_FORM_FIELD_VALIDATION_FAILED.value)
                value = None
                confidence = 0.0

        # PII-safe logging
        if self._config.log_ocr_output and value is not None:
            logger.debug("OCR result for field '%s': %s", field.field_name, value)

        return ExtractedField(
            field_id=field.field_id,
            field_name=field.field_name,
            field_label=field.field_label,
            field_type=field.field_type,
            value=value,
            raw_value=raw_value,
            confidence=confidence,
            extraction_method="ocr_overlay",
            bounding_box=field.region,
            validation_passed=validation_passed,
            warnings=warnings,
        )
```

### 3.9 `_extract_text_field` Method

```python
    def _extract_text_field(
        self,
        crop: Image.Image,
        field: FieldMapping,
    ) -> tuple[str | None, float, str | None]:
        """Extract a text-based field (TEXT, NUMBER, DATE) via OCR.

        Returns:
            (processed_value, confidence, raw_value)
        """
        preprocessed = preprocess_for_ocr(crop, field.field_type)
        image_bytes = _image_to_png_bytes(preprocessed)

        ocr_config = _build_ocr_config(
            field.field_type,
            self._ocr.engine_name(),
            field.extraction_hint,
        )

        try:
            result = self._ocr.ocr_region(
                image_bytes=image_bytes,
                language=self._config.form_ocr_language,
                config=ocr_config,
                timeout=float(self._config.form_ocr_per_field_timeout_seconds),
            )
        except TimeoutError:
            logger.warning(
                "OCR timeout for field '%s' after %ds",
                field.field_name,
                self._config.form_ocr_per_field_timeout_seconds,
            )
            return None, 0.0, None
        except Exception as e:
            raise FormIngestError(
                code=FormErrorCode.E_FORM_OCR_FAILED,
                message=f"OCR failed for field '{field.field_name}': {e}",
                stage="ocr_overlay",
                field_name=field.field_name,
                recoverable=True,
            ) from e

        raw_text = result.text
        processed = _post_process_value(raw_text, field.field_type, field.extraction_hint)

        # Confidence = mean of char_confidences (spec section 7.2 step 2d)
        if result.char_confidences:
            confidence = sum(result.char_confidences) / len(result.char_confidences)
        else:
            confidence = result.confidence

        if not processed:
            return None, 0.0, raw_text

        return processed, confidence, raw_text
```

### 3.10 `_extract_checkbox_field` Method

```python
    def _extract_checkbox_field(
        self,
        crop: Image.Image,
    ) -> tuple[bool, float, str | None]:
        """Extract a CHECKBOX or RADIO field via fill ratio analysis.

        Spec section 7.2 step 2e:
            fill_ratio > checkbox_fill_threshold -> checked
            confidence = min(abs(fill_ratio - threshold) / threshold, 1.0)
        """
        preprocessed = preprocess_for_ocr(crop, FieldType.CHECKBOX)
        fill_ratio = compute_fill_ratio(preprocessed)
        threshold = self._config.checkbox_fill_threshold

        checked = fill_ratio > threshold
        confidence = min(abs(fill_ratio - threshold) / threshold, 1.0) if threshold > 0 else 1.0

        return checked, confidence, f"fill_ratio={fill_ratio:.4f}"
```

### 3.11 `_extract_signature_field` Method

```python
    def _extract_signature_field(
        self,
        crop: Image.Image,
    ) -> tuple[bool, float, str | None]:
        """Extract a SIGNATURE field via ink ratio analysis.

        Spec section 7.2 step 2f:
            ink_ratio > signature_ink_threshold -> signed
            confidence = min(abs(ink_ratio - threshold) / threshold, 1.0)
        """
        preprocessed = preprocess_for_ocr(crop, FieldType.SIGNATURE)
        ink_ratio = compute_ink_ratio(preprocessed)
        threshold = self._config.signature_ink_threshold

        signed = ink_ratio > threshold
        confidence = min(abs(ink_ratio - threshold) / threshold, 1.0) if threshold > 0 else 1.0

        return signed, confidence, f"ink_ratio={ink_ratio:.4f}"
```

### 3.12 `_failed_field` Helper Method

```python
    def _failed_field(
        self,
        field: FieldMapping,
        error_code: FormErrorCode,
        message: str,
    ) -> ExtractedField:
        """Create a fail-closed ExtractedField with value=None, confidence=0.0."""
        return ExtractedField(
            field_id=field.field_id,
            field_name=field.field_name,
            field_label=field.field_label,
            field_type=field.field_type,
            value=None,
            raw_value=None,
            confidence=0.0,
            extraction_method="ocr_overlay",
            bounding_box=field.region,
            validation_passed=None,
            warnings=[error_code.value, message],
        )
```

---

## File 4: `extractors/__init__.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/extractors/__init__.py`

Add `OCROverlayExtractor` to exports:

```python
"""Form field extractors.

Subpackage containing extraction backends:
- native_pdf: PyMuPDF-based form widget extraction
- ocr_overlay: Template overlay + per-field OCR extraction
- excel_cell: openpyxl cell value mapping extraction
"""

from ingestkit_forms.extractors.ocr_overlay import OCROverlayExtractor

__all__ = ["OCROverlayExtractor"]
```

---

## File 5: `pyproject.toml` (MODIFY)

**Full path:** `packages/ingestkit-forms/pyproject.toml`

Add `numpy>=1.24` to the `dependencies` list (already a transitive dep of Pillow and all OCR backends, but needs to be explicit for the preprocessing module):

```toml
dependencies = [
    "ingestkit-core>=0.1.0",
    "pydantic>=2.0",
    "openpyxl>=3.1",
    "Pillow>=10.0",
    "numpy>=1.24",
]
```

---

## File 6: `test_extractors.py` (MODIFY -- replace stub)

**Full path:** `packages/ingestkit-forms/tests/test_extractors.py`

### 6.1 Test Infrastructure

```python
"""Tests for form field extractors â€” OCR overlay extraction.

All tests use synthetic PIL images and a mock OCRBackend.
No external services required.
"""
import io
import re
from unittest.mock import MagicMock, patch

import numpy as np
import pytest
from PIL import Image

from ingestkit_forms.config import FormProcessorConfig
from ingestkit_forms.extractors._preprocessing import (
    adaptive_threshold,
    compute_fill_ratio,
    compute_ink_ratio,
    deskew,
    enhance_contrast,
    preprocess_for_ocr,
    reduce_noise,
)
from ingestkit_forms.extractors._rendering import (
    get_page_image,
    load_image_file,
    validate_image_safety,
)
from ingestkit_forms.extractors.ocr_overlay import (
    OCROverlayExtractor,
    _build_ocr_config,
    _crop_field_region,
    _post_process_value,
    _regex_match_with_timeout,
)
from ingestkit_forms.models import (
    BoundingBox,
    FieldMapping,
    FieldType,
    FormTemplate,
    SourceFormat,
)
from ingestkit_forms.protocols import OCRRegionResult
```

### 6.2 Fixtures

```python
@pytest.fixture
def mock_ocr_backend():
    """Create a mock OCRBackend."""
    backend = MagicMock()
    backend.engine_name.return_value = "tesseract"
    backend.ocr_region.return_value = OCRRegionResult(
        text="Sample Text",
        confidence=0.92,
        char_confidences=[0.9, 0.95, 0.88, 0.93, 0.94, 0.9, 0.91, 0.92, 0.95, 0.93, 0.89],
        engine="tesseract",
    )
    return backend

@pytest.fixture
def config():
    """Create a default FormProcessorConfig."""
    return FormProcessorConfig()

@pytest.fixture
def simple_template():
    """Create a single-page template with one text field."""
    return FormTemplate(
        name="Test Form",
        source_format=SourceFormat.PDF,
        page_count=1,
        fields=[
            FieldMapping(
                field_name="name",
                field_label="Full Name",
                field_type=FieldType.TEXT,
                page_number=0,
                region=BoundingBox(x=0.1, y=0.2, width=0.3, height=0.05),
            ),
        ],
    )

def _make_white_image(width=200, height=50):
    """Create an all-white test image."""
    return Image.new("RGB", (width, height), color=(255, 255, 255))

def _make_black_image(width=200, height=50):
    """Create an all-black test image."""
    return Image.new("RGB", (width, height), color=(0, 0, 0))

def _make_half_filled_image(width=200, height=50):
    """Create image with top half black, bottom half white."""
    img = Image.new("L", (width, height), 255)
    arr = np.array(img)
    arr[: height // 2, :] = 0
    return Image.fromarray(arr)

def _save_image_to_tmp(img, tmp_path, name="test.png"):
    """Save a PIL image to a temp file and return the path."""
    path = tmp_path / name
    img.save(str(path))
    return str(path)
```

### 6.3 Preprocessing Tests (12 tests)

| Test Function | Description | Key Assertion |
|---|---|---|
| `test_deskew_returns_image` | Deskew a straight image returns same-size image | Output size matches input |
| `test_deskew_small_image_unchanged` | Image < 20x20 is returned unchanged | Pixel data identical |
| `test_enhance_contrast_increases_range` | Low-contrast image -> wider histogram | Max-min pixel range increases |
| `test_enhance_contrast_fallback_on_error` | Force numpy error -> autocontrast fallback | Returns a valid image, no exception |
| `test_reduce_noise_preserves_size` | Output has same dimensions as input | Width/height match |
| `test_adaptive_threshold_produces_binary` | Grayscale input -> binary output | Only 0 and 255 values in output |
| `test_preprocess_for_ocr_text_pipeline` | TEXT field goes through full 4-step pipeline | Returns an image (smoke test) |
| `test_preprocess_for_ocr_checkbox_pipeline` | CHECKBOX field gets threshold only | Returns a binary image |
| `test_compute_fill_ratio_empty_region` | All-white image -> ratio near 0.0 | `ratio < 0.01` |
| `test_compute_fill_ratio_filled_region` | All-black image -> ratio near 1.0 | `ratio > 0.99` |
| `test_compute_fill_ratio_partial` | Half-filled image -> ratio ~0.5 | `0.45 < ratio < 0.55` |
| `test_compute_ink_ratio_delegates` | `compute_ink_ratio` returns same as `compute_fill_ratio` | Values match |

### 6.4 Rendering Tests (6 tests)

| Test Function | Description | Key Assertion |
|---|---|---|
| `test_load_image_file_jpeg` | Load a valid JPEG from tmp_path | Returns RGB PIL Image |
| `test_load_image_file_rejects_oversized` | Image > 10000px -> `FormIngestError` | Error code = `E_FORM_FILE_CORRUPT` |
| `test_validate_image_safety_empty_file` | 0-byte file -> `FormIngestError` | Error code = `E_FORM_FILE_CORRUPT` |
| `test_render_pdf_page_import_error` | Mock `fitz` import failure -> `FormIngestError` | Error code = `E_FORM_UNSUPPORTED_FORMAT` |
| `test_get_page_image_unsupported_ext` | `.docx` file -> `FormIngestError` | Error code = `E_FORM_UNSUPPORTED_FORMAT` |
| `test_get_page_image_image_nonzero_page` | Image with page=1 -> `FormIngestError` | Error code = `E_FORM_EXTRACTION_FAILED` |

### 6.5 OCROverlayExtractor Tests (19 tests)

All tests mock `get_page_image` to return a synthetic PIL image (avoid needing real PDF/image files).

| Test Function | Description | Key Assertion |
|---|---|---|
| `test_extract_text_field` | Mock OCR returns text, verify ExtractedField | `value == "Sample Text"`, `extraction_method == "ocr_overlay"` |
| `test_extract_number_field_strips_nonnumeric` | OCR returns "12.34 USD" | `value == "12.34"` |
| `test_extract_date_field` | OCR returns "02/15/2026" | `value == "02/15/2026"` |
| `test_extract_checkbox_checked` | Provide mostly-black crop (fill > 0.3) | `value == True` |
| `test_extract_checkbox_unchecked` | Provide all-white crop (fill < 0.3) | `value == False` |
| `test_extract_checkbox_confidence_at_threshold` | fill_ratio = exactly 0.3 | `value == False` (not strictly >), `confidence == 0.0` |
| `test_extract_checkbox_confidence_calculation` | fill_ratio = 0.6 -> `abs(0.6-0.3)/0.3 = 1.0` | `confidence == 1.0` |
| `test_extract_signature_signed` | Provide crop with ink_ratio > 0.05 | `value == True` |
| `test_extract_signature_blank` | All-white crop, ink_ratio < 0.05 | `value == False` |
| `test_validation_pattern_pass` | Pattern `r"^\d{3}-\d{4}$"`, value "123-4567" | `validation_passed == True`, value kept |
| `test_validation_pattern_fail` | Pattern `r"^\d{3}$"`, value "abc" | `validation_passed == False`, `value == None`, `confidence == 0.0` |
| `test_validation_pattern_redos_timeout` | Malicious ReDoS pattern -> timeout | `validation_passed == False`, `value == None` |
| `test_per_field_timeout_passed_to_backend` | Verify `timeout` kwarg propagated | `mock_ocr.ocr_region.assert_called_with(..., timeout=10.0)` |
| `test_ocr_timeout_returns_none_value` | Backend raises `TimeoutError` | `value == None`, `confidence == 0.0` |
| `test_ocr_failure_continues_to_next_field` | First field raises, second succeeds | `len(results) == 2`, first has error, second has value |
| `test_multi_page_extraction` | Template with fields on pages 0 and 1 | `get_page_image` called twice (once per page) |
| `test_bbox_to_pixel_conversion` | 1000x800 image, bbox(0.1, 0.2, 0.3, 0.05) | Crop box = (100, 160, 400, 200) |
| `test_field_without_region_fails_closed` | Field with `region=None` (Excel field) | `value == None`, error warning present |
| `test_page_render_failure_skips_page_fields` | `get_page_image` raises for page 1 | All page-1 fields have `value == None` and error warning |

### 6.6 Security Tests (3 tests)

| Test Function | Description | Key Assertion |
|---|---|---|
| `test_decompression_bomb_rejected` | Create a high-ratio compressed image (mock) | `FormIngestError` with `E_FORM_FILE_CORRUPT` |
| `test_resolution_guardrail` | Image 10001x100 -> rejected | `FormIngestError` with `E_FORM_FILE_CORRUPT` |
| `test_regex_timeout_protection` | ReDoS pattern `(a+)+$` with "aaa...!" | Returns `None` (timeout) within 2s |

### 6.7 PII Safety Tests (2 tests)

| Test Function | Description | Key Assertion |
|---|---|---|
| `test_no_raw_ocr_in_logs_by_default` | `log_ocr_output=False`, capture logs | No OCR text in log output |
| `test_raw_ocr_logged_when_enabled` | `log_ocr_output=True`, capture logs | OCR text appears in log output |

### 6.8 Helper Function Tests (4 tests)

| Test Function | Description | Key Assertion |
|---|---|---|
| `test_build_ocr_config_tesseract_number` | Tesseract + NUMBER | Returns `"--psm 7 -c tessedit_char_whitelist=0123456789.-"` |
| `test_build_ocr_config_tesseract_text` | Tesseract + TEXT | Returns `"--psm 7"` |
| `test_build_ocr_config_paddleocr_number` | PaddleOCR + NUMBER | Returns `"rec_char_type=EN"` |
| `test_post_process_number_strips_text` | Input "$ 1,234.56 USD" | Output `"1,234.56"` |

### 6.9 Test Markers

All tests marked `@pytest.mark.unit`. No `@pytest.mark.integration` tests (all use mocks).

**Total test count: 46 tests.**

---

## Acceptance Criteria

- [ ] `OCROverlayExtractor` accepts `OCRBackend` protocol, never imports a concrete OCR engine
- [ ] All image operations use Pillow + numpy; no OpenCV dependency
- [ ] PyMuPDF import is lazy (`import fitz` inside `render_pdf_page`), handles `ImportError`
- [ ] Per-field timeout propagated to `ocr_backend.ocr_region(timeout=...)`
- [ ] Checkbox: `fill_ratio > config.checkbox_fill_threshold` -> `True`
- [ ] Signature: `ink_ratio > config.signature_ink_threshold` -> `True`
- [ ] Confidence for checkbox/signature: `min(abs(ratio - threshold) / threshold, 1.0)`
- [ ] Text field confidence: mean of `char_confidences` from OCR result
- [ ] Validation pattern failure: `value=None`, `confidence=0.0`, `W_FORM_FIELD_VALIDATION_FAILED`
- [ ] No raw OCR text in logs when `log_ocr_output=False`
- [ ] Security: decompression bomb check, resolution limit 10000px
- [ ] ReDoS protection: regex matching with 1s thread-based timeout
- [ ] All unit tests use mock `OCRBackend`, no external services
- [ ] Tests marked with `@pytest.mark.unit`
- [ ] `numpy>=1.24` added to `pyproject.toml` dependencies
- [ ] `OCROverlayExtractor` exported from `extractors/__init__.py`
- [ ] Page images released after processing all fields on that page (memory management)
- [ ] Fail-closed: any extraction failure returns `ExtractedField(value=None, confidence=0.0)`

---

## Verification Gates (for PROVE)

```bash
# All unit tests pass
pytest packages/ingestkit-forms/tests/test_extractors.py -v -m unit

# No regressions in existing tests
pytest packages/ingestkit-forms/tests/ -v

# Import check
python -c "from ingestkit_forms.extractors import OCROverlayExtractor; print('OK')"

# Type check (if mypy is configured)
# mypy packages/ingestkit-forms/src/ingestkit_forms/extractors/
```

AGENT_RETURN: .agents/outputs/plan-64-021526.md
