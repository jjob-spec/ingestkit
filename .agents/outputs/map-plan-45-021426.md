# MAP-PLAN: Issue #45 -- Implement async wrapper aprocess()

**Issue:** #45 -- Implement async wrapper `aprocess()`
**SPEC Section:** 18.2
**Complexity:** SIMPLE
**Date:** 2026-02-14

---

## INVESTIGATION FINDINGS

### 1. PDFRouter class location and process() signature

**File:** `packages/ingestkit-pdf/src/ingestkit_pdf/router.py`

- `PDFRouter` class defined at line 72
- `process()` method at line 147, signature:
  ```python
  def process(
      self,
      file_path: str,
      source_uri: str | None = None,
  ) -> ProcessingResult:
  ```
- Returns `ProcessingResult` (imported from `ingestkit_pdf.models`)
- The method is synchronous, runs the full 15-step pipeline (security scan, ingest key, PyMuPDF open, classification, routing to processor, error merge, logging, return)
- No existing async methods on the class
- No `asyncio` import currently in the file

### 2. SPEC section 18.2 requirements

From `packages/ingestkit-pdf/SPEC.md` lines 1501-1518:

- `aprocess()` wraps `process()` via `asyncio.to_thread()`
- Sync `process()` remains the canonical implementation -- `aprocess()` is a thin wrapper
- No async backends required; async is for caller integration (FastAPI, async job queues)
- `process()` remains available and supported indefinitely, NOT deprecated
- Test requirement (R-EXE-1): `test_router::test_aprocess_matches_process`

### 3. Test file patterns

**File:** `packages/ingestkit-pdf/tests/test_router.py`

- Uses `pytest` with `@pytest.mark.unit` class decorators
- Test classes organized by feature: `TestCanHandle`, `TestClassify`, `TestLLMOutageResilience`, `TestSecurityScan`, `TestDocumentProfiling`, `TestProcessFlow`, `TestIngestKey`, `TestProcessBatch`, `TestCreateDefaultRouter`, `TestLogging`
- Fixtures come from `conftest.py`: `pdf_router` fixture creates `PDFRouter` with mock backends
- Heavy use of `unittest.mock.patch` and `patch.object` to mock internal components
- `_make_processing_result()` helper builds `ProcessingResult` with sensible defaults
- No existing async tests in the file
- No `pytest-asyncio` usage yet

### 4. Package exports

**File:** `packages/ingestkit-pdf/src/ingestkit_pdf/__init__.py`

- `PDFRouter` is exported in `__all__`
- No changes needed to `__init__.py` (the method is on the class, not a standalone export)

### 5. Dependencies check

- `asyncio` is part of the Python standard library (3.10+), no new dependency needed
- `asyncio.to_thread()` available since Python 3.9, project requires Python >= 3.10
- `pytest-asyncio` will be needed for the async test -- need to verify if it's already a dev dependency

---

## IMPLEMENTATION PLAN

### File 1: `packages/ingestkit-pdf/src/ingestkit_pdf/router.py`

**Change type:** Add method

**Location:** After the `process()` method (after line 423, before `process_batch()`), within the `# Public API` section.

**Add import** at top of file (line 18 area, with other stdlib imports):
```python
import asyncio
```

**Add method** (insert between `process()` and `process_batch()`):
```python
async def aprocess(
    self,
    file_path: str,
    source_uri: str | None = None,
) -> ProcessingResult:
    """Async wrapper around :meth:`process`.

    Offloads the synchronous ``process()`` call to a thread via
    ``asyncio.to_thread()`` so that callers using async frameworks
    (FastAPI, aiohttp) can ``await`` ingestion without blocking the
    event loop.

    The result is identical to calling ``process()`` directly.
    See SPEC section 18.2.

    Parameters
    ----------
    file_path:
        Filesystem path to the PDF file.
    source_uri:
        Optional override for the source URI stored in the ingest key.

    Returns
    -------
    ProcessingResult
        The fully-assembled result (identical to sync ``process()``).
    """
    return await asyncio.to_thread(self.process, file_path, source_uri)
```

**Rationale:**
- Thin wrapper per SPEC 18.2 -- delegates entirely to `process()`
- `asyncio.to_thread()` runs the sync function in a default executor thread, preventing event loop blocking
- Same parameters and return type as `process()`
- Positional argument passing to `to_thread()` is correct since `file_path` and `source_uri` are the only params

**Update docstring** of `PDFRouter` class (line 77-79) to mention `aprocess`:
```python
    the public API.
```
Change to:
```python
    the public API.  An async variant :meth:`aprocess` wraps ``process()``
    via ``asyncio.to_thread()`` for use in async frameworks.
```

### File 2: `packages/ingestkit-pdf/tests/test_router.py`

**Change type:** Add test class

**Location:** After `TestProcessBatch` class (after line 1146), before `TestCreateDefaultRouter`.

**Add import** at top of file:
```python
import asyncio
```

**Add test class:**
```python
# ---------------------------------------------------------------------------
# TestAprocess
# ---------------------------------------------------------------------------


@pytest.mark.unit
class TestAprocess:
    """Tests for the async aprocess() wrapper (SPEC 18.2, R-EXE-1)."""

    @pytest.mark.asyncio
    async def test_aprocess_returns_processing_result(
        self, pdf_router: PDFRouter,
    ) -> None:
        """aprocess() should return a ProcessingResult."""
        expected_result = _make_processing_result()

        with (
            patch.object(
                pdf_router._security_scanner, "scan",
                return_value=(_make_security_metadata(), []),
            ),
            patch("ingestkit_pdf.router.compute_ingest_key", return_value=_make_ingest_key_obj()),
            patch("ingestkit_pdf.router.fitz.open") as mock_fitz_open,
            patch.object(
                pdf_router, "_build_document_profile",
                return_value=_make_document_profile(),
            ),
            patch.object(
                pdf_router._inspector, "classify",
                return_value=ClassificationResult(
                    pdf_type=PDFType.TEXT_NATIVE,
                    confidence=0.9,
                    tier_used=ClassificationTier.RULE_BASED,
                    reasoning="OK.",
                    per_page_types={1: PageType.TEXT},
                ),
            ),
            patch.object(
                pdf_router._text_extractor, "process",
                return_value=expected_result,
            ),
        ):
            mock_fitz_open.return_value = _make_mock_doc()
            result = await pdf_router.aprocess("/tmp/test.pdf")

        assert isinstance(result, ProcessingResult)
        assert result.chunks_created == 5

    @pytest.mark.asyncio
    async def test_aprocess_matches_process(
        self, pdf_router: PDFRouter,
    ) -> None:
        """aprocess() output must be identical to process() output (R-EXE-1)."""
        expected_result = _make_processing_result()

        def run_process():
            with (
                patch.object(
                    pdf_router._security_scanner, "scan",
                    return_value=(_make_security_metadata(), []),
                ),
                patch("ingestkit_pdf.router.compute_ingest_key", return_value=_make_ingest_key_obj()),
                patch("ingestkit_pdf.router.fitz.open") as mock_fitz_open,
                patch.object(
                    pdf_router, "_build_document_profile",
                    return_value=_make_document_profile(),
                ),
                patch.object(
                    pdf_router._inspector, "classify",
                    return_value=ClassificationResult(
                        pdf_type=PDFType.TEXT_NATIVE,
                        confidence=0.9,
                        tier_used=ClassificationTier.RULE_BASED,
                        reasoning="OK.",
                        per_page_types={1: PageType.TEXT},
                    ),
                ),
                patch.object(
                    pdf_router._text_extractor, "process",
                    return_value=expected_result,
                ),
            ):
                mock_fitz_open.return_value = _make_mock_doc()
                return pdf_router.process("/tmp/test.pdf")

        # Get sync result
        sync_result = run_process()

        # Get async result with same mocking
        with (
            patch.object(
                pdf_router._security_scanner, "scan",
                return_value=(_make_security_metadata(), []),
            ),
            patch("ingestkit_pdf.router.compute_ingest_key", return_value=_make_ingest_key_obj()),
            patch("ingestkit_pdf.router.fitz.open") as mock_fitz_open,
            patch.object(
                pdf_router, "_build_document_profile",
                return_value=_make_document_profile(),
            ),
            patch.object(
                pdf_router._inspector, "classify",
                return_value=ClassificationResult(
                    pdf_type=PDFType.TEXT_NATIVE,
                    confidence=0.9,
                    tier_used=ClassificationTier.RULE_BASED,
                    reasoning="OK.",
                    per_page_types={1: PageType.TEXT},
                ),
            ),
            patch.object(
                pdf_router._text_extractor, "process",
                return_value=expected_result,
            ),
        ):
            mock_fitz_open.return_value = _make_mock_doc()
            async_result = await pdf_router.aprocess("/tmp/test.pdf")

        # Core fields must match (processing_time_seconds may differ slightly)
        assert async_result.file_path == sync_result.file_path
        assert async_result.ingest_key == sync_result.ingest_key
        assert async_result.chunks_created == sync_result.chunks_created
        assert async_result.tables_created == sync_result.tables_created
        assert async_result.errors == sync_result.errors
        assert async_result.warnings == sync_result.warnings

    @pytest.mark.asyncio
    async def test_aprocess_propagates_source_uri(
        self, pdf_router: PDFRouter,
    ) -> None:
        """source_uri should be forwarded to process()."""
        expected_result = _make_processing_result()

        with (
            patch.object(
                pdf_router, "process",
                return_value=expected_result,
            ) as process_mock,
        ):
            await pdf_router.aprocess("/tmp/test.pdf", source_uri="s3://bucket/test.pdf")

        process_mock.assert_called_once_with("/tmp/test.pdf", "s3://bucket/test.pdf")
```

**Note on test approach for `test_aprocess_matches_process`:** An alternative simpler approach is to mock `process()` directly and verify `aprocess()` calls it with the same args and returns the same result. This is actually cleaner and avoids duplication. The `test_aprocess_propagates_source_uri` test already does this pattern. The implementer may choose to simplify `test_aprocess_matches_process` to:

```python
@pytest.mark.asyncio
async def test_aprocess_matches_process(
    self, pdf_router: PDFRouter,
) -> None:
    """aprocess() delegates to process() and returns identical result."""
    expected_result = _make_processing_result()

    with patch.object(
        pdf_router, "process",
        return_value=expected_result,
    ) as process_mock:
        result = await pdf_router.aprocess("/tmp/test.pdf")

    process_mock.assert_called_once_with("/tmp/test.pdf", None)
    assert result is expected_result
```

This simpler version is preferred since it directly tests the wrapper contract without reimplementing process() mocking.

### File 3: `packages/ingestkit-pdf/pyproject.toml` (conditional)

**Check:** Verify if `pytest-asyncio` is already in dev dependencies. If not, add it.

```toml
# Under [project.optional-dependencies] dev section, add:
"pytest-asyncio>=0.23",
```

---

## RISK ASSESSMENT

| Risk | Likelihood | Mitigation |
|------|-----------|------------|
| `pytest-asyncio` not installed | Medium | Add to dev dependencies in pyproject.toml |
| `asyncio.to_thread` not available | None | Python >= 3.10 required, available since 3.9 |
| Thread safety of `process()` | Low | `process()` is already designed for process isolation in batch mode; thread isolation is less strict but mocks/backends are instance-level |

## ESTIMATED EFFORT

- Lines of code to add: ~25 (router.py) + ~80 (test_router.py)
- Complexity: SIMPLE -- thin wrapper, no logic changes
- Estimated time: 15-20 minutes

## VERIFICATION CHECKLIST

- [ ] `aprocess()` method added to `PDFRouter` with correct signature
- [ ] `import asyncio` added to router.py
- [ ] Method uses `asyncio.to_thread(self.process, file_path, source_uri)`
- [ ] Docstring references SPEC 18.2
- [ ] Test class `TestAprocess` with `@pytest.mark.unit` and `@pytest.mark.asyncio`
- [ ] Test `test_aprocess_matches_process` verifies identical output (R-EXE-1)
- [ ] `pytest-asyncio` in dev dependencies
- [ ] All existing tests still pass
- [ ] `process()` remains unchanged and functional
