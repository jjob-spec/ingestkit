---
issue: 34
agent: PLAN
date: 2026-02-14
complexity: COMPLEX
stack: backend
depends_on: map-34-021426.md
---

# PLAN Artifact: Issue #34 -- OCR Engine Abstraction

## Executive Summary

Issue #34 creates `packages/ingestkit-pdf/src/ingestkit_pdf/utils/ocr_engines.py` (~180 lines) containing a Protocol-based `OCREngineInterface`, a Pydantic `OCRPageResult` model, a `TesseractEngine` adapter with ISO 639-1 to 639-3 language mapping, a `create_ocr_engine()` factory with PaddleOCR-to-Tesseract fallback, and an `EngineUnavailableError` exception. Tests (~250 lines) fully mock `pytesseract` and `shutil.which` so no real Tesseract binary is needed. The module follows the established util pattern from `header_footer.py` and `heading_detector.py`.

## File-by-File Implementation

---

### 1. `packages/ingestkit-pdf/src/ingestkit_pdf/utils/ocr_engines.py` (~180 lines)

#### Imports

```python
from __future__ import annotations

import logging
import shutil
from typing import TYPE_CHECKING, Protocol, runtime_checkable

from pydantic import BaseModel

from ingestkit_pdf.config import PDFProcessorConfig
from ingestkit_pdf.models import OCREngine

if TYPE_CHECKING:
    from PIL import Image
```

Logger: `logger = logging.getLogger("ingestkit_pdf.utils.ocr_engines")`

#### 1a. `EngineUnavailableError` Exception

```python
class EngineUnavailableError(Exception):
    """Raised when no OCR engine is available."""
```

Simple `Exception` subclass, NOT `IngestError`. This is a setup-time error raised during factory construction. Downstream consumers (future OCR processor) catch this and convert to `IngestError(code=E_OCR_ENGINE_UNAVAILABLE)`.

#### 1b. `OCRPageResult` Pydantic Model

```python
class OCRPageResult(BaseModel):
    """Standardized OCR output from any engine."""

    text: str
    confidence: float  # 0.0-1.0 average
    word_confidences: list[float] | None = None
    language_detected: str | None = None
```

Lives here per SPEC 12.2, NOT in `models.py`. This is engine-level output. The existing `OCRResult` in `models.py` wraps this with pipeline context (page number, DPI, preprocessing steps).

Fields match SPEC verbatim:
- `text`: Full extracted text from the page
- `confidence`: Average word confidence, 0.0-1.0 scale
- `word_confidences`: Optional per-word confidence list (Tesseract provides this; other engines may not)
- `language_detected`: Optional detected language code (if engine supports detection)

#### 1c. `OCREngineInterface` Protocol

```python
@runtime_checkable
class OCREngineInterface(Protocol):
    """Structural subtyping interface for OCR engines."""

    def recognize(self, image: Image.Image, language: str) -> OCRPageResult: ...
    def name(self) -> str: ...
```

Uses `@runtime_checkable` per project convention (no ABCs). The `image` parameter uses `Image.Image` from Pillow (TYPE_CHECKING import). The `language` parameter uses ISO 639-1 codes (e.g., `"en"`); adapters handle engine-specific mapping internally.

#### 1d. `_LANGUAGE_MAP` Constant

```python
_LANGUAGE_MAP: dict[str, str] = {
    "en": "eng",
    "fr": "fra",
    "de": "deu",
    "es": "spa",
    "it": "ita",
    "pt": "por",
    "nl": "nld",
    "ru": "rus",
    "zh": "chi_sim",
    "ja": "jpn",
    "ko": "kor",
    "ar": "ara",
    "hi": "hin",
    "pl": "pol",
    "tr": "tur",
    "vi": "vie",
    "th": "tha",
    "uk": "ukr",
    "cs": "ces",
    "ro": "ron",
}
```

Maps ISO 639-1 codes to Tesseract's ISO 639-3 codes. Covers the 20 most common languages. Unknown codes pass through as-is (Tesseract may support the code directly or will fail with a clear error).

#### 1e. `_to_tesseract_lang()` Private Helper

```python
def _to_tesseract_lang(language: str) -> str:
    """Map ISO 639-1 language code to Tesseract's code."""
    return _LANGUAGE_MAP.get(language, language)
```

Simple lookup with pass-through fallback.

#### 1f. `_tesseract_available()` Private Helper

```python
def _tesseract_available() -> bool:
    """Check if Tesseract binary and pytesseract are both available."""
    if shutil.which("tesseract") is None:
        return False
    try:
        import pytesseract  # noqa: F401
        return True
    except ImportError:
        return False
```

Two-part check per MAP decision D4:
1. Binary exists on PATH via `shutil.which("tesseract")`
2. Python binding `pytesseract` is importable

Both must be true. The binary check comes first (cheaper than import).

#### 1g. `TesseractEngine` Class

```python
class TesseractEngine:
    """Adapter for Tesseract via pytesseract. Required baseline on all platforms."""

    def __init__(self, lang: str = "eng") -> None:
        self._lang = lang
```

Constructor stores the Tesseract-format language code. Default is `"eng"` per SPEC 12.3. Note: the factory passes `config.ocr_language` (ISO 639-1, e.g., `"en"`) through the language mapping before constructing, so the constructor receives the already-mapped code.

**Wait -- re-reading the SPEC more carefully:**

The SPEC 12.5 factory does `TesseractEngine(lang=config.ocr_language)` directly. This means the constructor receives the ISO 639-1 code from config. The adapter must handle the mapping internally. Two design options:

- **Option A**: Constructor receives ISO 639-1, maps internally in `__init__`
- **Option B**: Constructor receives Tesseract code; factory maps before passing

The SPEC pseudocode passes `config.ocr_language` directly to the constructor (`lang=config.ocr_language`), and the SPEC 12.3 says "Adapter handles mapping." This means **Option A**: the constructor receives the user-facing code and maps internally.

Revised constructor:

```python
def __init__(self, lang: str = "eng") -> None:
    self._lang = _to_tesseract_lang(lang)
```

The default `"eng"` works correctly -- `_to_tesseract_lang("eng")` returns `"eng"` (pass-through since it's not in the ISO 639-1 map). When the factory passes `"en"`, it maps to `"eng"`.

#### 1h. `TesseractEngine.recognize()` Method

```python
def recognize(self, image: Image.Image, language: str) -> OCRPageResult:
    """Run Tesseract OCR on an image.

    Parameters
    ----------
    image:
        PIL Image to recognize.
    language:
        ISO 639-1 language code. Mapped to Tesseract format internally.
        Overrides the instance default if provided.
    """
    import pytesseract

    tess_lang = _to_tesseract_lang(language) if language else self._lang
    data = pytesseract.image_to_data(
        image, lang=tess_lang, output_type=pytesseract.Output.DICT
    )

    # Extract words and confidences from Tesseract output dict
    words: list[str] = []
    confidences: list[float] = []
    for text_val, conf_val in zip(data["text"], data["conf"]):
        text_stripped = text_val.strip()
        if text_stripped and conf_val != -1:
            words.append(text_stripped)
            confidences.append(conf_val / 100.0)  # Tesseract returns 0-100

    full_text = " ".join(words)
    avg_confidence = (
        sum(confidences) / len(confidences) if confidences else 0.0
    )

    return OCRPageResult(
        text=full_text,
        confidence=avg_confidence,
        word_confidences=confidences if confidences else None,
        language_detected=None,  # Tesseract does not reliably report detected language
    )
```

Key implementation details:
- Lazy import of `pytesseract` (optional dependency)
- Uses `image_to_data(output_type=pytesseract.Output.DICT)` per SPEC 12.3 for word-level confidence
- Filters out empty text entries and entries with `conf == -1` (Tesseract's "no confidence" marker)
- Converts Tesseract's 0-100 confidence scale to 0.0-1.0
- Joins words with spaces for full text
- `language_detected` is always `None` for Tesseract (no reliable detection support)
- The `language` parameter overrides the instance default, mapped through `_to_tesseract_lang()`

#### 1i. `TesseractEngine.name()` Method

```python
def name(self) -> str:
    """Return the engine name."""
    return "tesseract"
```

Per SPEC 12.3, returns the string `"tesseract"`.

#### 1j. `create_ocr_engine()` Factory Function

```python
def create_ocr_engine(
    config: PDFProcessorConfig,
) -> tuple[OCREngineInterface, list[str]]:
    """Create the configured OCR engine with fallback.

    Returns
    -------
    tuple[OCREngineInterface, list[str]]
        The engine instance and any warning codes emitted during creation.

    Raises
    ------
    EngineUnavailableError
        If Tesseract (the required baseline) is not available.
    """
    warnings: list[str] = []

    if config.ocr_engine == OCREngine.PADDLEOCR:
        try:
            from ingestkit_pdf.utils.ocr_engines import PaddleOCREngine  # noqa: F811

            return PaddleOCREngine(lang=config.ocr_language), warnings
        except ImportError:
            warnings.append("W_OCR_ENGINE_FALLBACK")
            logger.warning(
                "PaddleOCR requested but not installed, "
                "falling back to Tesseract baseline"
            )
            # Fall through to Tesseract

    if not _tesseract_available():
        raise EngineUnavailableError(
            "Tesseract is the required OCR baseline but is not installed. "
            "Install with: apt install tesseract-ocr && pip install pytesseract"
        )
    return TesseractEngine(lang=config.ocr_language), warnings
```

**PaddleOCR import handling:** Since `PaddleOCREngine` doesn't exist yet, the `import` will raise `ImportError`. This is the correct behavior -- it triggers the fallback to Tesseract with the `W_OCR_ENGINE_FALLBACK` warning. When PaddleOCR is implemented in a future issue, this import path will resolve.

**Correction on the PaddleOCR import approach:** The factory should attempt to instantiate `PaddleOCREngine` which would internally import `paddleocr`. Since `PaddleOCREngine` doesn't exist in this module yet, we need a different approach. The SPEC pseudocode shows a direct `PaddleOCREngine(lang=...)` call. The simplest approach:

```python
if config.ocr_engine == OCREngine.PADDLEOCR:
    try:
        # PaddleOCREngine is not implemented yet (future issue).
        # Attempting import here ensures the fallback path is exercised.
        raise ImportError("PaddleOCREngine not yet implemented")
    except ImportError:
        warnings.append("W_OCR_ENGINE_FALLBACK")
        logger.warning(
            "PaddleOCR requested but not installed, "
            "falling back to Tesseract baseline"
        )
```

**Actually, better approach:** Define a placeholder that matches the SPEC pseudocode pattern more closely. The factory should try to import `paddleocr` (the third-party package) and construct the engine. Since the adapter class doesn't exist, we guard on the import of `paddleocr` itself:

```python
if config.ocr_engine == OCREngine.PADDLEOCR:
    try:
        import paddleocr as _  # noqa: F401

        # PaddleOCREngine adapter not yet implemented (future issue)
        raise ImportError("PaddleOCREngine adapter not yet implemented")
    except ImportError:
        warnings.append("W_OCR_ENGINE_FALLBACK")
        logger.warning(
            "PaddleOCR requested but not available, "
            "falling back to Tesseract baseline"
        )
```

This approach:
1. First tries importing the `paddleocr` package (if installed, the second `raise` still fires because the adapter class isn't built yet)
2. When `paddleocr` is not installed, the `ImportError` from the import statement is caught naturally
3. Both paths produce the fallback behavior
4. When PaddleOCREngine is implemented in a future issue, this block gets replaced with the real instantiation

---

### 2. `packages/ingestkit-pdf/src/ingestkit_pdf/utils/__init__.py` (Modify)

Add exports for all public names from `ocr_engines`:

```python
from ingestkit_pdf.utils.ocr_engines import (
    EngineUnavailableError,
    OCREngineInterface,
    OCRPageResult,
    TesseractEngine,
    create_ocr_engine,
)
```

Update `__all__` to include the new names:

```python
__all__ = [
    "HeaderFooterDetector",
    "HeadingDetector",
    "EngineUnavailableError",
    "OCREngineInterface",
    "OCRPageResult",
    "TesseractEngine",
    "create_ocr_engine",
]
```

---

### 3. `packages/ingestkit-pdf/tests/test_ocr_engines.py` (~250 lines)

All tests use `@pytest.mark.unit`. No real Tesseract binary or pytesseract needed -- all mocked.

#### Imports

```python
from __future__ import annotations

from typing import Any
from unittest.mock import MagicMock, patch

import pytest
from pydantic import ValidationError

from ingestkit_pdf.config import PDFProcessorConfig
from ingestkit_pdf.models import OCREngine
from ingestkit_pdf.utils.ocr_engines import (
    EngineUnavailableError,
    OCREngineInterface,
    OCRPageResult,
    TesseractEngine,
    _LANGUAGE_MAP,
    _tesseract_available,
    _to_tesseract_lang,
    create_ocr_engine,
)
```

#### 3a. `TestOCRPageResult` (6 tests)

| Test Method | What It Tests |
|---|---|
| `test_valid_result_creation` | All fields set correctly |
| `test_minimal_result` | Only `text` and `confidence` required; optionals default to `None` |
| `test_empty_text_is_valid` | `text=""` is allowed (blank page OCR) |
| `test_word_confidences_list` | `word_confidences=[0.9, 0.8, 0.95]` stored correctly |
| `test_language_detected` | `language_detected="en"` stored correctly |
| `test_confidence_not_bounded` | No ge/le validators -- raw float accepted (consumer validates range) |

#### 3b. `TestOCREngineInterface` (2 tests)

| Test Method | What It Tests |
|---|---|
| `test_tesseract_engine_satisfies_protocol` | `isinstance(TesseractEngine(), OCREngineInterface)` is `True` (runtime_checkable) |
| `test_arbitrary_class_without_methods_fails_protocol` | Plain `object()` fails `isinstance` check |

Note: For the `isinstance` check on `TesseractEngine()`, we need to mock `pytesseract` since `TesseractEngine.__init__` does not import it, but `recognize()` does. The constructor only stores `_lang`, so no mock needed for instantiation.

#### 3c. `TestLanguageMapping` (5 tests)

| Test Method | What It Tests |
|---|---|
| `test_english_maps_to_eng` | `_to_tesseract_lang("en") == "eng"` |
| `test_french_maps_to_fra` | `_to_tesseract_lang("fr") == "fra"` |
| `test_chinese_maps_to_chi_sim` | `_to_tesseract_lang("zh") == "chi_sim"` |
| `test_unknown_code_passes_through` | `_to_tesseract_lang("xyz") == "xyz"` |
| `test_already_tesseract_code_passes_through` | `_to_tesseract_lang("eng") == "eng"` |

#### 3d. `TestTesseractAvailable` (4 tests)

All use `@patch("ingestkit_pdf.utils.ocr_engines.shutil.which")`.

| Test Method | What It Tests |
|---|---|
| `test_both_binary_and_module_available` | `which` returns path, `pytesseract` importable -> `True` |
| `test_binary_missing` | `which` returns `None` -> `False` |
| `test_module_missing` | `which` returns path, `pytesseract` import raises `ImportError` -> `False` |
| `test_both_missing` | `which` returns `None` -> `False` (short-circuits, never tries import) |

For mocking the `import pytesseract` inside `_tesseract_available()`: use `@patch.dict("sys.modules", {"pytesseract": MagicMock()})` for the available case, and `@patch.dict("sys.modules", {"pytesseract": None})` combined with a side_effect on `__import__` for the missing case. Alternatively, mock `builtins.__import__` to raise `ImportError` for `pytesseract`.

Simpler approach: patch the entire function body isn't ideal. Better to test at a higher level through the factory, but these direct unit tests are also valuable. Use `unittest.mock.patch("builtins.__import__", side_effect=...)` to control `pytesseract` importability.

#### 3e. `TestTesseractEngine` (8 tests)

All use mocked `pytesseract`.

**Fixture / Helper:**

```python
def _mock_tesseract_data(
    texts: list[str],
    confs: list[int],
) -> dict[str, list]:
    """Build a mock pytesseract.image_to_data return dict."""
    return {"text": texts, "conf": confs}
```

| Test Method | What It Tests |
|---|---|
| `test_name_returns_tesseract` | `TesseractEngine().name() == "tesseract"` |
| `test_recognize_basic` | Mock `image_to_data` returns 3 words with confs [90, 80, 70] -> text joined with spaces, confidence avg 0.8 |
| `test_recognize_filters_empty_text` | Entries with empty `text` are excluded from words and confidences |
| `test_recognize_filters_negative_confidence` | Entries with `conf == -1` are excluded |
| `test_recognize_empty_page` | All entries empty/filtered -> `text=""`, `confidence=0.0`, `word_confidences=None` |
| `test_recognize_maps_language` | Calling with `language="en"` passes `lang="eng"` to `pytesseract.image_to_data` |
| `test_confidence_scaled_to_0_1` | Tesseract conf 95 -> 0.95 in word_confidences |
| `test_default_lang_is_eng` | `TesseractEngine()._lang == "eng"` (default, after mapping passthrough) |

Mock setup for `pytesseract`:

```python
@pytest.fixture()
def mock_pytesseract():
    mock_module = MagicMock()
    mock_module.Output.DICT = "dict"
    with patch.dict("sys.modules", {"pytesseract": mock_module}):
        yield mock_module
```

Then in each test, set `mock_pytesseract.image_to_data.return_value = _mock_tesseract_data(...)`.

#### 3f. `TestCreateOCREngine` (7 tests)

| Test Method | What It Tests |
|---|---|
| `test_tesseract_config_returns_tesseract_engine` | Config with `ocr_engine=TESSERACT` -> returns `TesseractEngine`, empty warnings |
| `test_tesseract_engine_receives_config_language` | Engine's `_lang` is the mapped version of `config.ocr_language` |
| `test_paddleocr_config_falls_back_to_tesseract` | Config with `ocr_engine=PADDLEOCR`, paddleocr not installed -> returns `TesseractEngine`, warnings contain `"W_OCR_ENGINE_FALLBACK"` |
| `test_paddleocr_fallback_warning_message` | Exactly one warning in list, value is `"W_OCR_ENGINE_FALLBACK"` |
| `test_tesseract_unavailable_raises_error` | Both `shutil.which` returns `None` AND pytesseract not importable -> `EngineUnavailableError` |
| `test_error_message_contains_install_instructions` | Error message contains `"apt install tesseract-ocr"` and `"pip install pytesseract"` |
| `test_return_type_is_tuple` | Return value is a 2-tuple of (engine, list) |

Mock setup for factory tests:
- Patch `_tesseract_available` to return `True` for happy-path tests
- Patch `_tesseract_available` to return `False` for unavailable tests
- PaddleOCR fallback: no special mock needed -- `import paddleocr` will naturally fail since it's not installed in the test environment. If it is installed, patch `sys.modules` to remove it.

#### 3g. `TestEngineUnavailableError` (2 tests)

| Test Method | What It Tests |
|---|---|
| `test_is_exception_subclass` | `issubclass(EngineUnavailableError, Exception)` |
| `test_message_preserved` | `str(EngineUnavailableError("msg")) == "msg"` |

**Total test count:** ~34 tests across 7 test classes.

---

## Acceptance Criteria

- [ ] `OCREngineInterface` Protocol with `@runtime_checkable`, `recognize()` and `name()` methods
- [ ] `OCRPageResult` Pydantic model with `text`, `confidence`, `word_confidences`, `language_detected`
- [ ] `TesseractEngine` class implementing `OCREngineInterface` with `pytesseract.image_to_data` usage
- [ ] Language mapping from ISO 639-1 to Tesseract ISO 639-3 (20 common languages + pass-through)
- [ ] `_tesseract_available()` checks both binary (`shutil.which`) and Python module
- [ ] `create_ocr_engine()` factory returns `tuple[OCREngineInterface, list[str]]`
- [ ] Factory handles PaddleOCR config with `ImportError` fallback to Tesseract + `W_OCR_ENGINE_FALLBACK` warning
- [ ] Factory raises `EngineUnavailableError` when Tesseract is unavailable
- [ ] `EngineUnavailableError` is a simple `Exception` subclass (not `IngestError`)
- [ ] `OCRPageResult` lives in `ocr_engines.py` (not `models.py`)
- [ ] Logger name is `"ingestkit_pdf.utils.ocr_engines"`
- [ ] No ABC classes used (Protocol only)
- [ ] Exports added to `utils/__init__.py`
- [ ] All unit tests pass with `pytest -m unit` (all mocked, no real Tesseract)
- [ ] No regressions in existing tests

## Verification Gates (PROVE)

```bash
# All unit tests pass
pytest packages/ingestkit-pdf/tests/test_ocr_engines.py -v -m unit

# No regressions in existing tests
pytest packages/ingestkit-pdf/tests/ -v

# Imports work
python -c "from ingestkit_pdf.utils.ocr_engines import OCREngineInterface, OCRPageResult, TesseractEngine, create_ocr_engine, EngineUnavailableError"

# Protocol check works
python -c "from ingestkit_pdf.utils.ocr_engines import OCREngineInterface, TesseractEngine; assert isinstance(TesseractEngine(), OCREngineInterface)"
```

AGENT_RETURN: .agents/outputs/plan-34-021426.md
