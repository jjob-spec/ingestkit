---
issue: 62
agent: PLAN
date: 2026-02-15
complexity: COMPLEX
stack: backend
files_to_modify: 5
---

# PLAN - Issue #62: Implement Form Matching with Windowed Multi-Page Alignment

## Summary

Implement the `FormMatcher` class in `matcher.py` with two code paths: (1) `match_document()` for auto-detection via layout fingerprint comparison with windowed multi-page alignment, and (2) `resolve_manual_override()` for admin-specified template application with format compatibility validation. This requires adding a `LayoutFingerprinter` protocol to `protocols.py`, implementing the sliding window algorithm with per-page minimums and extra-page penalties, and building a comprehensive test suite with mock backends.

## Scope

- **Stack**: Backend only
- **From MAP**: See map-62-021526.md
- **Out of scope**: Fingerprint *computation* (image rendering, grid quantization) -- that is a separate issue (#61). This issue consumes pre-computed fingerprints. Text anchors and field positions matching are future enhancements (v1 uses `layout_grid` only).

## Open Question Resolutions

1. **LayoutFingerprinter protocol**: Returns `list[bytes]` (per-page). The matcher concatenates for storage comparison. `FormTemplate.layout_fingerprint` stores concatenated bytes; the matcher deserializes via `_deserialize_fingerprint()` using `rows * cols` as the page size.

2. **Warning emission**: The matcher returns all matches with confidence >= 0.5. The caller (FormRouter) interprets confidence bands and emits `W_FORM_MATCH_BELOW_THRESHOLD` / `W_FORM_MULTI_MATCH`. The matcher is a pure comparison engine -- no warning/error emission internally (except raising `FormIngestError` for manual override failures).

3. **`form_match_enabled` gate**: The matcher does NOT check this flag. The caller (router) gates the call. Keeps the matcher focused on comparison logic.

4. **`matched_features` population**: Hardcode `["layout_grid"]` for v1. Extensibility is trivial (append to list) when text anchors / field positions are added.

---

## File-by-File Plan

### File 1: `packages/ingestkit-forms/src/ingestkit_forms/protocols.py`

**Current**: Defines `FormTemplateStore`, `OCRBackend`, `PDFWidgetBackend`, `VLMBackend`. No fingerprinter protocol.
**Changes**:

1. Add `LayoutFingerprinter` protocol after `FormTemplateStore` (line ~135):

```python
@runtime_checkable
class LayoutFingerprinter(Protocol):
    """Interface for computing structural layout fingerprints.

    Concrete implementations render documents at a target DPI,
    convert to grayscale, threshold, and quantize into an NxM grid.
    The matcher consumes pre-computed fingerprints; this protocol
    enables dependency injection for the computation step.
    """

    def compute_fingerprint(self, file_path: str) -> list[bytes]:
        """Compute per-page layout fingerprints for a document.

        Each element in the returned list is a single page's fingerprint:
        a bytes object of length ``rows * cols`` where each byte is a
        quantization level (0-3).

        Returns:
            List of per-page fingerprint bytes, ordered by page number.

        Raises:
            FormIngestError with E_FORM_FINGERPRINT_FAILED on failure.
        """
        ...
```

2. Add `"LayoutFingerprinter"` to `__all__` list.

**Pattern**: Follows existing `@runtime_checkable` protocol pattern used by `FormTemplateStore` at line 86.

---

### File 2: `packages/ingestkit-forms/src/ingestkit_forms/matcher.py`

**Current**: Empty stub (7-line docstring).
**Changes**: Full implementation of `FormMatcher` class and supporting functions.

#### Module-level function: `detect_source_format`

```python
_EXTENSION_MAP: dict[str, SourceFormat] = {
    ".pdf": SourceFormat.PDF,
    ".xlsx": SourceFormat.XLSX,
    ".jpg": SourceFormat.IMAGE,
    ".jpeg": SourceFormat.IMAGE,
    ".png": SourceFormat.IMAGE,
    ".tiff": SourceFormat.IMAGE,
    ".tif": SourceFormat.IMAGE,
}

def detect_source_format(file_path: str) -> SourceFormat:
    """Map file extension to SourceFormat enum.

    Raises:
        FormIngestError with E_FORM_UNSUPPORTED_FORMAT if extension
        is not recognized.
    """
    suffix = pathlib.Path(file_path).suffix.lower()
    fmt = _EXTENSION_MAP.get(suffix)
    if fmt is None:
        raise FormIngestError(
            code=FormErrorCode.E_FORM_UNSUPPORTED_FORMAT,
            message=f"Unsupported file extension '{suffix}'",
            stage="matching",
        )
    return fmt
```

#### Internal function: `_deserialize_fingerprint`

```python
def _deserialize_fingerprint(
    fp: bytes,
    rows: int,
    cols: int,
) -> list[list[list[int]]]:
    """Deserialize concatenated fingerprint bytes into per-page NxM grids.

    Args:
        fp: Concatenated fingerprint bytes. Length must be a multiple
            of rows * cols.
        rows: Grid row count (default 20).
        cols: Grid column count (default 16).

    Returns:
        List of pages, each page is a list of rows, each row is a
        list of int quantization levels (0-3).

    Raises:
        ValueError if byte length is not a multiple of rows * cols.
    """
    page_size = rows * cols
    if len(fp) == 0 or len(fp) % page_size != 0:
        raise ValueError(
            f"Fingerprint length {len(fp)} is not a multiple of "
            f"page_size {page_size} (rows={rows}, cols={cols})"
        )
    pages: list[list[list[int]]] = []
    num_pages = len(fp) // page_size
    for p in range(num_pages):
        offset = p * page_size
        grid: list[list[int]] = []
        for r in range(rows):
            row_offset = offset + r * cols
            grid.append(list(fp[row_offset : row_offset + cols]))
        pages.append(grid)
    return pages
```

#### Internal function: `_compute_page_similarity`

```python
def _compute_page_similarity(
    page_a: list[list[int]],
    page_b: list[list[int]],
) -> float:
    """Compare two single-page fingerprint grids.

    Scoring per cell (spec 5.4):
        - Exact match: 1.0
        - Off by one quantization level: 0.5
        - Off by two or more: 0.0

    Returns:
        Similarity score 0.0-1.0.
    """
    total_cells = 0
    score_sum = 0.0
    for row_a, row_b in zip(page_a, page_b):
        for cell_a, cell_b in zip(row_a, row_b):
            diff = abs(cell_a - cell_b)
            if diff == 0:
                score_sum += 1.0
            elif diff == 1:
                score_sum += 0.5
            # else: 0.0 (no addition)
            total_cells += 1
    return score_sum / total_cells if total_cells > 0 else 0.0
```

#### Internal function: `_windowed_match`

```python
def _windowed_match(
    doc_pages: list[list[list[int]]],
    tmpl_pages: list[list[list[int]]],
    per_page_minimum: float,
    extra_page_penalty: float,
) -> tuple[float, list[float], int] | None:
    """Sliding window match across document pages.

    Algorithm (spec 6.1 lines 601-611):
        Let T = len(tmpl_pages), D = len(doc_pages).
        - D < T: return None (no match possible).
        - D == T: compare all pages 1:1.
        - D > T: slide window of size T across D pages.

    For each window position i (0 to D-T):
        1. Compare template page j vs document page i+j for all j.
        2. If any per-page similarity < per_page_minimum: skip window.
        3. penalty = (D - T) * extra_page_penalty
        4. confidence = mean(per_page_similarities) - penalty

    Returns:
        (confidence, per_page_scores, best_window_start) for the best
        window, or None if no window passes per-page minimum.
    """
    T = len(tmpl_pages)
    D = len(doc_pages)

    if D < T:
        return None

    extra_pages = D - T
    penalty = extra_pages * extra_page_penalty

    best_confidence: float = -1.0
    best_scores: list[float] = []
    best_start: int = 0

    for i in range(D - T + 1):
        page_scores: list[float] = []
        window_valid = True

        for j in range(T):
            sim = _compute_page_similarity(doc_pages[i + j], tmpl_pages[j])
            if sim < per_page_minimum:
                window_valid = False
                break
            page_scores.append(sim)

        if not window_valid:
            continue

        confidence = sum(page_scores) / len(page_scores) - penalty
        if confidence > best_confidence:
            best_confidence = confidence
            best_scores = page_scores
            best_start = i

    if best_confidence < 0:
        return None

    return (best_confidence, best_scores, best_start)
```

#### Class: `FormMatcher`

```python
logger = logging.getLogger("ingestkit_forms")

class FormMatcher:
    """Match incoming documents against registered form templates.

    Two code paths:
        1. match_document(): auto-detection via fingerprint comparison
        2. resolve_manual_override(): admin-specified template with
           format compatibility check

    Args:
        template_store: Backend for template retrieval.
        fingerprinter: Computes per-page layout fingerprints.
        config: Form processor configuration.
    """

    def __init__(
        self,
        template_store: FormTemplateStore,
        fingerprinter: LayoutFingerprinter,
        config: FormProcessorConfig,
    ) -> None:
        self._store = template_store
        self._fingerprinter = fingerprinter
        self._config = config

    def match_document(self, file_path: str) -> list[TemplateMatch]:
        """Match an incoming document against all active templates.

        Algorithm (spec 6.1):
            1. Detect source format from file extension.
            2. Load all active template fingerprints for that format.
            3. Compute incoming document's fingerprint (once).
            4. For each candidate: windowed alignment comparison.
            5. Filter matches with confidence >= 0.5 (warning floor).
            6. Sort by confidence descending.

        Returns:
            List of TemplateMatch sorted by confidence descending.
            Includes all matches with confidence >= 0.5.
            Empty list if no matches found.
        """
        source_format = detect_source_format(file_path)
        candidates = self._store.get_all_fingerprints(
            tenant_id=self._config.tenant_id,
            source_format=source_format.value,
        )
        if not candidates:
            return []

        # Compute document fingerprint once (performance requirement)
        try:
            doc_page_bytes = self._fingerprinter.compute_fingerprint(file_path)
        except Exception as exc:
            raise FormIngestError(
                code=FormErrorCode.E_FORM_FINGERPRINT_FAILED,
                message=f"Failed to compute fingerprint for '{file_path}': {exc}",
                stage="matching",
            ) from exc

        doc_pages = self._deserialize_pages(doc_page_bytes)
        rows = self._config.fingerprint_grid_rows
        cols = self._config.fingerprint_grid_cols

        matches: list[TemplateMatch] = []
        for tmpl_id, tmpl_name, tmpl_version, tmpl_fp in candidates:
            try:
                tmpl_pages = _deserialize_fingerprint(tmpl_fp, rows, cols)
            except ValueError:
                logger.warning(
                    "Skipping template %s v%d: invalid fingerprint",
                    tmpl_id, tmpl_version,
                )
                continue

            result = _windowed_match(
                doc_pages=doc_pages,
                tmpl_pages=tmpl_pages,
                per_page_minimum=self._config.form_match_per_page_minimum,
                extra_page_penalty=self._config.form_match_extra_page_penalty,
            )
            if result is None:
                continue

            confidence, per_page_scores, _window_start = result
            # Include matches with confidence >= 0.5 (warning floor)
            if confidence >= 0.5:
                matches.append(TemplateMatch(
                    template_id=tmpl_id,
                    template_name=tmpl_name,
                    template_version=tmpl_version,
                    confidence=confidence,
                    per_page_confidence=per_page_scores,
                    matched_features=["layout_grid"],
                ))

        matches.sort(key=lambda m: m.confidence, reverse=True)
        return matches

    def resolve_manual_override(
        self, request: FormIngestRequest,
    ) -> FormTemplate:
        """Load and validate a manually specified template.

        Spec 6.3 algorithm:
            1. Load template by ID (+ version if given; latest otherwise).
            2. If not found: raise E_FORM_TEMPLATE_NOT_FOUND.
            3. If format mismatch: raise E_FORM_FORMAT_MISMATCH.
            4. Return template for extraction.

        Raises:
            FormIngestError with E_FORM_TEMPLATE_NOT_FOUND or
            E_FORM_FORMAT_MISMATCH.
        """
        template = self._store.get_template(
            request.template_id,  # type: ignore[arg-type]  # caller ensures non-None
            version=request.template_version,
        )
        if template is None:
            version_msg = (
                f" version {request.template_version}"
                if request.template_version is not None
                else ""
            )
            raise FormIngestError(
                code=FormErrorCode.E_FORM_TEMPLATE_NOT_FOUND,
                message=(
                    f"Template '{request.template_id}'{version_msg} not found"
                ),
                stage="matching",
                template_id=request.template_id,
                template_version=request.template_version,
            )

        input_format = detect_source_format(request.file_path)
        if template.source_format != input_format:
            raise FormIngestError(
                code=FormErrorCode.E_FORM_FORMAT_MISMATCH,
                message=(
                    f"Template source_format '{template.source_format.value}' "
                    f"incompatible with input format '{input_format.value}'"
                ),
                stage="matching",
                template_id=request.template_id,
                template_version=request.template_version,
            )

        return template

    def _deserialize_pages(
        self, page_bytes: list[bytes],
    ) -> list[list[list[int]]]:
        """Convert per-page fingerprint bytes to grid matrices."""
        rows = self._config.fingerprint_grid_rows
        cols = self._config.fingerprint_grid_cols
        pages: list[list[list[int]]] = []
        for page_fp in page_bytes:
            grids = _deserialize_fingerprint(page_fp, rows, cols)
            # Each single-page bytes produces exactly 1 page grid
            if len(grids) != 1:
                raise FormIngestError(
                    code=FormErrorCode.E_FORM_FINGERPRINT_FAILED,
                    message=(
                        f"Expected 1 page per fingerprint element, got {len(grids)}"
                    ),
                    stage="matching",
                )
            pages.append(grids[0])
        return pages
```

**Key design notes**:
- `_deserialize_pages()` bridges the `list[bytes]` from `LayoutFingerprinter` to the grid format used by `_windowed_match`. Each element in `list[bytes]` is one page.
- Template fingerprints from `get_all_fingerprints()` are concatenated `bytes` (stored in DB). These are deserialized via `_deserialize_fingerprint()` which handles multi-page concatenation.
- The 0.5 warning floor is hardcoded as the minimum inclusion threshold. Only `form_match_confidence_threshold` (0.8) is configurable for auto-apply.

---

### File 3: `packages/ingestkit-forms/tests/conftest.py`

**Current**: Placeholder fixtures returning `{}` and `None`.
**Changes**:

1. Replace `form_config` fixture to return actual `FormProcessorConfig`:

```python
from ingestkit_forms.config import FormProcessorConfig

@pytest.fixture()
def form_config():
    """Return a FormProcessorConfig with all defaults."""
    return FormProcessorConfig()
```

2. Add `MockFormTemplateStore` class and fixture:

```python
from ingestkit_forms.models import FormTemplate, SourceFormat

class MockFormTemplateStore:
    """In-memory FormTemplateStore for testing."""

    def __init__(self) -> None:
        self._templates: dict[tuple[str, int], FormTemplate] = {}

    def save_template(self, template: FormTemplate) -> None:
        self._templates[(template.template_id, template.version)] = template

    def get_template(
        self, template_id: str, version: int | None = None,
    ) -> FormTemplate | None:
        if version is not None:
            return self._templates.get((template_id, version))
        # Find latest version
        matches = [
            t for (tid, _), t in self._templates.items()
            if tid == template_id
        ]
        if not matches:
            return None
        return max(matches, key=lambda t: t.version)

    def list_templates(self, tenant_id=None, source_format=None, active_only=True):
        results = list(self._templates.values())
        if source_format:
            results = [t for t in results if t.source_format.value == source_format]
        if tenant_id:
            results = [t for t in results if t.tenant_id == tenant_id]
        return results

    def list_versions(self, template_id: str) -> list[FormTemplate]:
        return sorted(
            [t for (tid, _), t in self._templates.items() if tid == template_id],
            key=lambda t: t.version, reverse=True,
        )

    def delete_template(self, template_id: str, version: int | None = None) -> None:
        if version is not None:
            self._templates.pop((template_id, version), None)
        else:
            keys = [k for k in self._templates if k[0] == template_id]
            for k in keys:
                del self._templates[k]

    def get_all_fingerprints(
        self, tenant_id=None, source_format=None,
    ) -> list[tuple[str, str, int, bytes]]:
        results = []
        for t in self._templates.values():
            if source_format and t.source_format.value != source_format:
                continue
            if tenant_id and t.tenant_id != tenant_id:
                continue
            if t.layout_fingerprint is not None:
                results.append((
                    t.template_id, t.name, t.version, t.layout_fingerprint,
                ))
        return results
```

3. Add `MockLayoutFingerprinter` class and fixture:

```python
class MockLayoutFingerprinter:
    """Mock fingerprinter that returns pre-configured page fingerprints."""

    def __init__(self, pages: list[bytes] | None = None) -> None:
        self._pages = pages or []

    def compute_fingerprint(self, file_path: str) -> list[bytes]:
        return self._pages
```

4. Add fixture wiring:

```python
@pytest.fixture()
def mock_template_store():
    return MockFormTemplateStore()

@pytest.fixture()
def mock_fingerprinter():
    return MockLayoutFingerprinter()
```

5. Add fingerprint helper:

```python
def make_fingerprint(
    pages: list[list[list[int]]], rows: int = 20, cols: int = 16,
) -> bytes:
    """Serialize per-page grid matrices into concatenated fingerprint bytes."""
    result = bytearray()
    for page in pages:
        for row in page:
            result.extend(row)
    return bytes(result)

def make_uniform_page(value: int, rows: int = 20, cols: int = 16) -> list[list[int]]:
    """Create a uniform grid page filled with a single value."""
    return [[value] * cols for _ in range(rows)]

def make_page_bytes(page: list[list[int]]) -> bytes:
    """Convert a single page grid to bytes."""
    result = bytearray()
    for row in page:
        result.extend(row)
    return bytes(result)
```

---

### File 4: `packages/ingestkit-forms/tests/test_matcher.py`

**Current**: Empty stub (1-line docstring).
**Changes**: Full test suite. All tests marked `@pytest.mark.unit`.

#### Test Categories and Cases

**A. `detect_source_format` tests (6 cases)**

| Test | Input | Expected |
|------|-------|----------|
| `test_detect_pdf` | `"form.pdf"` | `SourceFormat.PDF` |
| `test_detect_xlsx` | `"data.xlsx"` | `SourceFormat.XLSX` |
| `test_detect_image_variants` | `.jpg`, `.jpeg`, `.png`, `.tiff`, `.tif` | `SourceFormat.IMAGE` |
| `test_detect_case_insensitive` | `"FORM.PDF"` | `SourceFormat.PDF` |
| `test_detect_unknown_extension` | `"file.doc"` | raises `FormIngestError` with `E_FORM_UNSUPPORTED_FORMAT` |
| `test_detect_no_extension` | `"noext"` | raises `FormIngestError` with `E_FORM_UNSUPPORTED_FORMAT` |

**B. `_deserialize_fingerprint` tests (4 cases)**

| Test | Input | Expected |
|------|-------|----------|
| `test_deserialize_single_page` | 320 bytes | 1 page, 20x16 grid |
| `test_deserialize_multi_page` | 640 bytes | 2 pages |
| `test_deserialize_invalid_length` | 100 bytes | raises `ValueError` |
| `test_deserialize_empty` | 0 bytes | raises `ValueError` |

**C. `_compute_page_similarity` tests (4 cases)**

| Test | Input | Expected |
|------|-------|----------|
| `test_identical_pages` | same grids | 1.0 |
| `test_off_by_one` | all cells differ by 1 | 0.5 |
| `test_completely_different` | all cells differ by 2+ | 0.0 |
| `test_mixed_similarity` | 50% exact, 50% off-by-one | 0.75 |

**D. `_windowed_match` tests (7 cases)**

| Test | Scenario | Expected |
|------|----------|----------|
| `test_d_less_than_t` | D=1, T=2 | None |
| `test_d_equals_t_match` | D=2, T=2, identical | confidence ~1.0 |
| `test_d_equals_t_no_match` | D=2, T=2, page below minimum | None |
| `test_d_greater_than_t_finds_best_window` | D=4, T=2, match at position 1 | confidence with penalty |
| `test_extra_page_penalty_applied` | D=3, T=1 | penalty = 2 * 0.02 = 0.04 |
| `test_per_page_minimum_enforced` | one page < 0.6 | None or skips that window |
| `test_single_page_template_single_page_doc` | D=1, T=1 | direct comparison |

**E. `FormMatcher.match_document` integration tests (6 cases)**

| Test | Scenario | Expected |
|------|----------|----------|
| `test_match_single_template_high_confidence` | 1 template, identical FP | 1 match, confidence ~1.0 |
| `test_match_no_templates` | empty store | empty list |
| `test_match_below_warning_floor` | template with conf < 0.5 | empty list (excluded) |
| `test_match_multiple_templates_sorted` | 3 templates, varying similarity | sorted desc by confidence |
| `test_match_fingerprint_failure` | fingerprinter raises | raises `E_FORM_FINGERPRINT_FAILED` |
| `test_match_invalid_template_fingerprint_skipped` | bad FP bytes in store | skipped with warning, others still matched |

**F. `FormMatcher.resolve_manual_override` tests (5 cases)**

| Test | Scenario | Expected |
|------|----------|----------|
| `test_override_happy_path` | template exists, format matches | returns template |
| `test_override_not_found` | template_id doesn't exist | raises `E_FORM_TEMPLATE_NOT_FOUND` |
| `test_override_version_not_found` | specific version missing | raises `E_FORM_TEMPLATE_NOT_FOUND` |
| `test_override_format_mismatch` | PDF template vs XLSX input | raises `E_FORM_FORMAT_MISMATCH` with exact message |
| `test_override_latest_version` | no version specified | returns latest version |

**Total: ~32 test cases**

---

### File 5: `packages/ingestkit-forms/src/ingestkit_forms/__init__.py`

**Current**: Exports all models, protocols, config, errors. No matcher exports.
**Changes**:

1. Add import:
```python
from ingestkit_forms.matcher import FormMatcher, detect_source_format
from ingestkit_forms.protocols import LayoutFingerprinter
```

2. Add to `__all__`:
```python
# Matcher (from issue #62)
"FormMatcher",
"detect_source_format",
# Protocol additions (from issue #62)
"LayoutFingerprinter",
```

---

## Enum Value Verification

| Enum | Usage in Matcher | Actual Value | Match |
|------|------------------|-------------|-------|
| `SourceFormat.PDF` | Format detection | `"pdf"` | Verified (models.py:36) |
| `SourceFormat.XLSX` | Format detection | `"xlsx"` | Verified (models.py:37) |
| `SourceFormat.IMAGE` | Format detection | `"image"` | Verified (models.py:38) |
| `FormErrorCode.E_FORM_FORMAT_MISMATCH` | Manual override | `"E_FORM_FORMAT_MISMATCH"` | Verified (errors.py:52) |
| `FormErrorCode.E_FORM_TEMPLATE_NOT_FOUND` | Manual override | `"E_FORM_TEMPLATE_NOT_FOUND"` | Verified (errors.py:26) |
| `FormErrorCode.E_FORM_FINGERPRINT_FAILED` | FP computation failure | `"E_FORM_FINGERPRINT_FAILED"` | Verified (errors.py:33) |
| `FormErrorCode.E_FORM_UNSUPPORTED_FORMAT` | Unknown extension | `"E_FORM_UNSUPPORTED_FORMAT"` | Verified (errors.py:39) |

**Error code discrepancy**: Spec 6.3 line 683 says `E_FORM_TEMPLATE_INVALID` for format mismatch. Code uses `E_FORM_FORMAT_MISMATCH` (errors.py:52) which is more specific. Using `E_FORM_FORMAT_MISMATCH` per MAP recommendation.

---

## Contract Required

No. Backend-only change. No frontend, no API contract needed.

## Acceptance Criteria

- [ ] `LayoutFingerprinter` protocol added to `protocols.py` with `compute_fingerprint(file_path) -> list[bytes]` signature
- [ ] `detect_source_format()` maps all 7 extensions (pdf, xlsx, jpg, jpeg, png, tiff, tif) and raises `E_FORM_UNSUPPORTED_FORMAT` for unknowns
- [ ] `_deserialize_fingerprint()` converts concatenated bytes to per-page NxM grids
- [ ] `_compute_page_similarity()` implements exact/off-by-one/zero scoring per spec 5.4
- [ ] `_windowed_match()` handles D<T (None), D==T (1:1), D>T (sliding window) per spec 6.1
- [ ] Per-page minimum (0.6 default) rejects windows where any page is below threshold
- [ ] Extra page penalty = `(D-T) * form_match_extra_page_penalty` applied correctly
- [ ] `FormMatcher.match_document()` returns matches with confidence >= 0.5, sorted descending
- [ ] `FormMatcher.resolve_manual_override()` validates format compatibility and raises `E_FORM_FORMAT_MISMATCH` with exact message format from spec
- [ ] `resolve_manual_override()` raises `E_FORM_TEMPLATE_NOT_FOUND` for missing template/version
- [ ] `MockFormTemplateStore` and `MockLayoutFingerprinter` in conftest.py
- [ ] All ~32 unit tests pass with `@pytest.mark.unit`
- [ ] `FormMatcher` and `LayoutFingerprinter` exported from `__init__.py`
- [ ] No concrete backends inside `ingestkit_forms/` (DI via protocols only)

## Verification Gates

```bash
cd /home/jjob/projects/ingestkit && pytest packages/ingestkit-forms/tests/test_matcher.py -v -m unit
cd /home/jjob/projects/ingestkit && pytest packages/ingestkit-forms/tests -v
```

---

AGENT_RETURN: .agents/outputs/plan-62-021526.md
