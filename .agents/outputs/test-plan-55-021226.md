# TEST PLAN: Issue #55 -- Extract ingestkit-core Shared Package

**Date:** 2026-02-12
**Issue:** #55 -- Extract ingestkit-core shared package from sibling packages
**Risk level:** HIGH -- refactoring extraction with two downstream consumers

---

## 1. Inventory of Shared Primitives

### 1.1 Protocols (identical in both packages)

| Protocol               | Excel location                         | PDF location                         | Methods                                                          |
|------------------------|----------------------------------------|--------------------------------------|------------------------------------------------------------------|
| `VectorStoreBackend`   | `ingestkit_excel/protocols.py:19-36`   | `ingestkit_pdf/protocols.py:20-37`   | `upsert_chunks`, `ensure_collection`, `create_payload_index`, `delete_by_ids` |
| `StructuredDBBackend`  | `ingestkit_excel/protocols.py:40-61`   | `ingestkit_pdf/protocols.py:41-62`   | `create_table_from_dataframe`, `drop_table`, `table_exists`, `get_table_schema`, `get_connection_uri` |
| `LLMBackend`           | `ingestkit_excel/protocols.py:65-87`   | `ingestkit_pdf/protocols.py:66-88`   | `classify`, `generate`                                           |
| `EmbeddingBackend`     | `ingestkit_excel/protocols.py:90-101`  | `ingestkit_pdf/protocols.py:91-102`  | `embed`, `dimension`                                             |

**Note:** Protocols are byte-for-byte identical except for the TYPE_CHECKING import path (`ingestkit_excel.models.ChunkPayload` vs `ingestkit_pdf.models.ChunkPayload`). The core package must use a generic `ChunkPayload` type or `Any` in the TYPE_CHECKING block.

### 1.2 Models (identical logic, different field-level structure)

| Model              | Excel                       | PDF                         | Identical? | Notes                                  |
|--------------------|-----------------------------|-----------------------------|------------|----------------------------------------|
| `IngestKey`        | `models.py:85-104`          | `models.py:99-117`          | YES        | Same fields, same `key` property       |
| `WrittenArtifacts` | `models.py:245-251`         | `models.py:345-351`         | YES        | Same fields, same defaults             |
| `EmbedStageResult` | `models.py:135-141`         | `models.py:332-338`         | YES        | Same fields                            |
| `ChunkPayload`     | `models.py:222-228`         | `models.py:283-289`         | NO         | Different metadata types (`ChunkMetadata` vs `PDFChunkMetadata`) |

### 1.3 Error Codes (partially overlapping)

| Shared error codes (appear in both packages)                        |
|--------------------------------------------------------------------|
| `E_CLASSIFY_INCONCLUSIVE`, `E_LLM_TIMEOUT`, `E_LLM_MALFORMED_JSON`, `E_LLM_SCHEMA_INVALID`, `E_LLM_CONFIDENCE_OOB` |
| `E_BACKEND_VECTOR_TIMEOUT`, `E_BACKEND_VECTOR_CONNECT`, `E_BACKEND_DB_TIMEOUT`, `E_BACKEND_DB_CONNECT`, `E_BACKEND_EMBED_TIMEOUT`, `E_BACKEND_EMBED_CONNECT` |
| `E_PARSE_CORRUPT`, `E_PARSE_PASSWORD`, `E_PARSE_EMPTY`            |
| `W_LLM_RETRY`                                                      |

| Error model    | Excel                    | PDF                      | Differences                                   |
|----------------|--------------------------|--------------------------|-----------------------------------------------|
| `IngestError`  | `errors.py:55-67`        | `errors.py:75-87`        | Excel: `sheet_name: str | None`; PDF: `page_number: int | None` |

**Key design decision for core:** The base `IngestError` in core should contain the shared fields (`code`, `message`, `stage`, `recoverable`) and each package extends with its own location field. Alternatively, use a generic `location` field.

---

## 2. Existing Test Coverage Summary

### 2.1 ingestkit-excel tests (8 test files)

| File                      | Classes/focus                                                    | Count (approx) |
|---------------------------|------------------------------------------------------------------|----------------|
| `conftest.py`             | `sample_config`, `sample_ingest_key` fixtures                    | 2 fixtures     |
| `test_models.py`          | All enums, IngestKey, stage artifacts, core models, protocols    | ~60 tests      |
| `test_config.py`          | Config defaults, from_file (JSON/YAML), ErrorCode completeness   | ~40 tests      |
| `test_idempotency.py`     | `compute_ingest_key` determinism, tenant_id, source_uri          | ~15 tests      |
| `test_inspector.py`       | Tier 1 rule-based classifier signals and decisions               | ~30 tests      |
| `test_llm_classifier.py`  | Tier 2/3 LLM classifier with mock backend                       | ~40 tests      |
| `test_parser_chain.py`    | Parser fallback chain with real xlsx files                       | ~20 tests      |
| `test_structured_db.py`   | Path A processor: clean_name, process flow, error handling       | ~40 tests      |

### 2.2 ingestkit-pdf tests (6 test files)

| File                | Classes/focus                                              | Count (approx) |
|---------------------|------------------------------------------------------------|----------------|
| `conftest.py`       | Empty (placeholder)                                        | 0              |
| `test_models.py`    | Enums, ExtractionQuality, IngestKey, stage artifacts       | ~40 tests      |
| `test_errors.py`    | ErrorCode enum values, IngestError model                   | ~15 tests      |
| `test_config.py`    | PDFProcessorConfig defaults, security overrides, from_file | ~35 tests      |
| `test_quality.py`   | QualityAssessor: assess_page, assess_document, OCR fallback| ~25 tests      |
| `test_security.py`  | PDFSecurityScanner: magic bytes, JS, encryption, size      | ~20 tests      |

---

## 3. Test Matrix

### 3.1 Category 1: Core Package Unit Tests (NEW -- `packages/ingestkit-core/tests/`)

| # | Test name                                          | File              | Priority | Description                                                        |
|---|---------------------------------------------------|-------------------|----------|--------------------------------------------------------------------|
| 1 | `test_vector_store_backend_is_runtime_checkable`   | `test_protocols.py` | P0       | `VectorStoreBackend` decorated with `@runtime_checkable`           |
| 2 | `test_structured_db_backend_is_runtime_checkable`  | `test_protocols.py` | P0       | `StructuredDBBackend` decorated with `@runtime_checkable`          |
| 3 | `test_llm_backend_is_runtime_checkable`            | `test_protocols.py` | P0       | `LLMBackend` decorated with `@runtime_checkable`                   |
| 4 | `test_embedding_backend_is_runtime_checkable`      | `test_protocols.py` | P0       | `EmbeddingBackend` decorated with `@runtime_checkable`             |
| 5 | `test_conforming_class_passes_isinstance_vector`   | `test_protocols.py` | P0       | Class with all methods passes `isinstance` check                   |
| 6 | `test_conforming_class_passes_isinstance_db`       | `test_protocols.py` | P0       | Class with all methods passes `isinstance` check                   |
| 7 | `test_conforming_class_passes_isinstance_llm`      | `test_protocols.py` | P0       | Class with all methods passes `isinstance` check                   |
| 8 | `test_conforming_class_passes_isinstance_embed`    | `test_protocols.py` | P0       | Class with all methods passes `isinstance` check                   |
| 9 | `test_non_conforming_class_fails_isinstance`       | `test_protocols.py` | P0       | Empty class fails all protocol isinstance checks                   |
| 10| `test_partial_implementation_fails_vector`         | `test_protocols.py` | P1       | Class with only some methods fails isinstance                      |
| 11| `test_structural_subtyping_no_inheritance`         | `test_protocols.py` | P0       | Class that implements methods WITHOUT inheriting Protocol passes   |
| 12| `test_ingest_key_deterministic`                    | `test_models.py`  | P0       | Same inputs produce same key                                       |
| 13| `test_ingest_key_hex_64_chars`                     | `test_models.py`  | P0       | Key is 64-char lowercase hex string                                |
| 14| `test_ingest_key_different_content_hash`           | `test_models.py`  | P0       | Different content_hash produces different key                      |
| 15| `test_ingest_key_different_source_uri`             | `test_models.py`  | P0       | Different source_uri produces different key                        |
| 16| `test_ingest_key_different_parser_version`         | `test_models.py`  | P0       | Different parser_version produces different key                    |
| 17| `test_ingest_key_tenant_none_vs_set`               | `test_models.py`  | P0       | tenant_id=None vs tenant_id="x" produces different key             |
| 18| `test_ingest_key_serialization_round_trip`         | `test_models.py`  | P0       | model_dump -> model_validate preserves key                         |
| 19| `test_ingest_key_json_round_trip`                  | `test_models.py`  | P1       | model_dump_json -> model_validate_json preserves key               |
| 20| `test_written_artifacts_defaults`                  | `test_models.py`  | P0       | Default instance has empty lists and None collection               |
| 21| `test_written_artifacts_populated`                 | `test_models.py`  | P0       | Populated instance has correct values                              |
| 22| `test_written_artifacts_empty_lists`               | `test_models.py`  | P1       | Explicit empty lists work correctly                                |
| 23| `test_written_artifacts_serialization_round_trip`  | `test_models.py`  | P0       | model_dump -> model_validate preserves values                      |
| 24| `test_embed_stage_result_valid`                    | `test_models.py`  | P0       | Valid construction with all required fields                        |
| 25| `test_embed_stage_result_missing_required`         | `test_models.py`  | P0       | Missing required fields raises ValidationError                     |
| 26| `test_embed_stage_result_serialization_round_trip` | `test_models.py`  | P1       | model_dump -> model_validate preserves values                      |
| 27| `test_shared_error_codes_exist`                    | `test_errors.py`  | P0       | All shared E_BACKEND_* codes exist with correct values             |
| 28| `test_shared_classify_error_codes_exist`           | `test_errors.py`  | P0       | E_CLASSIFY_INCONCLUSIVE, E_LLM_* codes exist                      |
| 29| `test_shared_parse_error_codes_exist`              | `test_errors.py`  | P0       | E_PARSE_CORRUPT, E_PARSE_PASSWORD, E_PARSE_EMPTY exist            |
| 30| `test_error_codes_are_str_enum`                    | `test_errors.py`  | P0       | All error code members are instances of str                        |
| 31| `test_error_code_value_equals_name`                | `test_errors.py`  | P0       | Each member's .value matches its .name                             |
| 32| `test_error_codes_have_prefix`                     | `test_errors.py`  | P0       | All codes start with E_ or W_                                     |
| 33| `test_base_ingest_error_construction`              | `test_errors.py`  | P0       | Base IngestError with code, message, stage, recoverable            |
| 34| `test_base_ingest_error_defaults`                  | `test_errors.py`  | P0       | stage=None, recoverable=False by default                           |
| 35| `test_base_ingest_error_serialization_round_trip`  | `test_errors.py`  | P0       | model_dump -> model_validate preserves values                      |
| 36| `test_package_importable`                          | `test_imports.py` | P0       | `import ingestkit_core` succeeds                                   |
| 37| `test_protocols_importable_from_core`              | `test_imports.py` | P0       | `from ingestkit_core.protocols import VectorStoreBackend` works    |
| 38| `test_models_importable_from_core`                 | `test_imports.py` | P0       | `from ingestkit_core.models import IngestKey` works                |
| 39| `test_errors_importable_from_core`                 | `test_imports.py` | P0       | `from ingestkit_core.errors import ErrorCode` works                |
| 40| `test_all_exports_in_init`                         | `test_imports.py` | P0       | `__all__` includes all expected public symbols                     |
| 41| `test_no_circular_imports`                         | `test_imports.py` | P0       | Importing core does not pull in excel or pdf                       |

### 3.2 Category 2: Migration Regression Tests

| # | Test name                                          | Location            | Priority | Description                                                     |
|---|---------------------------------------------------|---------------------|----------|-----------------------------------------------------------------|
| 42| All existing `ingestkit-excel` tests pass          | Excel test suite    | P0       | `pytest packages/ingestkit-excel/tests` green after migration   |
| 43| All existing `ingestkit-pdf` tests pass            | PDF test suite      | P0       | `pytest packages/ingestkit-pdf/tests` green after migration     |
| 44| `test_excel_re_exports_core_protocols`             | `test_imports.py`   | P0       | `from ingestkit_excel.protocols import VectorStoreBackend` still works |
| 45| `test_excel_re_exports_core_models`                | `test_imports.py`   | P0       | `from ingestkit_excel.models import IngestKey` still works      |
| 46| `test_excel_re_exports_core_errors`                | `test_imports.py`   | P0       | `from ingestkit_excel.errors import IngestError` still works    |
| 47| `test_pdf_re_exports_core_protocols`               | `test_imports.py`   | P0       | `from ingestkit_pdf.protocols import VectorStoreBackend` still works |
| 48| `test_pdf_re_exports_core_models`                  | `test_imports.py`   | P0       | `from ingestkit_pdf.models import IngestKey` still works        |
| 49| `test_pdf_re_exports_core_errors`                  | `test_imports.py`   | P0       | `from ingestkit_pdf.errors import IngestError` still works      |
| 50| `test_core_import_path_works`                      | `test_imports.py`   | P0       | `from ingestkit_core.protocols import VectorStoreBackend` works |
| 51| `test_excel_protocol_is_core_protocol`             | `test_imports.py`   | P0       | `ingestkit_excel.protocols.VectorStoreBackend is ingestkit_core.protocols.VectorStoreBackend` |
| 52| `test_pdf_protocol_is_core_protocol`               | `test_imports.py`   | P0       | `ingestkit_pdf.protocols.VectorStoreBackend is ingestkit_core.protocols.VectorStoreBackend` |
| 53| `test_ingest_key_from_excel_is_core_ingest_key`    | `test_imports.py`   | P0       | Same class identity check                                       |
| 54| `test_ingest_key_from_pdf_is_core_ingest_key`      | `test_imports.py`   | P0       | Same class identity check                                       |

### 3.3 Category 3: Integration / Contract Tests

| # | Test name                                          | File                     | Priority | Description                                                        |
|---|---------------------------------------------------|--------------------------|----------|--------------------------------------------------------------------|
| 55| `test_mock_backend_used_by_excel_and_pdf`          | `test_cross_package.py`  | P1       | A single mock implementing core Protocol works in both packages    |
| 56| `test_no_circular_import_core_to_excel`            | `test_cross_package.py`  | P0       | Importing core never pulls in excel                                |
| 57| `test_no_circular_import_core_to_pdf`              | `test_cross_package.py`  | P0       | Importing core never pulls in pdf                                  |
| 58| `test_no_circular_import_excel_to_pdf`             | `test_cross_package.py`  | P0       | Importing excel never pulls in pdf                                 |
| 59| `test_excel_isinstance_check_with_core_protocol`   | `test_cross_package.py`  | P0       | Mock backend checked against `ingestkit_core.protocols.VectorStoreBackend` passes when used in excel context |
| 60| `test_written_artifacts_interoperable`             | `test_cross_package.py`  | P1       | WrittenArtifacts from core can be used in both package ProcessingResults |
| 61| `test_ingest_key_computation_identical_across_packages` | `test_cross_package.py` | P0  | Same inputs to core IngestKey produce same key as old excel/pdf IngestKey |

### 3.4 Category 4: Edge Cases

| # | Test name                                          | File              | Priority | Description                                                        |
|---|---------------------------------------------------|-------------------|----------|--------------------------------------------------------------------|
| 62| `test_structural_subtyping_extra_methods_ok`       | `test_protocols.py` | P1     | Class with extra methods beyond protocol still passes isinstance   |
| 63| `test_structural_subtyping_different_param_names`  | `test_protocols.py` | P2     | Python Protocol ignores param names; verify behavior               |
| 64| `test_error_model_empty_message`                   | `test_errors.py`  | P2       | IngestError with empty string message (Pydantic allows it)         |
| 65| `test_error_model_unicode_message`                 | `test_errors.py`  | P2       | IngestError with unicode characters in message                     |
| 66| `test_written_artifacts_large_id_list`             | `test_models.py`  | P2       | WrittenArtifacts with 10,000 point IDs serializes correctly        |
| 67| `test_ingest_key_empty_content_hash`               | `test_models.py`  | P2       | Empty string content_hash produces valid (deterministic) key       |
| 68| `test_ingest_key_unicode_source_uri`               | `test_models.py`  | P2       | Unicode characters in source_uri produce valid key                 |
| 69| `test_ingest_key_empty_tenant_id_vs_none`          | `test_models.py`  | P1       | tenant_id="" (empty string) is falsy; verify behavior matches None |
| 70| `test_embed_stage_result_zero_texts`               | `test_models.py`  | P2       | texts_embedded=0 is valid                                          |
| 71| `test_embed_stage_result_negative_duration`        | `test_models.py`  | P2       | Pydantic does not constrain; just verify it stores                 |

---

## 4. Test Details

### 4.1 `test_protocols.py` -- Core Protocol Definitions

```python
"""Tests for ingestkit_core.protocols -- runtime-checkable protocol definitions."""

from __future__ import annotations

import sys

import pytest

from ingestkit_core.protocols import (
    EmbeddingBackend,
    LLMBackend,
    StructuredDBBackend,
    VectorStoreBackend,
)


# -- Runtime checkable decorator verification --

class TestRuntimeCheckable:
    """All four protocols must be @runtime_checkable."""

    @pytest.mark.parametrize(
        "protocol",
        [VectorStoreBackend, StructuredDBBackend, LLMBackend, EmbeddingBackend],
        ids=["VectorStore", "StructuredDB", "LLM", "Embedding"],
    )
    def test_is_runtime_checkable(self, protocol):
        """Protocol has _is_runtime_checkable attribute set by decorator."""
        assert getattr(protocol, "_is_runtime_checkable", False) is True


# -- Conforming mock classes (structural subtyping, NO inheritance) --

class _FakeVectorStore:
    def upsert_chunks(self, collection, chunks): return 0
    def ensure_collection(self, collection, vector_size): pass
    def create_payload_index(self, collection, field, field_type): pass
    def delete_by_ids(self, collection, ids): return 0

class _FakeStructuredDB:
    def create_table_from_dataframe(self, table_name, df): pass
    def drop_table(self, table_name): pass
    def table_exists(self, table_name): return False
    def get_table_schema(self, table_name): return {}
    def get_connection_uri(self): return "sqlite:///:memory:"

class _FakeLLM:
    def classify(self, prompt, model, temperature=0.1, timeout=None): return {}
    def generate(self, prompt, model, temperature=0.7, timeout=None): return ""

class _FakeEmbedding:
    def embed(self, texts, timeout=None): return [[0.0] * 768 for _ in texts]
    def dimension(self): return 768


class TestStructuralSubtyping:
    """Classes implementing protocol methods WITHOUT inheriting pass isinstance."""

    def test_vector_store_isinstance(self):
        assert isinstance(_FakeVectorStore(), VectorStoreBackend)

    def test_structured_db_isinstance(self):
        assert isinstance(_FakeStructuredDB(), StructuredDBBackend)

    def test_llm_isinstance(self):
        assert isinstance(_FakeLLM(), LLMBackend)

    def test_embedding_isinstance(self):
        assert isinstance(_FakeEmbedding(), EmbeddingBackend)


class TestNonConforming:
    """Empty or partial implementations must fail isinstance."""

    def test_empty_class_fails_all(self):
        class Empty: pass
        assert not isinstance(Empty(), VectorStoreBackend)
        assert not isinstance(Empty(), StructuredDBBackend)
        assert not isinstance(Empty(), LLMBackend)
        assert not isinstance(Empty(), EmbeddingBackend)

    def test_partial_vector_store_fails(self):
        class Partial:
            def upsert_chunks(self, collection, chunks): return 0
            # Missing: ensure_collection, create_payload_index, delete_by_ids
        assert not isinstance(Partial(), VectorStoreBackend)


class TestExtraMethodsOk:
    """A class with extra methods beyond the protocol should still conform."""

    def test_extra_methods_on_vector_store(self):
        class Extended(_FakeVectorStore):
            def extra_method(self): return "extra"
        assert isinstance(Extended(), VectorStoreBackend)
```

### 4.2 `test_models.py` -- Core Models

```python
"""Tests for ingestkit_core.models -- IngestKey, WrittenArtifacts, EmbedStageResult."""

from __future__ import annotations

import hashlib
import re

import pytest
from pydantic import ValidationError

from ingestkit_core.models import (
    EmbedStageResult,
    IngestKey,
    WrittenArtifacts,
)


class TestIngestKey:
    """Deterministic key computation tests."""

    def test_key_is_deterministic(self):
        ik = IngestKey(content_hash="abc", source_uri="file:///test", parser_version="1.0.0")
        assert ik.key == ik.key

    def test_key_is_64_char_hex(self):
        ik = IngestKey(content_hash="abc", source_uri="u", parser_version="v")
        assert len(ik.key) == 64
        assert re.fullmatch(r"[0-9a-f]{64}", ik.key)

    def test_different_content_hash_different_key(self):
        ik1 = IngestKey(content_hash="aaa", source_uri="u", parser_version="v")
        ik2 = IngestKey(content_hash="bbb", source_uri="u", parser_version="v")
        assert ik1.key != ik2.key

    def test_different_source_uri_different_key(self):
        ik1 = IngestKey(content_hash="h", source_uri="a", parser_version="v")
        ik2 = IngestKey(content_hash="h", source_uri="b", parser_version="v")
        assert ik1.key != ik2.key

    def test_different_parser_version_different_key(self):
        ik1 = IngestKey(content_hash="h", source_uri="u", parser_version="v1")
        ik2 = IngestKey(content_hash="h", source_uri="u", parser_version="v2")
        assert ik1.key != ik2.key

    def test_tenant_none_vs_set(self):
        ik1 = IngestKey(content_hash="h", source_uri="u", parser_version="v")
        ik2 = IngestKey(content_hash="h", source_uri="u", parser_version="v", tenant_id="t")
        assert ik1.key != ik2.key

    def test_same_fields_same_key(self):
        kwargs = dict(content_hash="h", source_uri="u", parser_version="v", tenant_id="t")
        assert IngestKey(**kwargs).key == IngestKey(**kwargs).key

    def test_known_value(self):
        """Verify against hand-computed SHA-256."""
        ik = IngestKey(content_hash="abc", source_uri="file:///test.pdf", parser_version="1.0.0")
        expected = hashlib.sha256("abc|file:///test.pdf|1.0.0".encode()).hexdigest()
        assert ik.key == expected

    def test_known_value_with_tenant(self):
        ik = IngestKey(content_hash="abc", source_uri="uri", parser_version="v", tenant_id="t1")
        expected = hashlib.sha256("abc|uri|v|t1".encode()).hexdigest()
        assert ik.key == expected

    def test_serialization_round_trip(self):
        ik = IngestKey(content_hash="abc", source_uri="u", parser_version="v", tenant_id="t")
        data = ik.model_dump()
        ik2 = IngestKey.model_validate(data)
        assert ik2.key == ik.key

    def test_json_round_trip(self):
        ik = IngestKey(content_hash="abc", source_uri="u", parser_version="v")
        json_str = ik.model_dump_json()
        ik2 = IngestKey.model_validate_json(json_str)
        assert ik2.key == ik.key

    def test_empty_tenant_id_is_falsy(self):
        """Empty string tenant_id behaves same as None (not appended to hash)."""
        ik_none = IngestKey(content_hash="h", source_uri="u", parser_version="v", tenant_id=None)
        ik_empty = IngestKey(content_hash="h", source_uri="u", parser_version="v", tenant_id="")
        # Both should NOT append tenant_id (empty string is falsy)
        assert ik_none.key == ik_empty.key

    def test_unicode_source_uri(self):
        ik = IngestKey(content_hash="h", source_uri="file:///tmp/cafe\u0301.pdf", parser_version="v")
        assert len(ik.key) == 64


class TestWrittenArtifacts:
    """WrittenArtifacts construction and serialization."""

    def test_defaults(self):
        wa = WrittenArtifacts()
        assert wa.vector_point_ids == []
        assert wa.vector_collection is None
        assert wa.db_table_names == []

    def test_populated(self):
        wa = WrittenArtifacts(
            vector_point_ids=["p1", "p2"],
            vector_collection="helpdesk",
            db_table_names=["employees"],
        )
        assert len(wa.vector_point_ids) == 2
        assert wa.vector_collection == "helpdesk"

    def test_explicit_empty_lists(self):
        wa = WrittenArtifacts(vector_point_ids=[], db_table_names=[])
        assert wa.vector_point_ids == []
        assert wa.db_table_names == []

    def test_serialization_round_trip(self):
        wa = WrittenArtifacts(
            vector_point_ids=["p1"],
            vector_collection="col",
            db_table_names=["t1"],
        )
        data = wa.model_dump()
        wa2 = WrittenArtifacts.model_validate(data)
        assert wa2.vector_point_ids == wa.vector_point_ids
        assert wa2.vector_collection == wa.vector_collection
        assert wa2.db_table_names == wa.db_table_names

    def test_large_id_list(self):
        ids = [f"point-{i}" for i in range(10_000)]
        wa = WrittenArtifacts(vector_point_ids=ids)
        assert len(wa.vector_point_ids) == 10_000
        data = wa.model_dump()
        wa2 = WrittenArtifacts.model_validate(data)
        assert len(wa2.vector_point_ids) == 10_000


class TestEmbedStageResult:
    """EmbedStageResult construction and validation."""

    def test_valid(self):
        r = EmbedStageResult(texts_embedded=10, embedding_dimension=768, embed_duration_seconds=2.0)
        assert r.texts_embedded == 10

    def test_missing_required(self):
        with pytest.raises(ValidationError):
            EmbedStageResult()  # type: ignore[call-arg]

    def test_serialization_round_trip(self):
        r = EmbedStageResult(texts_embedded=5, embedding_dimension=384, embed_duration_seconds=1.0)
        data = r.model_dump()
        r2 = EmbedStageResult.model_validate(data)
        assert r2.texts_embedded == r.texts_embedded
        assert r2.embedding_dimension == r.embedding_dimension

    def test_zero_texts_embedded(self):
        r = EmbedStageResult(texts_embedded=0, embedding_dimension=768, embed_duration_seconds=0.0)
        assert r.texts_embedded == 0
```

### 4.3 `test_errors.py` -- Core Error Codes and Base IngestError

```python
"""Tests for ingestkit_core.errors -- shared error codes and base error model."""

from __future__ import annotations

import pytest

from ingestkit_core.errors import BaseIngestError, ErrorCode


class TestSharedErrorCodes:
    """Verify all shared error codes exist and have correct values."""

    # Backend errors (shared across all packages)
    @pytest.mark.parametrize("code_name", [
        "E_BACKEND_VECTOR_TIMEOUT",
        "E_BACKEND_VECTOR_CONNECT",
        "E_BACKEND_DB_TIMEOUT",
        "E_BACKEND_DB_CONNECT",
        "E_BACKEND_EMBED_TIMEOUT",
        "E_BACKEND_EMBED_CONNECT",
    ])
    def test_backend_error_exists(self, code_name: str):
        code = ErrorCode[code_name]
        assert code.value == code_name

    # Classification/LLM errors (shared)
    @pytest.mark.parametrize("code_name", [
        "E_CLASSIFY_INCONCLUSIVE",
        "E_LLM_TIMEOUT",
        "E_LLM_MALFORMED_JSON",
        "E_LLM_SCHEMA_INVALID",
        "E_LLM_CONFIDENCE_OOB",
    ])
    def test_classify_error_exists(self, code_name: str):
        code = ErrorCode[code_name]
        assert code.value == code_name

    # Parse errors (shared subset)
    @pytest.mark.parametrize("code_name", [
        "E_PARSE_CORRUPT",
        "E_PARSE_PASSWORD",
        "E_PARSE_EMPTY",
    ])
    def test_parse_error_exists(self, code_name: str):
        code = ErrorCode[code_name]
        assert code.value == code_name

    # Shared warning
    def test_w_llm_retry_exists(self):
        assert ErrorCode.W_LLM_RETRY.value == "W_LLM_RETRY"


class TestErrorCodeProperties:
    """Structural properties of the ErrorCode enum."""

    def test_all_str_enum(self):
        for member in ErrorCode:
            assert isinstance(member, str)
            assert isinstance(member.value, str)

    def test_all_have_prefix(self):
        for member in ErrorCode:
            assert member.value.startswith("E_") or member.value.startswith("W_"), (
                f"{member.name} missing E_/W_ prefix"
            )

    def test_value_equals_name(self):
        for member in ErrorCode:
            assert member.value == member.name


class TestBaseIngestError:
    """Tests for the base IngestError model (shared fields only)."""

    def test_minimal_construction(self):
        e = BaseIngestError(
            code=ErrorCode.E_PARSE_CORRUPT,
            message="File is corrupt",
        )
        assert e.code == ErrorCode.E_PARSE_CORRUPT
        assert e.message == "File is corrupt"
        assert e.stage is None
        assert e.recoverable is False

    def test_full_construction(self):
        e = BaseIngestError(
            code=ErrorCode.W_LLM_RETRY,
            message="LLM retry #1",
            stage="classify",
            recoverable=True,
        )
        assert e.stage == "classify"
        assert e.recoverable is True

    def test_serialization_round_trip(self):
        e = BaseIngestError(
            code=ErrorCode.E_BACKEND_VECTOR_TIMEOUT,
            message="Vector store timed out",
            stage="embed",
            recoverable=False,
        )
        data = e.model_dump()
        e2 = BaseIngestError.model_validate(data)
        assert e2.code == e.code
        assert e2.message == e.message
        assert e2.stage == e.stage
        assert e2.recoverable == e.recoverable

    def test_empty_message_allowed(self):
        e = BaseIngestError(code=ErrorCode.E_PARSE_EMPTY, message="")
        assert e.message == ""

    def test_unicode_message(self):
        e = BaseIngestError(
            code=ErrorCode.E_PARSE_CORRUPT,
            message="Datei ist besch\u00e4digt",
        )
        assert "besch\u00e4digt" in e.message
```

### 4.4 `test_imports.py` -- Import Paths and Re-exports

```python
"""Tests for import paths, re-exports, and circular import prevention."""

from __future__ import annotations

import importlib
import sys


class TestCoreImportable:
    """Core package is importable and exports expected symbols."""

    def test_import_package(self):
        import ingestkit_core
        assert ingestkit_core is not None

    def test_import_protocols(self):
        from ingestkit_core.protocols import (
            VectorStoreBackend,
            StructuredDBBackend,
            LLMBackend,
            EmbeddingBackend,
        )
        assert VectorStoreBackend is not None

    def test_import_models(self):
        from ingestkit_core.models import (
            IngestKey,
            WrittenArtifacts,
            EmbedStageResult,
        )
        assert IngestKey is not None

    def test_import_errors(self):
        from ingestkit_core.errors import ErrorCode, BaseIngestError
        assert ErrorCode is not None

    def test_all_exports(self):
        import ingestkit_core
        expected = {
            "VectorStoreBackend",
            "StructuredDBBackend",
            "LLMBackend",
            "EmbeddingBackend",
            "IngestKey",
            "WrittenArtifacts",
            "EmbedStageResult",
            "ErrorCode",
            "BaseIngestError",
        }
        actual = set(ingestkit_core.__all__) if hasattr(ingestkit_core, "__all__") else set()
        assert expected.issubset(actual), f"Missing exports: {expected - actual}"


class TestReExportsExcel:
    """After migration, old import paths in ingestkit_excel still work."""

    def test_protocols_re_exported(self):
        from ingestkit_excel.protocols import VectorStoreBackend
        from ingestkit_core.protocols import VectorStoreBackend as CoreVSB
        assert VectorStoreBackend is CoreVSB

    def test_ingest_key_re_exported(self):
        from ingestkit_excel.models import IngestKey
        from ingestkit_core.models import IngestKey as CoreIK
        assert IngestKey is CoreIK

    def test_written_artifacts_re_exported(self):
        from ingestkit_excel.models import WrittenArtifacts
        from ingestkit_core.models import WrittenArtifacts as CoreWA
        assert WrittenArtifacts is CoreWA

    def test_embed_stage_result_re_exported(self):
        from ingestkit_excel.models import EmbedStageResult
        from ingestkit_core.models import EmbedStageResult as CoreESR
        assert EmbedStageResult is CoreESR


class TestReExportsPDF:
    """After migration, old import paths in ingestkit_pdf still work."""

    def test_protocols_re_exported(self):
        from ingestkit_pdf.protocols import VectorStoreBackend
        from ingestkit_core.protocols import VectorStoreBackend as CoreVSB
        assert VectorStoreBackend is CoreVSB

    def test_ingest_key_re_exported(self):
        from ingestkit_pdf.models import IngestKey
        from ingestkit_core.models import IngestKey as CoreIK
        assert IngestKey is CoreIK

    def test_written_artifacts_re_exported(self):
        from ingestkit_pdf.models import WrittenArtifacts
        from ingestkit_core.models import WrittenArtifacts as CoreWA
        assert WrittenArtifacts is CoreWA

    def test_embed_stage_result_re_exported(self):
        from ingestkit_pdf.models import EmbedStageResult
        from ingestkit_core.models import EmbedStageResult as CoreESR
        assert EmbedStageResult is CoreESR


class TestNoCircularImports:
    """Importing core must never transitively import excel or pdf."""

    def test_core_does_not_import_excel(self):
        # Clear caches to get clean state
        for mod_name in list(sys.modules):
            if mod_name.startswith("ingestkit_"):
                del sys.modules[mod_name]

        import ingestkit_core  # noqa: F811
        loaded = [m for m in sys.modules if m.startswith("ingestkit_excel")]
        assert len(loaded) == 0, f"Core imported excel modules: {loaded}"

    def test_core_does_not_import_pdf(self):
        for mod_name in list(sys.modules):
            if mod_name.startswith("ingestkit_"):
                del sys.modules[mod_name]

        import ingestkit_core  # noqa: F811
        loaded = [m for m in sys.modules if m.startswith("ingestkit_pdf")]
        assert len(loaded) == 0, f"Core imported pdf modules: {loaded}"
```

### 4.5 `test_cross_package.py` -- Cross-Package Contract Tests

```python
"""Integration tests: verify shared core primitives work across packages."""

from __future__ import annotations


class TestSharedMockBackend:
    """A single mock backend implementing core protocols works in both packages."""

    def test_mock_vector_store_passes_both_protocols(self):
        from ingestkit_core.protocols import VectorStoreBackend as CoreVSB

        class SharedMock:
            def upsert_chunks(self, collection, chunks): return 0
            def ensure_collection(self, collection, vector_size): pass
            def create_payload_index(self, collection, field, field_type): pass
            def delete_by_ids(self, collection, ids): return 0

        mock = SharedMock()
        assert isinstance(mock, CoreVSB)

        # Also passes via package-level re-exports
        from ingestkit_excel.protocols import VectorStoreBackend as ExcelVSB
        from ingestkit_pdf.protocols import VectorStoreBackend as PdfVSB
        assert isinstance(mock, ExcelVSB)
        assert isinstance(mock, PdfVSB)

    def test_mock_embedding_backend_passes_both(self):
        from ingestkit_core.protocols import EmbeddingBackend as CoreEB

        class SharedEmbedder:
            def embed(self, texts, timeout=None): return [[0.0] * 768 for _ in texts]
            def dimension(self): return 768

        mock = SharedEmbedder()
        assert isinstance(mock, CoreEB)

        from ingestkit_excel.protocols import EmbeddingBackend as ExcelEB
        from ingestkit_pdf.protocols import EmbeddingBackend as PdfEB
        assert isinstance(mock, ExcelEB)
        assert isinstance(mock, PdfEB)


class TestIngestKeyInterop:
    """IngestKey from core produces identical keys whether used via excel or pdf."""

    def test_same_computation(self):
        from ingestkit_core.models import IngestKey as CoreIK
        from ingestkit_excel.models import IngestKey as ExcelIK
        from ingestkit_pdf.models import IngestKey as PdfIK

        kwargs = dict(content_hash="abc", source_uri="file:///test", parser_version="1.0.0")
        assert CoreIK(**kwargs).key == ExcelIK(**kwargs).key == PdfIK(**kwargs).key


class TestWrittenArtifactsInterop:
    """WrittenArtifacts from core usable in both ProcessingResults."""

    def test_core_artifacts_type_compatible(self):
        from ingestkit_core.models import WrittenArtifacts
        wa = WrittenArtifacts(vector_point_ids=["p1"], vector_collection="col", db_table_names=["t1"])

        # Verify it can be used in model_dump / model_validate context
        data = wa.model_dump()
        wa2 = WrittenArtifacts.model_validate(data)
        assert wa2.vector_point_ids == ["p1"]
```

---

## 5. Regression Strategy

### 5.1 Pre-migration Baseline

Before starting the extraction:

1. **Record baseline test counts:**
   ```bash
   pytest packages/ingestkit-excel/tests -v --tb=no -q 2>&1 | tail -1
   pytest packages/ingestkit-pdf/tests -v --tb=no -q 2>&1 | tail -1
   ```
   Store the pass/fail counts.

2. **Record baseline import graph:**
   Enumerate all `from ingestkit_excel.*` and `from ingestkit_pdf.*` import statements in test files to know which paths must continue to work.

### 5.2 During Migration

After each step of the extraction:

1. **Run all three test suites:**
   ```bash
   pytest packages/ingestkit-core/tests -v
   pytest packages/ingestkit-excel/tests -v
   pytest packages/ingestkit-pdf/tests -v
   ```

2. **Verify zero regressions:**
   - Same number of tests pass in excel and pdf as the baseline.
   - No new failures, no tests skipped that weren't skipped before.

3. **Verify import identity:**
   Run `test_imports.py` to confirm `is` identity checks (re-exported symbols point to the same class objects in core).

### 5.3 Post-migration Verification

1. **Full monorepo test run:**
   ```bash
   pytest packages/ -v --tb=short
   ```

2. **Import smoke test (all three packages):**
   ```python
   python -c "
   from ingestkit_core.protocols import VectorStoreBackend
   from ingestkit_core.models import IngestKey, WrittenArtifacts, EmbedStageResult
   from ingestkit_core.errors import ErrorCode, BaseIngestError
   from ingestkit_excel.protocols import VectorStoreBackend as EVSB
   from ingestkit_pdf.protocols import VectorStoreBackend as PVSB
   assert VectorStoreBackend is EVSB is PVSB
   print('All imports OK, identity verified')
   "
   ```

3. **Circular import check:**
   ```bash
   python -c "import ingestkit_core" && echo "No circular imports"
   ```

---

## 6. Edge Cases and Risk Areas

### 6.1 High-Risk: IngestError Divergence

The `IngestError` model differs between packages:
- **Excel:** has `sheet_name: str | None` field
- **PDF:** has `page_number: int | None` field

**Recommended approach:** Extract a `BaseIngestError` to core with shared fields (`code`, `message`, `stage`, `recoverable`). Each package creates its own `IngestError` subclass that adds the location field. Tests must verify:
- Base model serialization/deserialization works
- Package-specific subclass adds its field correctly
- Existing tests importing `IngestError` from `ingestkit_excel.errors` still get the Excel variant with `sheet_name`
- Existing tests importing `IngestError` from `ingestkit_pdf.errors` still get the PDF variant with `page_number`

### 6.2 High-Risk: ChunkPayload Type Divergence

`ChunkPayload` uses different metadata types:
- **Excel:** `metadata: ChunkMetadata` (has `sheet_name`, `source_format="xlsx"`)
- **PDF:** `metadata: PDFChunkMetadata` (has `page_numbers`, `source_format="pdf"`, OCR fields)

**Decision:** `ChunkPayload` should NOT move to core because the metadata types differ. The `VectorStoreBackend.upsert_chunks` protocol method uses `ChunkPayload` in its type hint (via TYPE_CHECKING). In core, this should use `Any` or a generic `BaseChunkPayload` protocol.

### 6.3 Medium-Risk: ErrorCode Enum Superset vs Subset

Excel has 26 error codes. PDF has 42 error codes. Only ~14 are shared. Options:
- **Option A:** Core contains ONLY shared codes; each package extends with its own.
- **Option B:** Core contains the union of all codes.

**Recommended:** Option A. Core defines only the shared ~14 codes. Each package defines its full set (including the shared ones via re-export from core + its own additions). Tests must verify:
- Core ErrorCode has exactly the shared count
- Excel ErrorCode has all 26 members (shared from core + Excel-specific)
- PDF ErrorCode has all 42 members (shared from core + PDF-specific)
- Existing `ErrorCode.E_PARSE_CORRUPT` lookups work in both packages

### 6.4 Medium-Risk: `TYPE_CHECKING` Import Path

In protocols.py, both packages have:
```python
if TYPE_CHECKING:
    from ingestkit_{excel,pdf}.models import ChunkPayload
```
After extraction, the core protocols.py cannot import from either package. Options:
- Use `Any` type hint in core protocols
- Define a minimal `ChunkPayload` protocol in core
- Use a generic type parameter

### 6.5 Low-Risk: Empty `__init__.py` in PDF

`ingestkit_pdf/__init__.py` is essentially empty (no re-exports). The migration for PDF is purely changing import sources in the PDF package's own modules, not in `__init__.py`. Re-export tests for PDF should verify that `from ingestkit_pdf.models import IngestKey` works, even though there's no top-level re-export.

---

## 7. Test File Organization

```
packages/
  ingestkit-core/
    tests/
      __init__.py
      conftest.py            # Shared fixtures for core tests
      test_protocols.py      # Tests 1-11, 62-63
      test_models.py         # Tests 12-26, 66-71
      test_errors.py         # Tests 27-35, 64-65
      test_imports.py        # Tests 36-54
      test_cross_package.py  # Tests 55-61 (requires all 3 packages installed)
```

All tests in Category 1, 3, and 4 go here. Category 2 (regression) is verified by running the existing test suites in `packages/ingestkit-excel/tests/` and `packages/ingestkit-pdf/tests/` unchanged.

---

## 8. Test Execution Commands

```bash
# Core package tests only (fast, run frequently during development)
pytest packages/ingestkit-core/tests -v -m "not integration"

# Cross-package integration tests
pytest packages/ingestkit-core/tests/test_cross_package.py -v

# Full regression (all packages)
pytest packages/ -v --tb=short

# Import-only smoke test
pytest packages/ingestkit-core/tests/test_imports.py -v

# Coverage for core package
pytest packages/ingestkit-core/tests --cov=ingestkit_core --cov-report=term-missing
```

---

## 9. Definition of Done

1. All 71 tests in the matrix pass
2. All existing `ingestkit-excel` tests pass without modification
3. All existing `ingestkit-pdf` tests pass without modification
4. No circular imports between any pair of packages
5. `is` identity checks confirm re-exported symbols point to core classes
6. Coverage for `ingestkit_core` package is >= 95% for protocols, models, errors modules
