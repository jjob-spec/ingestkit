---
issue: 60
agent: MAP-PLAN
date: 2026-02-15
complexity: SIMPLE
stack: backend
---

# MAP-PLAN: Issue #60 â€” Implement Form-Specific Protocols

## Executive Summary

Implement four form-specific protocols (`FormTemplateStore`, `OCRBackend`, `PDFWidgetBackend`, `VLMBackend`) and their associated Pydantic result models (`OCRRegionResult`, `WidgetField`, `VLMFieldResult`) in the new `ingestkit-forms` package. All protocols use `typing.Protocol` with `@runtime_checkable` -- no ABCs. The file also re-exports `VectorStoreBackend`, `StructuredDBBackend`, and `EmbeddingBackend` from `ingestkit-core`. This is a single-file implementation following the exact patterns from `ingestkit-excel/protocols.py` and `ingestkit-core/protocols.py`.

## Investigation Findings

### Spec Source (SPEC 15.3, lines 2140-2351)

The spec defines exactly:
- **4 new protocols**: `FormTemplateStore`, `OCRBackend`, `PDFWidgetBackend`, `VLMBackend`
- **3 result models**: `OCRRegionResult` (BaseModel), `WidgetField` (BaseModel), `VLMFieldResult` (BaseModel)
- **3 reused protocols**: `VectorStoreBackend`, `StructuredDBBackend`, `EmbeddingBackend` from `ingestkit-core`

### Existing Protocol Patterns

Both `ingestkit-excel/protocols.py` and `ingestkit-pdf/protocols.py` follow the same pattern:
- Module docstring explaining the file's purpose
- Import `@runtime_checkable` and `Protocol` from `typing`
- Re-export shared protocols from `ingestkit_core.protocols`
- Use `from __future__ import annotations` (core does, siblings do not -- core pattern is preferred)
- `TYPE_CHECKING` guard for heavy imports (core uses this for `pandas`)
- `__all__` listing all public names

### Dependency State

- **#56 (scaffold)**: Not yet implemented. The `packages/ingestkit-forms/` directory does not exist. This plan assumes the scaffold will create `packages/ingestkit-forms/src/ingestkit_forms/` before this issue runs.
- **#57 (models)**: Provides `BoundingBox` and `FormTemplate` models. The `WidgetField` model references `BoundingBox` (from `ingestkit_forms.models`), and `FormTemplateStore` references `FormTemplate`. Both imports must be guarded with `TYPE_CHECKING`.

### Type Forward References

The protocols reference models from sibling modules:
- `FormTemplateStore` methods use `FormTemplate` (from `ingestkit_forms.models`)
- `WidgetField.bbox` field uses `BoundingBox` (from `ingestkit_forms.models`)
- `OCRRegionResult`, `WidgetField`, `VLMFieldResult` are Pydantic `BaseModel` subclasses defined in this file (not imported)

**Key decision**: `OCRRegionResult`, `WidgetField`, and `VLMFieldResult` are protocol-adjacent models. The spec defines them alongside the protocols (SPEC 15.3). They should live in `protocols.py` since they are return types of protocol methods and tightly coupled. However, `BoundingBox` and `FormTemplate` are core domain models from `models.py` (issue #57).

**Alternative**: If the team prefers models in `models.py`, the three result models could go there. But the spec groups them with protocols and they are only used as protocol return types, so `protocols.py` is the natural home.

## Implementation Plan

### File 1: `packages/ingestkit-forms/src/ingestkit_forms/protocols.py`

**Create new file.** This is the only production file for this issue.

**Structure:**

```python
"""Backend protocols for the ingestkit-forms pipeline.

Defines form-specific protocols (FormTemplateStore, OCRBackend,
PDFWidgetBackend, VLMBackend) and their result models.
Re-exports shared protocols from ingestkit_core.

See SPEC section 15.3 for authoritative definitions.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Protocol, runtime_checkable

from pydantic import BaseModel, Field

from ingestkit_core.protocols import (
    EmbeddingBackend,
    StructuredDBBackend,
    VectorStoreBackend,
)

if TYPE_CHECKING:
    from ingestkit_forms.models import BoundingBox, FormTemplate
```

**Protocol definitions (4 protocols, spec-exact signatures):**

| Protocol | Methods | Property Methods |
|----------|---------|-----------------|
| `FormTemplateStore` | `save_template(template: FormTemplate) -> None`, `get_template(template_id: str, version: int \| None = None) -> FormTemplate \| None`, `list_templates(tenant_id: str \| None = None, source_format: str \| None = None, active_only: bool = True) -> list[FormTemplate]`, `list_versions(template_id: str) -> list[FormTemplate]`, `delete_template(template_id: str, version: int \| None = None) -> None`, `get_all_fingerprints(tenant_id: str \| None = None, source_format: str \| None = None) -> list[tuple[str, str, int, bytes]]` | None |
| `OCRBackend` | `ocr_region(image_bytes: bytes, language: str = "en", config: str \| None = None, timeout: float \| None = None) -> OCRRegionResult` | `engine_name() -> str` |
| `PDFWidgetBackend` | `extract_widgets(file_path: str, page: int) -> list[WidgetField]`, `has_form_fields(file_path: str) -> bool` | `engine_name() -> str` |
| `VLMBackend` | `extract_field(image_bytes: bytes, field_type: str, field_name: str, extraction_hint: str \| None = None, timeout: float \| None = None) -> VLMFieldResult` | `model_name() -> str`, `is_available() -> bool` |

**Result models (3 Pydantic BaseModel subclasses):**

| Model | Fields |
|-------|--------|
| `OCRRegionResult` | `text: str`, `confidence: float = Field(ge=0.0, le=1.0)`, `char_confidences: list[float] \| None = Field(default=None)`, `engine: str` |
| `WidgetField` | `field_name: str`, `field_value: str \| None`, `field_type: str`, `bbox: BoundingBox`, `page: int` |
| `VLMFieldResult` | `value: str \| bool \| None`, `confidence: float = Field(ge=0.0, le=1.0)`, `model: str`, `prompt_tokens: int \| None = None`, `completion_tokens: int \| None = None` |

**`__all__` export list:**

```python
__all__ = [
    # Re-exported from ingestkit-core
    "VectorStoreBackend",
    "StructuredDBBackend",
    "EmbeddingBackend",
    # Form-specific protocols
    "FormTemplateStore",
    "OCRBackend",
    "PDFWidgetBackend",
    "VLMBackend",
    # Result models
    "OCRRegionResult",
    "WidgetField",
    "VLMFieldResult",
]
```

**Design decisions:**

1. `engine_name()`, `model_name()`, `is_available()` are regular methods (not `@property`) in Protocol definitions -- matching the spec code blocks exactly.
2. `WidgetField.bbox` uses `BoundingBox` which is imported under `TYPE_CHECKING`. At runtime, Pydantic v2 handles forward references via `model_rebuild()`. The `WidgetField` model will need `model_rebuild()` called after `models.py` is imported, or use `from __future__ import annotations` (which we already have).
3. Result models are defined before the protocols that reference them, so protocols can reference them as concrete types.

### File 2: `packages/ingestkit-forms/src/ingestkit_forms/__init__.py`

**Modify** (assumes scaffold from #56 creates this). Add protocol exports:

```python
from ingestkit_forms.protocols import (
    EmbeddingBackend,
    FormTemplateStore,
    OCRBackend,
    OCRRegionResult,
    PDFWidgetBackend,
    StructuredDBBackend,
    VectorStoreBackend,
    VLMBackend,
    VLMFieldResult,
    WidgetField,
)
```

**Note**: Only add if the scaffold `__init__.py` follows the pattern of exporting protocols (check after #56 lands). If the scaffold has no exports yet, add a minimal set or defer to a later wiring issue.

### File 3: `packages/ingestkit-forms/tests/test_protocols.py`

**Create new test file.**

**Test cases:**

| ID | Test | Purpose |
|----|------|---------|
| T1 | `test_form_template_store_is_runtime_checkable` | Verify `isinstance` check works with a conforming class |
| T2 | `test_ocr_backend_is_runtime_checkable` | Same for `OCRBackend` |
| T3 | `test_pdf_widget_backend_is_runtime_checkable` | Same for `PDFWidgetBackend` |
| T4 | `test_vlm_backend_is_runtime_checkable` | Same for `VLMBackend` |
| T5 | `test_ocr_region_result_model` | Create `OCRRegionResult`, verify field access and validation |
| T6 | `test_widget_field_model` | Create `WidgetField` with a `BoundingBox`, verify fields |
| T7 | `test_vlm_field_result_model` | Create `VLMFieldResult`, verify fields and optional fields |
| T8 | `test_ocr_region_result_confidence_bounds` | Confidence < 0 or > 1 raises `ValidationError` |
| T9 | `test_vlm_field_result_confidence_bounds` | Same bounds check for VLM |
| T10 | `test_reexported_protocols_are_same_objects` | `protocols.VectorStoreBackend is ingestkit_core.protocols.VectorStoreBackend` |
| T11 | `test_non_conforming_class_fails_isinstance` | A class missing a method fails `isinstance(obj, OCRBackend)` |

**Test approach**: For runtime_checkable tests, create minimal stub classes that implement the required methods, then verify `isinstance()` returns `True`. For non-conforming tests, verify `isinstance()` returns `False`.

## Acceptance Criteria

- [ ] `FormTemplateStore` protocol with all 6 methods matches SPEC 15.3 signatures exactly
- [ ] `OCRBackend` protocol with `ocr_region` + `engine_name` matches SPEC 15.3
- [ ] `PDFWidgetBackend` protocol with `extract_widgets` + `has_form_fields` + `engine_name` matches SPEC 15.3
- [ ] `VLMBackend` protocol with `extract_field` + `model_name` + `is_available` matches SPEC 15.3
- [ ] `OCRRegionResult`, `WidgetField`, `VLMFieldResult` Pydantic models match SPEC 15.3 field definitions
- [ ] All four protocols are `@runtime_checkable`
- [ ] No ABC base classes used anywhere
- [ ] `VectorStoreBackend`, `StructuredDBBackend`, `EmbeddingBackend` re-exported from `ingestkit_core`
- [ ] All protocols importable from `ingestkit_forms.protocols`
- [ ] Unit tests pass for all protocols and models
- [ ] No regressions in existing package tests

## Risks / Edge Cases

- **Scaffold dependency (#56)**: The `packages/ingestkit-forms/` directory does not exist yet. PATCH must run after #56 lands. If the scaffold is not present, PATCH should fail fast with a clear message.
- **BoundingBox forward reference**: `WidgetField.bbox` references `BoundingBox` from `models.py` (issue #57). With `from __future__ import annotations`, Pydantic v2 handles this via deferred evaluation. If #57 is not yet landed, tests for `WidgetField` will need a local `BoundingBox` stub or should be skipped.
- **`engine_name` / `model_name` as methods vs properties**: The spec shows these as methods (no `@property`). Protocol `@property` has quirks with `@runtime_checkable` -- keeping them as methods is correct and matches spec.

AGENT_RETURN: .agents/outputs/map-plan-60-021526.md
