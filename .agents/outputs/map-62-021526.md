---
issue: 62
agent: MAP
date: 2026-02-15
complexity: COMPLEX
stack: backend
---

# MAP: Issue #62 -- Implement Form Matching with Windowed Multi-Page Alignment

## 1. Executive Summary

Issue #62 requires implementing the `FormMatcher` class in `matcher.py` with two main code paths: (1) `match_document(file_path)` for auto-detection via layout fingerprint comparison against all registered templates, using windowed multi-page alignment for D>T cases, and (2) manual override when `template_id` is provided on `FormIngestRequest`, which skips matching but validates format compatibility. The stub at `matcher.py` is empty (7 lines). All supporting types are already implemented: `TemplateMatch`, `FormIngestRequest`, `FormTemplate` in `models.py`, `FormTemplateStore` protocol in `protocols.py` (with `get_all_fingerprints()` and `get_template()`), config fields in `config.py` (5 matching params + 3 fingerprint params), and error codes `E_FORM_NO_MATCH`, `E_FORM_FINGERPRINT_FAILED`, `E_FORM_FORMAT_MISMATCH`, `W_FORM_MATCH_BELOW_THRESHOLD`, `W_FORM_MULTI_MATCH` in `errors.py`. The primary algorithmic complexity is the sliding window comparison (spec section 6.1) and the fingerprint similarity scoring (spec section 5.4).

---

## 2. Spec Requirements (Section 6)

### 2.1 `match_document` Algorithm (spec 6.1, lines 570-613)

```
match_document(file_path: str) -> list[TemplateMatch]
```

Steps:
1. Determine source format from file extension
2. Load all active templates matching that source format (via `FormTemplateStore.get_all_fingerprints(source_format=...)`)
3. Compute incoming document's layout fingerprint **once** (performance requirement)
4. For each candidate template:
   a. Compute layout similarity (windowed multi-page alignment)
   b. If similarity >= `form_match_confidence_threshold`: add to matches
5. Sort matches by confidence descending
6. Return ranked list

### 2.2 Windowed Multi-Page Alignment (spec 6.1, lines 601-611)

Let T = template page count, D = document page count.

| Case | Behavior |
|------|----------|
| D < T | No match possible |
| D == T | Compare all pages 1:1 |
| D > T | Slide window of size T across D pages (positions 0 to D-T) |

For each window position `i`:
- Compare template page `j` vs document page `i+j` for all j in 0..T-1
- Per-page similarity must exceed `form_match_per_page_minimum` (default 0.6) -- **all pages**
- Penalty = `(D - T) * form_match_extra_page_penalty` (default 0.02/page)
- Window confidence = `mean(per_page_similarities) - penalty`
- Select window with highest confidence

### 2.3 Confidence Thresholds (spec 6.2, lines 641-647)

| Range | Action |
|-------|--------|
| >= 0.8 (configurable `form_match_confidence_threshold`) | Auto-apply template |
| 0.5 to < threshold | Emit `W_FORM_MATCH_BELOW_THRESHOLD` with top-N candidates (up to 3). Fall through to standard pipeline. |
| < 0.5 | No match; fall through to standard pipeline |

### 2.4 Manual Override (spec 6.3, lines 649-687)

When `template_id` is provided on `FormIngestRequest`:
1. Skip matcher entirely
2. Load specified template (+ version if given; latest otherwise)
3. **Format compatibility check**: template `source_format` must match input file's detected format. If mismatch: return `E_FORM_FORMAT_MISMATCH` with message `"Template source_format '{template_format}' incompatible with input format '{input_format}'"`. No extraction attempted.
4. If `template_version` specified but doesn't exist: return `E_FORM_TEMPLATE_NOT_FOUND`
5. Set `FormExtractionResult.match_method = "manual_override"`

### 2.5 Fingerprint Similarity (spec 5.4, lines 544-562)

```python
def compute_layout_similarity(fp_a: bytes, fp_b: bytes) -> float:
```

Algorithm:
1. Deserialize both fingerprints into NxM matrices (per page)
2. If page counts differ, this is handled by the windowed alignment (not a 0.0 score at this level -- individual page fingerprints are compared)
3. For each grid cell:
   - Exact match: 1.0
   - Off by one quantization level: 0.5
   - Off by two or more: 0.0
4. Similarity = sum(cell_scores) / total_cells

Grid defaults: 20 rows x 16 cols = 320 cells per page.

---

## 3. Existing Infrastructure

### 3.1 Models (already implemented in `models.py`)

| Model | Status | Key Fields |
|-------|--------|------------|
| `TemplateMatch` | Done (line 226-245) | `template_id`, `template_name`, `template_version`, `confidence`, `per_page_confidence`, `matched_features` |
| `FormIngestRequest` | Done (line 248-263) | `file_path`, `template_id`, `template_version`, `tenant_id`, `source_uri`, `metadata` |
| `FormTemplate` | Done (line 161-219) | `template_id`, `name`, `version`, `source_format`, `page_count`, `layout_fingerprint`, `tenant_id` |
| `SourceFormat` | Done (line 33-38) | `PDF="pdf"`, `XLSX="xlsx"`, `IMAGE="image"` |

### 3.2 Protocol: `FormTemplateStore` (`protocols.py` line 86-134)

Key methods for matching:
- `get_all_fingerprints(tenant_id, source_format) -> list[tuple[str, str, int, bytes]]` -- returns `(template_id, name, version, fingerprint)` tuples for batch comparison
- `get_template(template_id, version) -> FormTemplate | None` -- for manual override path
- `list_templates(tenant_id, source_format, active_only)` -- alternative to `get_all_fingerprints`

### 3.3 Config Fields (`config.py` lines 36-73)

| Field | Default | Usage |
|-------|---------|-------|
| `form_match_enabled` | `True` | Gate for auto-detection |
| `form_match_confidence_threshold` | `0.8` | Auto-apply threshold |
| `form_match_per_page_minimum` | `0.6` | Per-page floor |
| `form_match_extra_page_penalty` | `0.02` | Penalty per extra page |
| `page_match_strategy` | `"windowed"` | Only strategy in v1 |
| `fingerprint_grid_rows` | `20` | Grid dimension for fingerprint |
| `fingerprint_grid_cols` | `16` | Grid dimension for fingerprint |
| `fingerprint_dpi` | `150` | DPI for fingerprint rendering |

### 3.4 Error/Warning Codes (`errors.py`)

| Code | Type | Usage in Matcher |
|------|------|-----------------|
| `E_FORM_NO_MATCH` | Error | No template matched above threshold |
| `E_FORM_FINGERPRINT_FAILED` | Error | Fingerprint computation failed |
| `E_FORM_FORMAT_MISMATCH` | Error | Manual override format incompatibility |
| `E_FORM_TEMPLATE_NOT_FOUND` | Error | Manual override template/version not found |
| `E_FORM_TEMPLATE_INVALID` | Error | Spec 6.3 references this for format mismatch (spec says `E_FORM_TEMPLATE_INVALID` but errors.py has `E_FORM_FORMAT_MISMATCH` -- **see risk below**) |
| `W_FORM_MATCH_BELOW_THRESHOLD` | Warning | 0.5 to <threshold confidence match |
| `W_FORM_MULTI_MATCH` | Warning | Multiple templates matched |

### 3.5 Test Stub (`tests/test_matcher.py`)

Empty: 1 line docstring only. Needs full test suite.

### 3.6 Conftest (`tests/conftest.py`)

Has placeholder fixtures: `form_config` (returns `{}`), `mock_template_store` (returns `None`). Both need updating.

---

## 4. Architectural Decisions & Risks

### 4.1 ENUM_VALUE Risk: Source Format Detection

The file extension to `SourceFormat` mapping is:
- `.pdf` -> `SourceFormat.PDF` (value: `"pdf"`)
- `.xlsx` -> `SourceFormat.XLSX` (value: `"xlsx"`)
- `.jpg`, `.jpeg`, `.png`, `.tiff`, `.tif` -> `SourceFormat.IMAGE` (value: `"image"`)

Source detection is described in spec 3.1 (lines 107-151). The matcher needs a helper function to detect format from file extension. This is a utility shared across the pipeline -- should it live in matcher.py or a shared utils module?

**Recommendation**: Define `detect_source_format(file_path: str) -> SourceFormat` as a module-level function in `matcher.py` for now. It can be extracted to a shared module later.

### 4.2 Error Code Discrepancy (VERIFICATION_GAP)

Spec section 6.3 line 683 says: "return `E_FORM_TEMPLATE_INVALID` with message..." for format mismatch. But `errors.py` has a dedicated `E_FORM_FORMAT_MISMATCH` code (line 52) for exactly this purpose.

**Resolution**: Use `E_FORM_FORMAT_MISMATCH` (the more specific code). The spec's `E_FORM_TEMPLATE_INVALID` is for general template validation errors. The errors.py design is more refined.

### 4.3 Fingerprint Computation is OUT OF SCOPE

Issue #62 is about **matching** (comparing fingerprints), not **computing** fingerprints. Fingerprint computation (spec 5.4: render at DPI, grayscale, threshold, grid quantization) is a separate concern that depends on image rendering libraries (Pillow, pdf2image). The matcher should:
- Accept pre-computed fingerprints from templates (stored in `FormTemplate.layout_fingerprint`)
- Require a `compute_fingerprint(file_path) -> bytes` callable or protocol for the incoming document
- The actual fingerprint computation module will be a separate issue

**Design question for PLAN**: Should the matcher accept a fingerprint computation function as a dependency, or should it call a `Fingerprinter` protocol?

**Recommendation**: Define a simple `LayoutFingerprinter` protocol with `compute_fingerprint(file_path: str) -> list[bytes]` (returns per-page fingerprints). Inject it into the matcher. This follows the project's protocol-based DI pattern.

### 4.4 Fingerprint Serialization Format

The spec says fingerprints are NxM matrices of quantized values (0-3). For multi-page forms, per-page fingerprints are concatenated. The matcher needs to:
1. Deserialize `bytes` into per-page grid matrices
2. Compare individual page grids

**Format to define**: Each page fingerprint is `rows * cols` bytes (320 bytes for 20x16 grid), where each byte is a quantization level (0-3). Multi-page fingerprints concatenate page fingerprints. Total bytes = `pages * rows * cols`.

### 4.5 Matched Features

`TemplateMatch.matched_features` should list which features contributed. The spec mentions: `'layout_grid'`, `'text_anchors'`, `'field_positions'`. For v1, only `'layout_grid'` is implemented (the grid-based structural fingerprint). Text anchors and field positions are future enhancements.

### 4.6 Return Type Design

`match_document` returns `list[TemplateMatch]` -- this is a pure data return. Warnings (`W_FORM_MATCH_BELOW_THRESHOLD`, `W_FORM_MULTI_MATCH`) and errors (`E_FORM_NO_MATCH`) need to be communicated somehow. Options:
1. Return a richer result object with matches + warnings + errors
2. Use logging for warnings, raise for errors
3. Return matches only; let the caller (router) handle threshold logic

**Recommendation**: The matcher should return all matches above the minimum threshold (0.5), not just the auto-apply threshold (0.8). The caller (FormRouter) applies threshold logic and generates warnings. The matcher is a pure comparison engine.

**However**, the spec says the matcher should also return matches in the 0.5-threshold range with warnings. This suggests the matcher itself handles the warning threshold, returning candidates with metadata about whether they auto-apply or are warning-level.

**Resolution for PLAN**: Return all matches with confidence >= 0.5 (the warning floor), sorted by confidence descending. Let the `FormRouter` or API layer interpret the confidence bands. Include `W_FORM_MATCH_BELOW_THRESHOLD` generation in the matcher or router -- PLAN should decide.

---

## 5. Module Design Sketch

### 5.1 Public API

```python
class FormMatcher:
    def __init__(
        self,
        template_store: FormTemplateStore,
        fingerprinter: LayoutFingerprinter,  # new protocol
        config: FormProcessorConfig,
    ) -> None: ...

    def match_document(self, file_path: str) -> list[TemplateMatch]:
        """Auto-detect templates via fingerprint comparison."""
        ...

    def resolve_manual_override(
        self, request: FormIngestRequest,
    ) -> FormTemplate:
        """Load and validate template for manual override.
        Raises FormIngestError on format mismatch or not found.
        """
        ...
```

### 5.2 Internal Functions

```python
def detect_source_format(file_path: str) -> SourceFormat:
    """Map file extension to SourceFormat enum."""
    ...

def _deserialize_fingerprint(
    fp: bytes, rows: int, cols: int,
) -> list[list[list[int]]]:
    """Deserialize bytes to list of per-page NxM grids."""
    ...

def _compute_page_similarity(
    page_a: list[list[int]], page_b: list[list[int]],
) -> float:
    """Compare two single-page fingerprint grids. Returns 0.0-1.0."""
    ...

def _windowed_match(
    doc_pages: list[list[list[int]]],
    tmpl_pages: list[list[list[int]]],
    per_page_minimum: float,
    extra_page_penalty: float,
) -> tuple[float, list[float]] | None:
    """Sliding window match. Returns (confidence, per_page_scores) or None."""
    ...
```

### 5.3 New Protocol Needed

```python
@runtime_checkable
class LayoutFingerprinter(Protocol):
    def compute_fingerprint(self, file_path: str) -> list[bytes]:
        """Compute per-page layout fingerprints for a document.
        Returns one bytes object per page.
        """
        ...
```

This should be added to `protocols.py`.

---

## 6. Dependencies & Imports

```python
from __future__ import annotations

import logging
import pathlib
from typing import TYPE_CHECKING

from ingestkit_forms.config import FormProcessorConfig
from ingestkit_forms.errors import FormErrorCode, FormIngestError
from ingestkit_forms.models import (
    FormIngestRequest,
    FormTemplate,
    SourceFormat,
    TemplateMatch,
)
from ingestkit_forms.protocols import FormTemplateStore

if TYPE_CHECKING:
    from ingestkit_forms.protocols import LayoutFingerprinter
```

No new external dependencies needed. Pure Python implementation.

---

## 7. Test Requirements

### 7.1 Unit Tests Needed

| Test Category | Cases | Priority |
|---------------|-------|----------|
| Source format detection | pdf, xlsx, jpg, jpeg, png, tiff, tif, unknown extension | P0 |
| Fingerprint deserialization | Single page, multi-page, invalid bytes | P0 |
| Page similarity | Identical grids (1.0), off-by-one (0.5), completely different (0.0), mixed | P0 |
| Windowed matching: D < T | Returns None | P0 |
| Windowed matching: D == T | 1:1 comparison | P0 |
| Windowed matching: D > T | Sliding window, best window selection | P0 |
| Per-page minimum enforcement | Window rejected if any page < 0.6 | P0 |
| Extra page penalty | Penalty = (D-T) * 0.02 | P0 |
| match_document full flow | Mock template store + mock fingerprinter, verify sorted results | P0 |
| Manual override: happy path | Template found, format matches | P0 |
| Manual override: format mismatch | PDF template vs XLSX input -> E_FORM_FORMAT_MISMATCH | P0 |
| Manual override: not found | Template ID doesn't exist -> E_FORM_TEMPLATE_NOT_FOUND | P0 |
| Manual override: version not found | Specific version missing -> E_FORM_TEMPLATE_NOT_FOUND | P1 |
| Confidence bands | >=0.8 in results, 0.5-0.8 in results, <0.5 excluded | P0 |
| Empty template store | No templates -> empty result list | P1 |
| form_match_enabled=False | Matcher should be a no-op (or router skips) | P1 |
| Multiple matches | Sorted by confidence descending | P1 |

### 7.2 Mock Requirements

- `MockFormTemplateStore`: implements `FormTemplateStore` protocol with in-memory dict. Needs `get_all_fingerprints()` and `get_template()` at minimum. Update conftest.py placeholder.
- `MockLayoutFingerprinter`: returns pre-configured fingerprint bytes. New fixture.
- Helper to create synthetic fingerprint bytes (known grid values).

---

## 8. Files to Modify/Create

| File | Action | Description |
|------|--------|-------------|
| `packages/ingestkit-forms/src/ingestkit_forms/matcher.py` | Modify (replace stub) | Full `FormMatcher` class implementation |
| `packages/ingestkit-forms/src/ingestkit_forms/protocols.py` | Modify | Add `LayoutFingerprinter` protocol |
| `packages/ingestkit-forms/tests/test_matcher.py` | Modify (replace stub) | Full test suite |
| `packages/ingestkit-forms/tests/conftest.py` | Modify | Add `MockFormTemplateStore`, `MockLayoutFingerprinter`, update `form_config` fixture |
| `packages/ingestkit-forms/src/ingestkit_forms/__init__.py` | Modify | Export `FormMatcher`, `LayoutFingerprinter` |

---

## 9. Open Questions for PLAN

1. **LayoutFingerprinter protocol**: Should it return `list[bytes]` (per-page) or `bytes` (concatenated)? Per-page is cleaner for the windowed algorithm but differs from `FormTemplate.layout_fingerprint` which stores a single `bytes`. Need a consistent serialization convention.

2. **Warning emission**: Should `match_document` return warnings alongside matches (via a richer result type), or should the FormRouter handle threshold interpretation? Spec 6.2 says the 0.5-threshold band emits `W_FORM_MATCH_BELOW_THRESHOLD`, but doesn't specify where.

3. **`form_match_enabled` gate**: Should the matcher check this config flag, or should the caller (router) gate the call? The matcher receiving `form_match_enabled=False` in its config and returning `[]` is simpler.

4. **Fingerprint computation scope**: Is implementing `compute_fingerprint` (the actual grid quantization from rendered images) in scope, or only the comparison/matching logic? The spec separates these concerns. This MAP assumes fingerprint *computation* is a separate issue, and this issue focuses on the *matching* algorithm using pre-computed fingerprints.

5. **`matched_features` population**: For v1, this will always be `["layout_grid"]`. Should we hardcode it, or make it extensible from the start?

AGENT_RETURN: .agents/outputs/map-62-021526.md
