# MAP -- Issue #12: ExcelRouter

## SPEC Requirements

### Section 13 -- Router (`router.py`)

**Constructor:**
```python
class ExcelRouter:
    def __init__(
        self,
        vector_store: VectorStoreBackend,
        structured_db: StructuredDBBackend,
        llm: LLMBackend,
        embedder: EmbeddingBackend,
        config: ExcelProcessorConfig | None = None,
    ): ...
```

**`process(file_path, source_uri=None) -> ProcessingResult` flow (12 steps):**

1. Compute `ingest_key` via `compute_ingest_key(file_path, config.parser_version, config.tenant_id, source_uri)` -- returns `IngestKey`, use `.key` property for the hex digest string.
2. Generate `ingest_run_id` = `str(uuid.uuid4())`.
3. Parse file via `ParserChain.parse()` -- returns `(FileProfile, list[IngestError])`.
4. Classify via `ExcelInspector.classify(profile)` -- Tier 1.
5. If inconclusive (confidence == 0.0) -- call `LLMClassifier.classify(profile, ClassificationTier.LLM_BASIC)` -- Tier 2.
6. If still low confidence (< `config.tier2_confidence_threshold`, default 0.6) and `config.enable_tier3` is True -- call `LLMClassifier.classify(profile, ClassificationTier.LLM_REASONING)` -- Tier 3.
7. If all tiers fail -- return `ProcessingResult` with `E_CLASSIFY_INCONCLUSIVE` (fail-closed, zero chunks/tables).
8. Route to processor based on `ClassificationResult.file_type`:
   - `TABULAR_DATA` -> `StructuredDBProcessor.process()`
   - `FORMATTED_DOCUMENT` -> `TextSerializer.process()`
   - `HYBRID` -> `HybridSplitter.process()`
9. Collect `WrittenArtifacts` from processor result.
10. Assemble `ProcessingResult` with all stage artifacts.
11. Log the result (PII-safe).
12. Return `ProcessingResult`.

**`process_batch(file_paths) -> list[ProcessingResult]`:** Process multiple files sequentially.

### Section 15 -- Logging

- Logger name: `ingestkit_excel`
- **INFO**: `file=X | ingest_key=X | tier=X | type=X | confidence=X | path=X | chunks=X | tables=X | parser=X | time=Xs`
- **WARNING**: fallbacks and non-fatal issues with code
- **ERROR**: fatal failures with code
- **DEBUG**: opt-in only via `log_sample_data`, `log_llm_prompts`, `log_chunk_previews`
- Redaction via `config.redact_patterns`

### Section 16 -- Public API

**Top-level exports from `__init__.py`:**
```python
from ingestkit_excel.router import ExcelRouter
# ... all existing exports plus ExcelRouter and create_default_router
```

**`create_default_router(**overrides) -> ExcelRouter`:**
- Convenience factory using default backends (Qdrant, SQLite, Ollama).
- Accepts overrides for config params.

---

## Module Interfaces

### ParserChain.parse()

**File:** `packages/ingestkit-excel/src/ingestkit_excel/parser_chain.py`

```python
class ParserChain:
    def __init__(self, config: ExcelProcessorConfig) -> None: ...
    def parse(self, file_path: str) -> tuple[FileProfile, list[IngestError]]: ...
```

- Takes a file path string.
- Returns `(FileProfile, list[IngestError])` where errors include both fatal errors and non-fatal warnings.
- FileProfile contains: `file_path`, `file_size_bytes`, `sheet_count`, `sheet_names`, `sheets: list[SheetProfile]`, `has_password_protected_sheets`, `has_chart_only_sheets`, `total_merged_cells`, `total_rows`, `content_hash`.
- Raises `FileNotFoundError` if file doesn't exist.
- Can return an empty FileProfile (sheet_count=0) for empty/corrupt/password-protected files.

### ExcelInspector.classify()

**File:** `packages/ingestkit-excel/src/ingestkit_excel/inspector.py`

```python
class ExcelInspector:
    def __init__(self, config: ExcelProcessorConfig) -> None: ...
    def classify(self, profile: FileProfile) -> ClassificationResult: ...
```

- Takes a `FileProfile`.
- Returns `ClassificationResult` with: `file_type`, `confidence`, `tier_used` (always `ClassificationTier.RULE_BASED`), `reasoning`, `per_sheet_types` (if hybrid), `signals`.
- **Inconclusive detection**: confidence == 0.0. This happens when:
  - No sheets at all (returns HYBRID with confidence=0.0).
  - Any sheet has < 3 signals matching either type (returns HYBRID with confidence=0.0, reasoning starts with "Inconclusive:").
- High confidence: 0.9 (>= 4 signals agree).
- Medium confidence: 0.7 (3 signals agree).
- Hybrid from disagreement: 0.9 confidence.

### LLMClassifier.classify()

**File:** `packages/ingestkit-excel/src/ingestkit_excel/llm_classifier.py`

```python
class LLMClassifier:
    def __init__(self, llm: LLMBackend, config: ExcelProcessorConfig) -> None: ...
    def classify(
        self,
        profile: FileProfile,
        tier: ClassificationTier,
    ) -> ClassificationResult: ...
```

- Takes a `FileProfile` and a `ClassificationTier` (must be `LLM_BASIC` or `LLM_REASONING`).
- Raises `ValueError` if tier is `RULE_BASED`.
- Selects model: `LLM_BASIC` -> `config.classification_model`, `LLM_REASONING` -> `config.reasoning_model`.
- Has built-in retry logic (2 attempts) with correction hints.
- Returns `ClassificationResult` with file_type, confidence, tier_used, reasoning.
- **On failure** (all retries exhausted): returns `ClassificationResult` with confidence=0.0 and arbitrary file_type, indicating failure.
- Does NOT handle tier escalation -- that is the router's responsibility.

**Tier escalation logic (for the router):**
- Tier 2: Called when Tier 1 is inconclusive (confidence == 0.0).
- Tier 3: Called when Tier 2 confidence < `config.tier2_confidence_threshold` (0.6) AND `config.enable_tier3` is True.
- Fail-closed: If all tiers produce confidence < threshold, return E_CLASSIFY_INCONCLUSIVE.

### Processor process() signatures

All three processors share an identical `process()` signature:

```python
def process(
    self,
    file_path: str,
    profile: FileProfile,
    ingest_key: str,
    ingest_run_id: str,
    parse_result: ParseStageResult,
    classification_result: ClassificationStageResult,
    classification: ClassificationResult,
) -> ProcessingResult: ...
```

**StructuredDBProcessor** (`processors/structured_db.py`):
```python
def __init__(
    self,
    structured_db: StructuredDBBackend,
    vector_store: VectorStoreBackend,
    embedder: EmbeddingBackend,
    config: ExcelProcessorConfig,
) -> None: ...
```

**TextSerializer** (`processors/serializer.py`):
```python
def __init__(
    self,
    vector_store: VectorStoreBackend,
    embedder: EmbeddingBackend,
    config: ExcelProcessorConfig,
) -> None: ...
```

**HybridSplitter** (`processors/splitter.py`):
```python
def __init__(
    self,
    structured_processor: object,  # StructuredDBProcessor instance
    text_serializer: object,       # TextSerializer instance
    config: ExcelProcessorConfig,
) -> None: ...
```
- Note: HybridSplitter extracts backends from the structured_processor's private `_db`, `_vector_store`, `_embedder` attributes.

### compute_ingest_key()

**File:** `packages/ingestkit-core/src/ingestkit_core/idempotency.py` (re-exported from `ingestkit_excel.idempotency`)

```python
def compute_ingest_key(
    file_path: str,
    parser_version: str,
    tenant_id: str | None = None,
    source_uri: str | None = None,
) -> IngestKey: ...
```

- Returns `IngestKey` Pydantic model.
- Use `ingest_key_obj.key` property to get the SHA-256 hex digest string (what processors expect as `ingest_key: str`).
- Reads raw file bytes, computes content_hash, derives source_uri from absolute path if not provided.
- Can raise `FileNotFoundError`.

---

## Config Parameters (Router-Relevant)

| Parameter | Type | Default | Usage in Router |
|-----------|------|---------|----------------|
| `parser_version` | str | `"ingestkit_excel:1.0.0"` | Passed to `compute_ingest_key()` |
| `tenant_id` | str \| None | None | Passed to `compute_ingest_key()` and into `ProcessingResult` |
| `tier2_confidence_threshold` | float | 0.6 | Decides Tier 2->3 escalation |
| `enable_tier3` | bool | True | Whether Tier 3 is attempted |
| `classification_model` | str | `"qwen2.5:7b"` | Used by LLMClassifier internally |
| `reasoning_model` | str | `"deepseek-r1:14b"` | Used by LLMClassifier internally |
| `log_sample_data` | bool | False | PII-safe logging control |
| `log_llm_prompts` | bool | False | PII-safe logging control |
| `log_chunk_previews` | bool | False | PII-safe logging control |
| `redact_patterns` | list[str] | [] | PII redaction patterns |
| `default_collection` | str | `"helpdesk"` | Vector store collection name |

---

## Error Codes (Router-Relevant)

| Code | Type | When Used |
|------|------|-----------|
| `E_CLASSIFY_INCONCLUSIVE` | Error | All classification tiers failed -- router returns fail-closed result |
| `E_PARSE_CORRUPT` | Error | All parsers failed for file -- router returns error result |
| `E_PARSE_PASSWORD` | Error | Password-protected file -- from parser chain |
| `E_PARSE_EMPTY` | Error | Empty file or no data sheets -- from parser chain |
| `W_PARSER_FALLBACK` | Warning | Parser fell back (non-fatal) -- from parser chain |
| `E_LLM_TIMEOUT` | Error | LLM backend timed out -- from LLMClassifier |
| `E_LLM_MALFORMED_JSON` | Error | LLM returned bad JSON -- from LLMClassifier |
| `E_LLM_SCHEMA_INVALID` | Error | LLM output failed validation -- from LLMClassifier |
| `W_LLM_RETRY` | Warning | LLM retry attempt -- from LLMClassifier |

---

## Current Exports (__init__.py)

The `__init__.py` already exports:
- All 6 backend classes (SQLiteStructuredDB, QdrantVectorStore, OllamaLLM, OllamaEmbedding, MilvusVectorStore, PostgresStructuredDB)
- `ExcelProcessorConfig`
- `ErrorCode`, `IngestError`
- `compute_ingest_key`
- All models: ChunkMetadata, ChunkPayload, ClassificationResult, ClassificationStageResult, ClassificationTier, EmbedStageResult, FileProfile, FileType, IngestKey, IngestionMethod, ParseStageResult, ParserUsed, ProcessingResult, RegionType, SheetProfile, SheetRegion, WrittenArtifacts
- `ExcelInspector`, `LLMClassifier`, `ParserChain`
- `StructuredDBProcessor`, `TextSerializer`, `HybridSplitter`
- All 4 protocol types

**Missing (to be added):**
- `ExcelRouter` (from `ingestkit_excel.router`)
- `create_default_router` (function -- can live in `router.py` or `__init__.py`)

---

## Key Patterns (From Existing Code)

1. **Logger name**: All modules use `logger = logging.getLogger("ingestkit_excel")` (except processors which use `__name__` -- the router MUST use `"ingestkit_excel"` per SPEC section 15).

2. **Config defaults**: Constructor accepts `config: ExcelProcessorConfig | None = None` -- if None, create a default instance.

3. **Error collection pattern**: All modules collect `list[IngestError]` during processing. The router should aggregate errors from all stages.

4. **Fail-closed pattern**: When classification is inconclusive, return `ProcessingResult` with error code and zero chunks/tables. Never guess.

5. **ProcessingResult assembly**: Processors already return complete `ProcessingResult` objects. For fail-closed cases (parse failure, classification inconclusive), the router needs to construct a minimal `ProcessingResult` itself.

6. **Stage artifacts**: The router must construct:
   - `ParseStageResult` from parse output (parser_used from the first sheet or most common parser, sheets_parsed, sheets_skipped, skipped_reasons, parse_duration_seconds)
   - `ClassificationStageResult` from classification output (tier_used, file_type, confidence, signals, reasoning, per_sheet_types, classification_duration_seconds)
   - Processors construct their own `ProcessingResult` including embed_result.

7. **HybridSplitter construction**: Requires instances of StructuredDBProcessor and TextSerializer (not just their backends). The router creates all three processors upfront.

8. **Time tracking**: Use `time.monotonic()` for duration measurements (consistent with existing code).

9. **PII-safe INFO log format** (SPEC section 15):
   ```
   ingestkit_excel | file=X | ingest_key=X | tier=X | type=X | confidence=X | path=X | chunks=X | tables=X | parser=X | time=Xs
   ```

10. **Processor `ingest_key` param is a string**: Processors receive `ingest_key: str` (the hex digest from `IngestKey.key`), NOT the `IngestKey` model itself.

---

## Risks

1. **ParseStageResult construction complexity**: The router must assemble `ParseStageResult` from `FileProfile` + `list[IngestError]`. This requires:
   - Determining a "primary" `parser_used` from the sheet profiles (most common or first sheet's parser).
   - Counting sheets_parsed vs sheets_skipped.
   - Building `skipped_reasons` dict from warning errors.
   - Measuring parse duration (separate timer in router).

2. **Fail-closed ProcessingResult construction**: When parsing fails completely or classification is inconclusive, the router must construct a complete `ProcessingResult` with placeholder/empty values. This requires dummy `ParseStageResult` and `ClassificationStageResult` objects.

3. **Tier escalation edge cases**:
   - Tier 1 returns confidence=0.0 for inconclusive (escalate).
   - Tier 1 returns confidence=0.7 for medium confidence -- SPEC says this does NOT escalate (only inconclusive escalates).
   - Tier 1 returns HYBRID with confidence=0.9 when sheets disagree -- this is a valid classification, NOT inconclusive.
   - LLMClassifier returns confidence=0.0 on failure -- must be treated as failure, not as a valid classification.

4. **create_default_router needs concrete backend imports**: The factory function creates default instances of Qdrant, SQLite, Ollama backends. These are optional deps -- the function should handle ImportError gracefully or document the requirement.

5. **Error aggregation**: Parse errors come from `ParserChain.parse()`, classification errors come internally from LLMClassifier (but are NOT returned separately -- they're absorbed into the ClassificationResult). Processing errors come from the processor's `ProcessingResult`. The router should merge parse-stage errors into the final result.

6. **source_uri handling**: `process()` accepts optional `source_uri` which is passed to `compute_ingest_key()`. If None, the idempotency module derives it from the file path.

7. **Logger consistency**: Processors use `logging.getLogger(__name__)` but the SPEC requires `"ingestkit_excel"`. The router itself must use `"ingestkit_excel"`. The processor logger names are an existing pattern that shouldn't be changed by this issue.

AGENT_RETURN: map-12-021226.md
