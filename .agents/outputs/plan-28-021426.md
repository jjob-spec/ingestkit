---
issue: 28
agent: PLAN
date: 2026-02-14
complexity: COMPLEX
stack: backend
files_to_create:
  - packages/ingestkit-pdf/src/ingestkit_pdf/inspector.py
  - packages/ingestkit-pdf/tests/test_inspector.py
files_to_modify:
  - packages/ingestkit-pdf/tests/conftest.py
---

# PLAN Artifact: Issue #28 -- Tier 1 Rule-Based PDF Inspector

## Executive Summary

Implement `PDFInspector` in `packages/ingestkit-pdf/src/ingestkit_pdf/inspector.py`, a rule-based per-page structural classifier that handles ~80% of PDF files without any LLM call. The inspector evaluates 7 signals per page from a `DocumentProfile`, classifies each page into one of three categories (text-native, scanned, complex), then aggregates page-level results to produce a document-level `ClassificationResult`. The implementation follows the established `ExcelInspector` pattern but adapts it from binary sheet-level classification to three-way page-level classification with special page handling (blank, TOC, vector-only). Module-level constants will be used for the two SPEC-defined scanned thresholds not present in config.

## File-by-File Implementation

### 1. `packages/ingestkit-pdf/src/ingestkit_pdf/inspector.py` (~250 lines)

#### Module-Level Setup

```python
"""Tier 1 rule-based structural inspector for PDF files.

Evaluates seven signals per page and applies threshold-based decision
logic to classify files as text-native (Type A), scanned (Type B),
or complex (Type C) -- without any LLM call.

Signal evaluation and document-level aggregation logic are defined in
SPEC.md section 9.  All configurable thresholds live in
:class:`~ingestkit_pdf.config.PDFProcessorConfig`.
"""

from __future__ import annotations

import logging
from typing import Any

from ingestkit_pdf.config import PDFProcessorConfig
from ingestkit_pdf.models import (
    ClassificationResult,
    ClassificationTier,
    DocumentProfile,
    PageProfile,
    PageType,
    PDFType,
)

logger = logging.getLogger("ingestkit_pdf")
```

#### Module-Level Constants

These are the SPEC-defined thresholds for scanned page detection that are not in `PDFProcessorConfig` (see MAP Decision 2 -- Option A):

```python
# SPEC ยง9.2: scanned page thresholds (not configurable)
_MAX_CHARS_FOR_SCANNED: int = 50
_MIN_IMAGE_COVERAGE_FOR_SCANNED: float = 0.7
```

Also define which `PageType` values are "skippable" (do not contribute to document-level type agreement):

```python
_SKIPPABLE_PAGE_TYPES: frozenset[PageType] = frozenset({
    PageType.BLANK,
    PageType.TOC,
    PageType.VECTOR_ONLY,
})
```

#### Class: `PDFInspector`

##### `__init__(self, config: PDFProcessorConfig) -> None`

Store the config reference. Nothing else.

```python
def __init__(self, config: PDFProcessorConfig) -> None:
    self._config = config
```

##### `classify(self, profile: DocumentProfile) -> ClassificationResult` (public API)

This is the only public method. Steps:

1. **Edge case: no pages.** If `profile.page_count == 0` or `len(profile.pages) == 0`, return an inconclusive result:
   - `pdf_type=PDFType.COMPLEX`, `confidence=0.0`, `tier_used=ClassificationTier.RULE_BASED`
   - `reasoning="Inconclusive: document contains no pages to classify."`
   - `per_page_types={}`, `signals={"per_page": {}}`
   - Log at INFO level (no raw data).

2. **Classify each page independently.** For each `PageProfile` in `profile.pages`:
   - Call `_classify_page(page)` which returns `(page_type: PageType, pdf_type: PDFType | None, confidence: float, signals: dict[str, Any])`.
   - `pdf_type` is `None` when the page is borderline (inconclusive).
   - Collect results into a list of tuples: `(page_number, page_type, pdf_type, confidence, signals)`.

3. **Build aggregated signals dict:**
   ```python
   signals = {
       "per_page": {
           page_num: {
               "page_type": page_type.value,
               "pdf_type": pdf_type.value if pdf_type else None,
               "confidence": conf,
               "signals": sigs,
           }
           for page_num, page_type, pdf_type, conf, sigs in page_results
       }
   }
   ```

4. **Build per_page_types dict** (always populated, per MAP Decision 5):
   ```python
   per_page_types = {page_num: page_type for page_num, page_type, _, _, _ in page_results}
   ```

5. **Filter out skippable pages** for document-level aggregation. Only pages whose `page_type` is NOT in `_SKIPPABLE_PAGE_TYPES` contribute to the document-level decision. If ALL pages are skippable, return inconclusive (same as no-pages edge case but with different reasoning).

6. **Check for borderline pages.** If any non-skippable page has `pdf_type is None`, the whole document is inconclusive:
   - `pdf_type=PDFType.COMPLEX`, `confidence=0.0`
   - `reasoning=f"Inconclusive: page {page_num} could not be classified with sufficient confidence."`
   - Log at INFO.

7. **Check document-level agreement (Signal 7).** Among non-skippable pages:
   - Collect distinct `pdf_type` values.
   - If all agree on one type: document gets that type. Confidence = minimum of all non-skippable page confidences. Reasoning describes the agreement.
   - If pages disagree: document is `PDFType.COMPLEX`, confidence = 0.9 (high confidence in the disagreement itself). Reasoning lists the page type breakdown.

8. **Return `ClassificationResult`** with all fields populated.

##### `_classify_page(self, page: PageProfile) -> tuple[PageType, PDFType | None, float, dict[str, Any]]`

Returns `(page_type, pdf_type_or_None, confidence, signals_dict)`.

Steps:

1. **Evaluate signals** by calling `_evaluate_signals(page)`. This returns a dict with 6 named boolean/categorical signals.

2. **Check for special page types first:**
   - If `page.page_type == PageType.BLANK`: return `(PageType.BLANK, None, 1.0, signals)` -- but since blank pages are skippable, `pdf_type` doesn't matter. Use `None` so it's excluded from aggregation. Actually, to keep it clean: return `(PageType.BLANK, PDFType.SCANNED, 1.0, signals)`. Wait -- blank pages shouldn't vote. Better: return the page_type from profile as-is and set pdf_type to a sentinel. Let me reconsider.

   **Revised approach**: For pages whose `page.page_type` is in `_SKIPPABLE_PAGE_TYPES`, return `(page.page_type, None, 1.0, signals)`. The `None` pdf_type signals "skip me" and is handled by step 5 of `classify()`. Log a warning using the appropriate warning code (`W_PAGE_SKIPPED_BLANK`, `W_PAGE_SKIPPED_TOC`, `W_PAGE_SKIPPED_VECTOR_ONLY`).

3. **Check for complex indicators** (signals 4, 5, 6):
   - `has_tables = page.table_count >= config.min_table_count_for_complex`
   - `is_multi_column = page.is_multi_column`
   - `has_form_fields = page.has_form_fields`
   - Count complex indicators: `complex_count = sum([has_tables, is_multi_column, has_form_fields])`
   - If `complex_count >= 1`: page is complex.
     - Determine specific `PageType`:
       - If `has_form_fields`: `PageType.FORM`
       - Elif `has_tables`: `PageType.TABLE_HEAVY`
       - Else: `PageType.MIXED` (multi-column only)
     - `pdf_type = PDFType.COMPLEX`
     - Confidence: if `complex_count >= 2` -> 0.9 (high), if `complex_count == 1` -> 0.7 (medium)
     - Return early.

4. **Check for text-native indicators** (signals 1, 2, 3):
   - `has_text = page.text_length >= config.min_chars_per_page`
   - `low_image = page.image_coverage_ratio < config.max_image_coverage_for_text`
   - `has_fonts = page.font_count >= config.min_font_count_for_digital`
   - Count text-native indicators: `text_count = sum([has_text, low_image, has_fonts])`
   - If `text_count == 3`: high confidence text-native.
     - `page_type = PageType.TEXT`, `pdf_type = PDFType.TEXT_NATIVE`, `confidence = 0.9`
   - If `text_count == 2`: medium confidence text-native.
     - `page_type = PageType.TEXT`, `pdf_type = PDFType.TEXT_NATIVE`, `confidence = 0.7`

5. **Check for scanned indicators** (signals 1, 2, 3 inverted):
   - `few_chars = page.text_length < _MAX_CHARS_FOR_SCANNED`
   - `high_image = page.image_coverage_ratio > _MIN_IMAGE_COVERAGE_FOR_SCANNED`
   - `no_fonts = page.font_count == 0`
   - Count scanned indicators: `scan_count = sum([few_chars, high_image, no_fonts])`
   - If `scan_count == 3`: high confidence scanned.
     - `page_type = PageType.SCANNED`, `pdf_type = PDFType.SCANNED`, `confidence = 0.9`
   - If `scan_count == 2`: medium confidence scanned.
     - `page_type = PageType.SCANNED`, `pdf_type = PDFType.SCANNED`, `confidence = 0.7`

6. **Neither text-native nor scanned clearly wins.** Check which has more indicators:
   - If `text_count > scan_count` and `text_count >= 2`: text-native at medium confidence 0.7.
   - If `scan_count > text_count` and `scan_count >= 2`: scanned at medium confidence 0.7.
   - Otherwise: **borderline** -- return `(PageType.MIXED, None, 0.0, signals)`. This triggers Tier 2 escalation.

##### `_evaluate_signals(self, page: PageProfile) -> dict[str, Any]`

Returns a dict of the 6 per-page signal evaluations (signal 7 is document-level, handled in `classify()`):

```python
def _evaluate_signals(self, page: PageProfile) -> dict[str, Any]:
    cfg = self._config
    return {
        "text_length": page.text_length,
        "text_sufficient": page.text_length >= cfg.min_chars_per_page,
        "text_sparse": page.text_length < _MAX_CHARS_FOR_SCANNED,
        "image_coverage_ratio": page.image_coverage_ratio,
        "image_coverage_low": page.image_coverage_ratio < cfg.max_image_coverage_for_text,
        "image_coverage_high": page.image_coverage_ratio > _MIN_IMAGE_COVERAGE_FOR_SCANNED,
        "font_count": page.font_count,
        "fonts_present": page.font_count >= cfg.min_font_count_for_digital,
        "fonts_absent": page.font_count == 0,
        "table_count": page.table_count,
        "has_tables": page.table_count >= cfg.min_table_count_for_complex,
        "is_multi_column": page.is_multi_column,
        "has_form_fields": page.has_form_fields,
    }
```

This provides full transparency for debugging and signal tracing without logging raw content.

---

### 2. `packages/ingestkit-pdf/tests/conftest.py` (modify existing)

Add two helper factory functions (module-level, not fixtures -- following Excel pattern):

#### `_make_page_profile(**overrides) -> PageProfile`

Builds a `PageProfile` with sensible text-native defaults:

```python
def _make_page_profile(**overrides: object) -> PageProfile:
    defaults = dict(
        page_number=1,
        text_length=500,
        word_count=80,
        image_count=0,
        image_coverage_ratio=0.05,
        table_count=0,
        font_count=3,
        font_names=["Arial", "Arial-Bold", "TimesNewRoman"],
        has_form_fields=False,
        is_multi_column=False,
        page_type=PageType.TEXT,
        extraction_quality=ExtractionQuality(
            printable_ratio=0.95,
            avg_words_per_page=80.0,
            pages_with_text=1,
            total_pages=1,
            extraction_method="pdfplumber",
        ),
    )
    defaults.update(overrides)
    return PageProfile(**defaults)
```

#### `_make_document_profile(pages, **overrides) -> DocumentProfile`

Builds a `DocumentProfile` from a list of `PageProfile` objects:

```python
def _make_document_profile(
    pages: list[PageProfile], **overrides: object
) -> DocumentProfile:
    from collections import Counter
    type_dist = dict(Counter(p.page_type.value for p in pages))
    defaults = dict(
        file_path="/tmp/test.pdf",
        file_size_bytes=50000,
        page_count=len(pages),
        content_hash="a" * 64,
        metadata=DocumentMetadata(),
        pages=pages,
        page_type_distribution=type_dist,
        detected_languages=["en"],
        has_toc=False,
        overall_quality=ExtractionQuality(
            printable_ratio=0.95,
            avg_words_per_page=80.0,
            pages_with_text=len(pages),
            total_pages=len(pages),
            extraction_method="pdfplumber",
        ),
        security_warnings=[],
    )
    defaults.update(overrides)
    return DocumentProfile(**defaults)
```

**Note**: These helpers will be defined in `test_inspector.py` (following the Excel test pattern where `_make_sheet_profile` and `_make_file_profile` are local to the test file, NOT in conftest). The `conftest.py` will only get shared fixtures (config, inspector).

Add to `conftest.py`:

```python
import pytest
from ingestkit_pdf.config import PDFProcessorConfig
from ingestkit_pdf.inspector import PDFInspector

@pytest.fixture()
def pdf_config() -> PDFProcessorConfig:
    return PDFProcessorConfig()

@pytest.fixture()
def pdf_inspector(pdf_config: PDFProcessorConfig) -> PDFInspector:
    return PDFInspector(pdf_config)
```

---

### 3. `packages/ingestkit-pdf/tests/test_inspector.py` (~600 lines)

#### Module Setup

```python
"""Tests for the PDFInspector Tier 1 rule-based classifier.

Covers per-page signal evaluation, per-page classification (text-native,
scanned, complex, borderline), document-level aggregation (agreement,
disagreement), special page handling (blank, TOC, vector-only),
inconclusive escalation, edge cases, result field validation,
custom configs, and boundary values.
"""

from __future__ import annotations

import pytest

from ingestkit_pdf.config import PDFProcessorConfig
from ingestkit_pdf.inspector import PDFInspector
from ingestkit_pdf.models import (
    ClassificationResult,
    ClassificationTier,
    DocumentMetadata,
    DocumentProfile,
    ExtractionQuality,
    PageProfile,
    PageType,
    PDFType,
)
```

#### Helper Functions

`_make_page_profile(**overrides)` and `_make_document_profile(pages, **overrides)` as described above, local to the test file.

Also create convenience helpers for common page archetypes:

```python
def _text_native_page(page_number: int = 1, **overrides) -> PageProfile:
    """Page with strong text-native signals."""
    return _make_page_profile(
        page_number=page_number,
        text_length=500, image_coverage_ratio=0.05,
        font_count=3, table_count=0,
        is_multi_column=False, has_form_fields=False,
        page_type=PageType.TEXT,
        **overrides,
    )

def _scanned_page(page_number: int = 1, **overrides) -> PageProfile:
    """Page with strong scanned signals."""
    return _make_page_profile(
        page_number=page_number,
        text_length=10, image_coverage_ratio=0.95,
        font_count=0, table_count=0,
        is_multi_column=False, has_form_fields=False,
        page_type=PageType.SCANNED,
        **overrides,
    )

def _complex_page(page_number: int = 1, **overrides) -> PageProfile:
    """Page with complex signals (tables + multi-column)."""
    return _make_page_profile(
        page_number=page_number,
        text_length=300, image_coverage_ratio=0.1,
        font_count=4, table_count=3,
        is_multi_column=True, has_form_fields=False,
        page_type=PageType.TABLE_HEAVY,
        **overrides,
    )

def _blank_page(page_number: int = 1) -> PageProfile:
    """Blank page."""
    return _make_page_profile(
        page_number=page_number,
        text_length=0, word_count=0, image_count=0,
        image_coverage_ratio=0.0, font_count=0,
        table_count=0, is_multi_column=False,
        has_form_fields=False, page_type=PageType.BLANK,
    )
```

#### Test Class: `TestPerPageSignalEvaluation`

Tests that `_evaluate_signals()` returns correct boolean/numeric values for each signal.

| Test Method | What It Tests |
|------------|---------------|
| `test_text_sufficient_true` | `text_length=500` >= 200 -> `text_sufficient=True` |
| `test_text_sufficient_false` | `text_length=100` < 200 -> `text_sufficient=False` |
| `test_text_sparse_true` | `text_length=30` < 50 -> `text_sparse=True` |
| `test_text_sparse_false` | `text_length=100` >= 50 -> `text_sparse=False` |
| `test_image_coverage_low_true` | `image_coverage_ratio=0.1` < 0.3 -> `image_coverage_low=True` |
| `test_image_coverage_low_false` | `image_coverage_ratio=0.5` >= 0.3 -> `image_coverage_low=False` |
| `test_image_coverage_high_true` | `image_coverage_ratio=0.8` > 0.7 -> `image_coverage_high=True` |
| `test_image_coverage_high_false` | `image_coverage_ratio=0.5` <= 0.7 -> `image_coverage_high=False` |
| `test_fonts_present_true` | `font_count=3` >= 1 -> `fonts_present=True` |
| `test_fonts_present_false` | `font_count=0` < 1 -> `fonts_present=False` |
| `test_fonts_absent_true` | `font_count=0` -> `fonts_absent=True` |
| `test_fonts_absent_false` | `font_count=1` -> `fonts_absent=False` |
| `test_has_tables_true` | `table_count=2` >= 1 -> `has_tables=True` |
| `test_has_tables_false` | `table_count=0` < 1 -> `has_tables=False` |
| `test_is_multi_column` | `is_multi_column=True/False` passthrough |
| `test_has_form_fields` | `has_form_fields=True/False` passthrough |
| `test_raw_values_included` | Signals dict includes raw `text_length`, `image_coverage_ratio`, `font_count`, `table_count` |

#### Test Class: `TestPerPageClassification`

Tests `_classify_page()` for each archetype.

| Test Method | Input | Expected |
|------------|-------|----------|
| `test_text_native_all_3_signals_high_confidence` | text=500, img=0.05, fonts=3, tables=0, no multi-col, no forms | `(TEXT, TEXT_NATIVE, 0.9)` |
| `test_text_native_2_of_3_signals_medium_confidence` | text=500, img=0.05, fonts=0, tables=0 | `(TEXT, TEXT_NATIVE, 0.7)` |
| `test_scanned_all_3_signals_high_confidence` | text=10, img=0.95, fonts=0, tables=0, no multi-col, no forms | `(SCANNED, SCANNED, 0.9)` |
| `test_scanned_2_of_3_signals_medium_confidence` | text=10, img=0.95, fonts=1, tables=0 | `(SCANNED, SCANNED, 0.7)` |
| `test_complex_tables_only` | text=500, tables=3, no multi-col, no forms | `(TABLE_HEAVY, COMPLEX, 0.7)` (1 complex indicator) |
| `test_complex_tables_and_multi_column` | text=500, tables=3, multi-col=True | `(TABLE_HEAVY, COMPLEX, 0.9)` (2 complex indicators) |
| `test_complex_form_fields` | text=500, has_form_fields=True | `(FORM, COMPLEX, 0.7)` |
| `test_complex_all_three_indicators` | tables=2, multi-col=True, forms=True | `(FORM, COMPLEX, 0.9)` |
| `test_complex_takes_priority_over_text_native` | text=500, img=0.05, fonts=3, tables=2 | `(TABLE_HEAVY, COMPLEX, ...)` -- complex check runs first |
| `test_borderline_returns_none_pdf_type` | text=100 (neither >=200 nor <50), img=0.4, fonts=1, tables=0 | `(MIXED, None, 0.0)` |

#### Test Class: `TestSpecialPages`

Tests that blank, TOC, and vector-only pages are handled correctly.

| Test Method | What It Tests |
|------------|---------------|
| `test_blank_page_skipped_in_classification` | Single blank page -> document inconclusive (all pages skippable) |
| `test_blank_page_among_text_pages` | 2 text-native + 1 blank -> `TEXT_NATIVE` (blank doesn't affect) |
| `test_toc_page_skipped` | 2 text-native + 1 TOC -> `TEXT_NATIVE` |
| `test_vector_only_page_skipped` | 2 text-native + 1 vector-only -> `TEXT_NATIVE` |
| `test_all_pages_skippable` | 3 blank pages -> inconclusive |
| `test_per_page_types_include_special_pages` | Blank/TOC pages appear in `per_page_types` even though they're skipped for aggregation |

#### Test Class: `TestDocumentLevelAgreement`

Tests when all non-skippable pages agree.

| Test Method | What It Tests |
|------------|---------------|
| `test_all_pages_text_native` | 3 text-native pages -> `TEXT_NATIVE` |
| `test_all_pages_scanned` | 3 scanned pages -> `SCANNED` |
| `test_all_pages_complex` | 3 complex pages -> `COMPLEX` |
| `test_single_page_text_native` | 1 text-native page -> `TEXT_NATIVE` |
| `test_confidence_is_minimum_across_pages` | Mix of high/medium confidence text-native pages -> confidence = min |

#### Test Class: `TestDocumentLevelDisagreement`

Tests when non-skippable pages disagree (should become COMPLEX).

| Test Method | What It Tests |
|------------|---------------|
| `test_text_and_scanned_pages_produce_complex` | 2 text-native + 1 scanned -> `COMPLEX` |
| `test_text_and_complex_pages_produce_complex` | 2 text-native + 1 complex -> `COMPLEX` |
| `test_scanned_and_complex_pages_produce_complex` | 2 scanned + 1 complex -> `COMPLEX` |
| `test_disagreement_confidence_is_high` | Mixed pages -> confidence 0.9 |
| `test_disagreement_reasoning_describes_mix` | Reasoning mentions the different types found |
| `test_per_page_types_populated_on_disagreement` | All pages listed in `per_page_types` |

#### Test Class: `TestInconclusiveEscalation`

Tests that borderline pages trigger inconclusive results for Tier 2 escalation.

| Test Method | What It Tests |
|------------|---------------|
| `test_borderline_page_produces_zero_confidence` | Page with ambiguous signals -> confidence 0.0 |
| `test_borderline_among_clear_pages` | 2 clear text-native + 1 borderline -> whole document inconclusive |
| `test_inconclusive_reasoning_mentions_page` | Reasoning identifies which page is borderline |

#### Test Class: `TestEmptyProfile`

| Test Method | What It Tests |
|------------|---------------|
| `test_no_pages_returns_inconclusive` | `page_count=0`, empty pages list -> confidence 0.0 |
| `test_empty_pages_list_returns_inconclusive` | Non-zero `page_count` but empty `pages` list -> confidence 0.0 |
| `test_inconclusive_reasoning_mentions_no_pages` | Reasoning contains "no pages" |

#### Test Class: `TestClassificationResultFields`

| Test Method | What It Tests |
|------------|---------------|
| `test_tier_used_is_always_rule_based` | `tier_used == ClassificationTier.RULE_BASED` for all results |
| `test_signals_dict_populated` | `signals` is not None, contains `"per_page"` key with expected structure |
| `test_per_page_types_always_populated` | Every page number appears in `per_page_types` (unlike Excel which only populates on hybrid) |
| `test_reasoning_is_non_empty_string` | `reasoning` is a non-empty str |
| `test_pdf_type_uses_enum_values` | `result.pdf_type.value` is one of `"text_native"`, `"scanned"`, `"complex"` |
| `test_degraded_is_always_false` | Tier 1 never sets `degraded=True` |

#### Test Class: `TestCustomConfig`

| Test Method | What It Tests |
|------------|---------------|
| `test_custom_min_chars_per_page` | `min_chars_per_page=500`, page with 300 chars -> not text-native |
| `test_custom_max_image_coverage_for_text` | `max_image_coverage_for_text=0.1`, page with 0.2 coverage -> not text-native |
| `test_custom_min_font_count` | `min_font_count_for_digital=3`, page with 2 fonts -> not text-native |
| `test_custom_min_table_count_for_complex` | `min_table_count_for_complex=3`, page with 2 tables -> not complex |

#### Test Class: `TestBoundaryValues`

| Test Method | What It Tests |
|------------|---------------|
| `test_text_length_exactly_at_min_chars` | `text_length=200` (== `min_chars_per_page`) -> `text_sufficient=True` |
| `test_text_length_one_below_min_chars` | `text_length=199` -> `text_sufficient=False` |
| `test_text_length_exactly_at_scanned_max` | `text_length=50` -> `text_sparse=False` (< 50 is threshold, 50 is NOT sparse) |
| `test_text_length_one_below_scanned_max` | `text_length=49` -> `text_sparse=True` |
| `test_image_coverage_exactly_at_text_max` | `image_coverage_ratio=0.3` -> `image_coverage_low=False` (< 0.3 is threshold, 0.3 is NOT low) |
| `test_image_coverage_exactly_at_scanned_min` | `image_coverage_ratio=0.7` -> `image_coverage_high=False` (> 0.7 is threshold, 0.7 is NOT high) |
| `test_font_count_exactly_at_threshold` | `font_count=1` -> `fonts_present=True` |
| `test_table_count_exactly_at_threshold` | `table_count=1` -> `has_tables=True` |

#### Test Class: `TestConfidenceCalculation`

| Test Method | What It Tests |
|------------|---------------|
| `test_high_confidence_text_native` | All 3 text signals match -> 0.9 |
| `test_medium_confidence_text_native` | 2 of 3 text signals match -> 0.7 |
| `test_high_confidence_scanned` | All 3 scanned signals match -> 0.9 |
| `test_medium_confidence_scanned` | 2 of 3 scanned signals match -> 0.7 |
| `test_high_confidence_complex` | 2+ complex indicators -> 0.9 |
| `test_medium_confidence_complex` | 1 complex indicator -> 0.7 |
| `test_document_confidence_is_page_minimum` | Pages with 0.9 and 0.7 -> document confidence 0.7 |
| `test_borderline_confidence_is_zero` | Ambiguous signals -> 0.0 |

---

## Decision Summary

| # | Decision | Choice | Rationale |
|---|----------|--------|-----------|
| 1 | Three-way per-page logic | Check complex first, then text-native, then scanned, then borderline | Complex indicators (tables/forms/multi-col) are definitive and should override text/scanned signals |
| 2 | Scanned thresholds | Module-level constants (`_MAX_CHARS_FOR_SCANNED=50`, `_MIN_IMAGE_COVERAGE_FOR_SCANNED=0.7`) | SPEC does not list as configurable; avoids changing config.py |
| 3 | Confidence model | Per-page: 0.9 (all indicators), 0.7 (2+ indicators), 0.0 (borderline). Per-document: min of page confidences | Follows Excel pattern adapted for three-way |
| 4 | Special pages | Blank/TOC/vector-only detected via `page.page_type`, excluded from aggregation | Prevents non-content pages from skewing classification |
| 5 | per_page_types population | Always populated for all pages | SPEC implies full page-level visibility; downstream consumers need it |
| 6 | Complex priority in page classification | Complex check runs BEFORE text-native/scanned checks | A page with tables AND text should be classified as complex, not text-native |
| 7 | Helper location | Factory helpers in test file (not conftest) | Follows Excel test pattern; conftest only has shared fixtures |

## Acceptance Criteria

- [ ] `PDFInspector` class in `inspector.py` with `__init__(config)` and `classify(profile)` public API
- [ ] 7 per-page signals evaluated per SPEC section 9.2
- [ ] Three-way per-page classification: text-native, scanned, complex
- [ ] Borderline pages produce confidence 0.0 for Tier 2 escalation
- [ ] Document-level aggregation: agreement -> that type, disagreement -> complex
- [ ] Special pages (blank, TOC, vector-only) excluded from aggregation
- [ ] `ClassificationResult` fully populated: pdf_type, confidence, tier_used, reasoning, per_page_types, signals
- [ ] `tier_used` always `ClassificationTier.RULE_BASED`
- [ ] `degraded` always `False`
- [ ] PII-safe logging (logger name `ingestkit_pdf`, no raw page content)
- [ ] All configurable thresholds sourced from `PDFProcessorConfig`
- [ ] Unit tests cover all 11 test classes with full method coverage
- [ ] All tests pass with `pytest packages/ingestkit-pdf/tests/test_inspector.py -v`
- [ ] No imports from concrete backends
- [ ] No ABC usage -- structural subtyping only

## Verification Gates for PROVE

1. `pytest packages/ingestkit-pdf/tests/test_inspector.py -v` -- all tests pass
2. `pytest packages/ingestkit-pdf/tests/test_inspector.py --cov=ingestkit_pdf.inspector --cov-report=term-missing` -- 100% coverage of `inspector.py`
3. Verify no concrete backend imports in `inspector.py`
4. Verify logger name is `"ingestkit_pdf"`
5. Verify no raw page content in log statements (only page numbers, signal values, classification results)

AGENT_RETURN: .agents/outputs/plan-28-021426.md
