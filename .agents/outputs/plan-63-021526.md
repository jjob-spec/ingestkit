---
issue: 63
title: "Implement native PDF form field extraction"
agent: plan
timestamp: 2026-02-15
status: complete
branch: feature/issue-63-native-pdf-extractor
complexity: COMPLEX
stack: backend
files_to_modify:
  - packages/ingestkit-forms/src/ingestkit_forms/extractors/native_pdf.py
  - packages/ingestkit-forms/src/ingestkit_forms/extractors/__init__.py
  - packages/ingestkit-forms/tests/conftest.py
  - packages/ingestkit-forms/tests/test_extractors.py
---

# PLAN: Issue #63 -- Native PDF Form Field Extraction

## Executive Summary

Implement `NativePDFExtractor` in `extractors/native_pdf.py` that extracts form field values from fillable PDFs via the injected `PDFWidgetBackend` protocol. The class matches PDF widgets to template `FieldMapping` regions using IoU (Intersection over Union) scoring, coerces widget values to the expected `FieldType`, validates against regex patterns, and falls back to per-field OCR when no widget match is found. Flattened PDFs (zero widgets) are detected and signaled via `W_FORM_FIELDS_FLATTENED`. All 16 test cases use a `MockPDFWidgetBackend` -- no external services required.

---

## File 1: `extractors/native_pdf.py` (REWRITE stub)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/extractors/native_pdf.py`

### 1.1 Imports and Module Setup

```python
"""NativePDFExtractor: fillable PDF form field extraction.

Extracts values from fillable PDF form widgets using the PDFWidgetBackend
protocol. Supports text fields, checkboxes, radio buttons, dropdowns,
and signature fields (spec section 7.1).
"""

from __future__ import annotations

import logging
import re
from collections import defaultdict

from ingestkit_forms.config import FormProcessorConfig
from ingestkit_forms.errors import FormErrorCode
from ingestkit_forms.models import (
    BoundingBox,
    ExtractedField,
    FieldMapping,
    FieldType,
    FormTemplate,
)
from ingestkit_forms.protocols import OCRBackend, PDFWidgetBackend, WidgetField

logger = logging.getLogger(__name__)
```

### 1.2 Class Definition and Constructor

```python
class NativePDFExtractor:
    """Extracts form field values from fillable PDFs using widget matching.

    Uses the injected PDFWidgetBackend to read form widgets, matches them
    to template FieldMapping regions via IoU scoring, and validates/coerces
    extracted values. Falls back to per-field OCR when available.
    """

    def __init__(
        self,
        pdf_backend: PDFWidgetBackend,
        config: FormProcessorConfig,
        ocr_backend: OCRBackend | None = None,
    ) -> None:
        self._pdf_backend = pdf_backend
        self._config = config
        self._ocr_backend = ocr_backend
```

**Key decisions:**
- `pdf_backend` is required (Protocol, not concrete)
- `ocr_backend` is optional -- when `None`, unmatched fields get `value=None`
- `config` provides `native_pdf_iou_threshold` (default 0.5) and `form_extraction_min_field_confidence` (default 0.5)

### 1.3 Public Method: `extract()`

```python
def extract(
    self,
    file_path: str,
    template: FormTemplate,
) -> list[ExtractedField]:
    """Extract form field values from a fillable PDF.

    Algorithm (spec section 7.1):
        1. Check has_form_fields(); if False -> return empty list + W_FORM_FIELDS_FLATTENED
        2. Group template fields by page_number
        3. For each page: extract widgets, match to fields by IoU
        4. Validate and coerce values
        5. Return list[ExtractedField]
    """
```

**Step-by-step logic:**

1. **Flattened form detection:**
   ```python
   if not self._pdf_backend.has_form_fields(file_path):
       logger.warning("PDF has no form fields (flattened): %s", file_path)
       return []  # Caller receives empty list; caller checks and routes to OCR
   ```
   The caller (FormProcessor orchestrator) is responsible for detecting the empty return and emitting `W_FORM_FIELDS_FLATTENED`. However, the extractor also returns a **warning string** in the `warnings` field of each `ExtractedField` when relevant. Since the spec says "emit W_FORM_FIELDS_FLATTENED warning", and we return an empty list, the caller must check `len(results) == 0` and handle accordingly.

   **Revised approach:** Return a single sentinel `ExtractedField` is wrong -- the spec says return empty list. The warning propagation happens at the caller level. The extractor logs the warning.

2. **Group fields by page:**
   ```python
   fields_by_page: dict[int, list[FieldMapping]] = defaultdict(list)
   for field in template.fields:
       if field.region is not None:  # Skip Excel-only fields
           fields_by_page[field.page_number].append(field)
   ```

3. **Per-page extraction loop:**
   ```python
   results: list[ExtractedField] = []
   for page_num, page_fields in sorted(fields_by_page.items()):
       widgets = self._pdf_backend.extract_widgets(file_path, page_num)
       for field_mapping in page_fields:
           extracted = self._match_and_extract(field_mapping, widgets, file_path)
           results.append(extracted)
   return results
   ```

### 1.4 Private Method: `_match_and_extract()`

```python
def _match_and_extract(
    self,
    field: FieldMapping,
    widgets: list[WidgetField],
    file_path: str,
) -> ExtractedField:
    """Match a single template field to the best-overlapping widget."""
```

**Logic:**

1. Compute IoU between `field.region` and each widget's `bbox`.
2. Select best widget where IoU >= `self._config.native_pdf_iou_threshold`.
3. If multiple widgets match, pick highest IoU.

**If matched:**
```python
raw_value = best_widget.field_value
coerced_value = self._coerce_widget_value(raw_value, field.field_type, best_widget.field_type)
value, validation_passed, warnings = self._validate_field_value(coerced_value, field)
return ExtractedField(
    field_id=field.field_id,
    field_name=field.field_name,
    field_label=field.field_label,
    field_type=field.field_type,
    value=value,
    raw_value=raw_value,
    confidence=0.95,
    extraction_method="native_fields",
    bounding_box=best_widget.bbox,
    validation_passed=validation_passed,
    warnings=warnings,
)
```

**If not matched (no widget above IoU threshold):**
- If `self._ocr_backend` is available: attempt OCR for this field region. This is a stub call -- the actual OCR integration needs the rendered page image which is not available here. For now, set `extraction_method="native_fields_with_ocr_fallback"` and `value=None`, `confidence=0.0`.
  - **Design note:** Full OCR fallback requires page rendering (which `PDFWidgetBackend` does not provide). The per-field OCR fallback within `NativePDFExtractor` is a placeholder that signals the intent. The real OCR path will be completed when the `OCROverlayExtractor` (issue TBD) is implemented. For now, unmatched fields with `ocr_backend` present get `extraction_method="native_fields_with_ocr_fallback"`, `value=None`, `confidence=0.0`.
- If no `ocr_backend`: `value=None`, `confidence=0.0`, `extraction_method="native_fields"`.

```python
return ExtractedField(
    field_id=field.field_id,
    field_name=field.field_name,
    field_label=field.field_label,
    field_type=field.field_type,
    value=None,
    raw_value=None,
    confidence=0.0,
    extraction_method=(
        "native_fields_with_ocr_fallback"
        if self._ocr_backend is not None
        else "native_fields"
    ),
    bounding_box=field.region,
    validation_passed=None,
    warnings=[FormErrorCode.W_FORM_FIELD_LOW_CONFIDENCE.value],
)
```

### 1.5 Static Method: `_compute_iou()`

```python
@staticmethod
def _compute_iou(box_a: BoundingBox, box_b: BoundingBox) -> float:
    """Compute Intersection over Union for two axis-aligned bounding boxes.

    Both boxes use normalized (0.0-1.0) coordinates with (x, y) as top-left.
    """
```

**Algorithm:**
```python
# Convert (x, y, width, height) -> (x1, y1, x2, y2)
a_x1, a_y1 = box_a.x, box_a.y
a_x2, a_y2 = box_a.x + box_a.width, box_a.y + box_a.height

b_x1, b_y1 = box_b.x, box_b.y
b_x2, b_y2 = box_b.x + box_b.width, box_b.y + box_b.height

# Intersection
inter_x1 = max(a_x1, b_x1)
inter_y1 = max(a_y1, b_y1)
inter_x2 = min(a_x2, b_x2)
inter_y2 = min(a_y2, b_y2)

inter_width = max(0.0, inter_x2 - inter_x1)
inter_height = max(0.0, inter_y2 - inter_y1)
inter_area = inter_width * inter_height

# Union
area_a = box_a.width * box_a.height
area_b = box_b.width * box_b.height
union_area = area_a + area_b - inter_area

if union_area == 0.0:
    return 0.0
return inter_area / union_area
```

### 1.6 Static Method: `_coerce_widget_value()`

```python
@staticmethod
def _coerce_widget_value(
    raw_value: str | None,
    field_type: FieldType,
    widget_type: str,
) -> str | bool | float | None:
    """Coerce a raw PDF widget value to the expected FieldType.

    Args:
        raw_value: String value from the PDF widget (may be None for empty fields).
        field_type: Expected type from the template FieldMapping.
        widget_type: Widget's own type string ("text", "checkbox", "radio", etc.).
    """
```

**Coercion rules:**

| `field_type` | Logic |
|---|---|
| `TEXT` | Return `raw_value` as-is (string or None) |
| `DATE` | Return `raw_value` as-is (string; validation_pattern handles format) |
| `NUMBER` | Attempt `float(raw_value)`. On `ValueError`/`TypeError` -> return `raw_value` (validation will catch it) |
| `CHECKBOX` | Map truthy values: `raw_value` in `{"Yes", "On", "true", "1", "True"}` -> `True`, else `False`. If `raw_value is None` -> `False` |
| `RADIO` | Same truthy mapping as CHECKBOX (radio widget values are typically "Yes"/"Off") |
| `DROPDOWN` | Return `raw_value` as-is (string) |
| `SIGNATURE` | `True` if `raw_value` is not None and not empty, else `False` |

```python
if raw_value is None:
    if field_type in (FieldType.CHECKBOX, FieldType.RADIO, FieldType.SIGNATURE):
        return False
    return None

if field_type == FieldType.NUMBER:
    try:
        return float(raw_value)
    except (ValueError, TypeError):
        return raw_value  # Let validation catch it

if field_type in (FieldType.CHECKBOX, FieldType.RADIO):
    return raw_value.lower() in {"yes", "on", "true", "1"}

if field_type == FieldType.SIGNATURE:
    return bool(raw_value.strip())

# TEXT, DATE, DROPDOWN
return raw_value
```

### 1.7 Static Method: `_validate_field_value()`

```python
@staticmethod
def _validate_field_value(
    value: str | bool | float | None,
    field: FieldMapping,
) -> tuple[str | bool | float | None, bool | None, list[str]]:
    """Validate an extracted value against field constraints.

    Returns:
        (possibly_adjusted_value, validation_passed, warnings)
        - validation_passed: True if passed, False if failed, None if no pattern
        - If validation fails: value is kept (not nulled), warning is appended
    """
```

**Logic:**

1. If `field.validation_pattern` is None -> `(value, None, [])`
2. If `value` is None -> `(None, None, [])` (nothing to validate)
3. If value is bool -> convert to string for regex matching ("True"/"False")
4. Try `re.fullmatch(field.validation_pattern, str(value))`:
   - Match -> `(value, True, [])`
   - No match -> `(value, False, [FormErrorCode.W_FORM_FIELD_VALIDATION_FAILED.value])`
5. If regex itself is invalid (`re.error`) -> `(value, None, [f"Invalid validation pattern: {field.validation_pattern}"])`

**Key decision:** Validation failure does NOT null the value. The spec says "validate extracted values" but doesn't specify nulling on failure. We keep the value and set `validation_passed=False` with a warning. The caller decides policy.

---

## File 2: `extractors/__init__.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/src/ingestkit_forms/extractors/__init__.py`

**Change:** Add export of `NativePDFExtractor`.

```python
"""Form field extractors.

Subpackage containing extraction backends:
- native_pdf: PyMuPDF-based form widget extraction
- ocr_overlay: Template overlay + per-field OCR extraction
- excel_cell: openpyxl cell value mapping extraction
"""

from ingestkit_forms.extractors.native_pdf import NativePDFExtractor

__all__ = ["NativePDFExtractor"]
```

---

## File 3: `tests/conftest.py` (MODIFY)

**Full path:** `packages/ingestkit-forms/tests/conftest.py`

### 3.1 Replace `form_config` fixture

```python
from ingestkit_forms.config import FormProcessorConfig

@pytest.fixture()
def form_config():
    """Return a FormProcessorConfig with all defaults."""
    return FormProcessorConfig()
```

### 3.2 Implement `MockPDFWidgetBackend`

```python
from ingestkit_forms.models import BoundingBox
from ingestkit_forms.protocols import WidgetField


class MockPDFWidgetBackend:
    """Mock PDFWidgetBackend for testing NativePDFExtractor.

    Configurable via constructor: set widgets per page, and whether
    the PDF has form fields at all.
    """

    def __init__(
        self,
        widgets_by_page: dict[int, list[WidgetField]] | None = None,
        has_fields: bool = True,
    ) -> None:
        self._widgets_by_page = widgets_by_page or {}
        self._has_fields = has_fields

    def extract_widgets(self, file_path: str, page: int) -> list[WidgetField]:
        return self._widgets_by_page.get(page, [])

    def has_form_fields(self, file_path: str) -> bool:
        return self._has_fields

    def engine_name(self) -> str:
        return "mock"
```

### 3.3 Implement `MockOCRBackend`

```python
from ingestkit_forms.protocols import OCRRegionResult


class MockOCRBackend:
    """Mock OCRBackend for testing OCR fallback paths."""

    def __init__(self, default_text: str = "", default_confidence: float = 0.7) -> None:
        self._default_text = default_text
        self._default_confidence = default_confidence

    def ocr_region(
        self,
        image_bytes: bytes,
        language: str = "en",
        config: str | None = None,
        timeout: float | None = None,
    ) -> OCRRegionResult:
        return OCRRegionResult(
            text=self._default_text,
            confidence=self._default_confidence,
            char_confidences=None,
            engine="mock",
        )

    def engine_name(self) -> str:
        return "mock"
```

### 3.4 Replace `mock_pdf_widget_backend` fixture

```python
@pytest.fixture()
def mock_pdf_widget_backend():
    """Mock PDFWidgetBackend with no widgets (override in tests)."""
    return MockPDFWidgetBackend()
```

### 3.5 Factory Helpers

```python
from ingestkit_forms.models import FieldMapping, FieldType, FormTemplate, SourceFormat


def make_widget(
    field_name: str = "field_1",
    field_value: str | None = "some value",
    field_type: str = "text",
    x: float = 0.1,
    y: float = 0.1,
    width: float = 0.3,
    height: float = 0.05,
    page: int = 0,
) -> WidgetField:
    """Factory for WidgetField test instances."""
    return WidgetField(
        field_name=field_name,
        field_value=field_value,
        field_type=field_type,
        bbox=BoundingBox(x=x, y=y, width=width, height=height),
        page=page,
    )


def make_field_mapping(
    field_name: str = "employee_name",
    field_label: str = "Employee Name",
    field_type: FieldType = FieldType.TEXT,
    page_number: int = 0,
    x: float = 0.1,
    y: float = 0.1,
    width: float = 0.3,
    height: float = 0.05,
    validation_pattern: str | None = None,
    required: bool = False,
    options: list[str] | None = None,
) -> FieldMapping:
    """Factory for FieldMapping test instances."""
    return FieldMapping(
        field_name=field_name,
        field_label=field_label,
        field_type=field_type,
        page_number=page_number,
        region=BoundingBox(x=x, y=y, width=width, height=height),
        validation_pattern=validation_pattern,
        required=required,
        options=options,
    )


def make_template(
    fields: list[FieldMapping] | None = None,
    name: str = "Test Template",
    source_format: SourceFormat = SourceFormat.PDF,
    page_count: int = 1,
) -> FormTemplate:
    """Factory for FormTemplate test instances."""
    if fields is None:
        fields = [make_field_mapping()]
    return FormTemplate(
        name=name,
        source_format=source_format,
        page_count=page_count,
        fields=fields,
    )
```

---

## File 4: `tests/test_extractors.py` (REWRITE stub)

**Full path:** `packages/ingestkit-forms/tests/test_extractors.py`

All tests are `@pytest.mark.unit`. Import `NativePDFExtractor` from `ingestkit_forms.extractors`. Import factories from `conftest` (they are module-level functions, imported directly).

### Test Matrix (16 tests)

| # | Test Function | What It Validates | Key Assertions |
|---|---|---|---|
| 1 | `test_extract_text_field_exact_match` | Widget bbox exactly matches template field region | `value == "John Doe"`, `confidence == 0.95`, `extraction_method == "native_fields"` |
| 2 | `test_extract_text_field_iou_above_threshold` | Widget overlaps >= 50% IoU with template field | Same as #1 but with offset bboxes |
| 3 | `test_extract_text_field_iou_below_threshold` | Widget overlaps < 50% IoU -- no match | `value is None`, `confidence == 0.0`, warning contains `W_FORM_FIELD_LOW_CONFIDENCE` |
| 4 | `test_extract_checkbox_checked` | Checkbox widget value "Yes" -> `True` | `value is True`, `field_type == FieldType.CHECKBOX` |
| 5 | `test_extract_checkbox_unchecked` | Checkbox widget value "Off" -> `False` | `value is False` |
| 6 | `test_extract_radio_button` | Radio widget value "Yes" -> `True` | `value is True`, `field_type == FieldType.RADIO` |
| 7 | `test_extract_dropdown` | Dropdown widget returns string value | `value == "Full-Time"`, `field_type == FieldType.DROPDOWN` |
| 8 | `test_extract_number_field_coercion` | String "42.5" coerced to `float` | `value == 42.5`, `isinstance(value, float)` |
| 9 | `test_flattened_form_detection` | `has_form_fields()` returns False -> empty list | `len(results) == 0` |
| 10 | `test_validation_pattern_pass` | Value matches regex -> `validation_passed=True` | `validation_passed is True`, `warnings == []` |
| 11 | `test_validation_pattern_fail` | Value fails regex -> `validation_passed=False` + warning | `validation_passed is False`, `W_FORM_FIELD_VALIDATION_FAILED` in warnings |
| 12 | `test_multiple_fields_multiple_pages` | Template with fields on pages 0 and 1 | `len(results) == 2`, each from correct page |
| 13 | `test_no_ocr_backend_unmatched_field` | No OCR backend; unmatched field -> `value=None` | `extraction_method == "native_fields"`, `value is None` |
| 14 | `test_configurable_iou_threshold` | Custom threshold 0.8 changes matching | Same overlap that passes at 0.5 fails at 0.8 |
| 15 | `test_iou_computation_direct` | Unit test of `_compute_iou()` with known boxes | Exact IoU values for: identical boxes (1.0), no overlap (0.0), partial overlap (known value), one box inside other |
| 16 | `test_extraction_method_label` | Matched -> `"native_fields"`, OCR fallback -> `"native_fields_with_ocr_fallback"` | Two fields: one matched, one unmatched with OCR backend |

### Detailed Test Implementations

#### Test 1: `test_extract_text_field_exact_match`

```python
@pytest.mark.unit
def test_extract_text_field_exact_match(form_config):
    widget = make_widget(field_name="name", field_value="John Doe", x=0.1, y=0.1, width=0.3, height=0.05)
    backend = MockPDFWidgetBackend(widgets_by_page={0: [widget]})
    field = make_field_mapping(field_name="employee_name", x=0.1, y=0.1, width=0.3, height=0.05)
    template = make_template(fields=[field])

    extractor = NativePDFExtractor(pdf_backend=backend, config=form_config)
    results = extractor.extract("/fake/form.pdf", template)

    assert len(results) == 1
    assert results[0].value == "John Doe"
    assert results[0].confidence == 0.95
    assert results[0].extraction_method == "native_fields"
    assert results[0].field_name == "employee_name"
```

#### Test 2: `test_extract_text_field_iou_above_threshold`

Use template field at (0.1, 0.1, 0.3, 0.05) and widget at (0.12, 0.1, 0.3, 0.05). These share significant overlap. IoU = intersection / union. Intersection width = min(0.4, 0.42) - max(0.1, 0.12) = 0.40 - 0.12 = 0.28. Heights identical. Inter area = 0.28 * 0.05 = 0.014. Union = 2*(0.3*0.05) - 0.014 = 0.030 - 0.014 = 0.016. IoU = 0.014/0.016 = 0.875 > 0.5. Match succeeds.

```python
@pytest.mark.unit
def test_extract_text_field_iou_above_threshold(form_config):
    widget = make_widget(field_value="Jane Smith", x=0.12, y=0.1, width=0.3, height=0.05)
    backend = MockPDFWidgetBackend(widgets_by_page={0: [widget]})
    field = make_field_mapping(x=0.1, y=0.1, width=0.3, height=0.05)
    template = make_template(fields=[field])

    extractor = NativePDFExtractor(pdf_backend=backend, config=form_config)
    results = extractor.extract("/fake/form.pdf", template)

    assert results[0].value == "Jane Smith"
    assert results[0].confidence == 0.95
```

#### Test 3: `test_extract_text_field_iou_below_threshold`

Widget at far-away position (0.7, 0.7). No overlap with template field at (0.1, 0.1). IoU = 0.0 < 0.5.

```python
@pytest.mark.unit
def test_extract_text_field_iou_below_threshold(form_config):
    widget = make_widget(field_value="Won't Match", x=0.7, y=0.7, width=0.2, height=0.05)
    backend = MockPDFWidgetBackend(widgets_by_page={0: [widget]})
    field = make_field_mapping(x=0.1, y=0.1, width=0.3, height=0.05)
    template = make_template(fields=[field])

    extractor = NativePDFExtractor(pdf_backend=backend, config=form_config)
    results = extractor.extract("/fake/form.pdf", template)

    assert results[0].value is None
    assert results[0].confidence == 0.0
    assert FormErrorCode.W_FORM_FIELD_LOW_CONFIDENCE.value in results[0].warnings
```

#### Test 4: `test_extract_checkbox_checked`

```python
@pytest.mark.unit
def test_extract_checkbox_checked(form_config):
    widget = make_widget(field_value="Yes", field_type="checkbox", x=0.1, y=0.2, width=0.05, height=0.05)
    backend = MockPDFWidgetBackend(widgets_by_page={0: [widget]})
    field = make_field_mapping(field_type=FieldType.CHECKBOX, x=0.1, y=0.2, width=0.05, height=0.05)
    template = make_template(fields=[field])

    extractor = NativePDFExtractor(pdf_backend=backend, config=form_config)
    results = extractor.extract("/fake/form.pdf", template)

    assert results[0].value is True
    assert results[0].field_type == FieldType.CHECKBOX
```

#### Test 5: `test_extract_checkbox_unchecked`

Same as #4 but `field_value="Off"`. Assert `value is False`.

#### Test 6: `test_extract_radio_button`

Widget with `field_type="radio"`, `field_value="Yes"`, template field with `FieldType.RADIO`. Assert `value is True`.

#### Test 7: `test_extract_dropdown`

Widget with `field_type="dropdown"`, `field_value="Full-Time"`, template field with `FieldType.DROPDOWN`. Assert `value == "Full-Time"`.

#### Test 8: `test_extract_number_field_coercion`

Widget with `field_value="42.5"`, template field with `FieldType.NUMBER`. Assert `value == 42.5` and `isinstance(value, float)`.

#### Test 9: `test_flattened_form_detection`

```python
@pytest.mark.unit
def test_flattened_form_detection(form_config):
    backend = MockPDFWidgetBackend(has_fields=False)
    template = make_template()

    extractor = NativePDFExtractor(pdf_backend=backend, config=form_config)
    results = extractor.extract("/fake/form.pdf", template)

    assert results == []
```

#### Test 10: `test_validation_pattern_pass`

Field with `validation_pattern=r"^\d{3}-\d{2}-\d{4}$"`. Widget value = `"123-45-6789"`. Assert `validation_passed is True`, `warnings == []`.

#### Test 11: `test_validation_pattern_fail`

Same pattern but widget value = `"not-a-ssn"`. Assert `validation_passed is False`, `W_FORM_FIELD_VALIDATION_FAILED` in warnings.

#### Test 12: `test_multiple_fields_multiple_pages`

Two fields: page 0 field at (0.1, 0.1) and page 1 field at (0.1, 0.3). Two widget pages. Assert `len(results) == 2`, each field extracted from correct page's widgets.

#### Test 13: `test_no_ocr_backend_unmatched_field`

No OCR backend, widget doesn't overlap field. Assert `extraction_method == "native_fields"`, `value is None`.

#### Test 14: `test_configurable_iou_threshold`

Two runs with same geometry: first with default threshold (0.5) -> match; second with threshold 0.8 and slightly offset widget -> no match. Uses `FormProcessorConfig(native_pdf_iou_threshold=0.8)`.

```python
@pytest.mark.unit
def test_configurable_iou_threshold():
    # Widget slightly offset: IoU ~ 0.6 (above 0.5, below 0.8)
    widget = make_widget(field_value="Test", x=0.15, y=0.1, width=0.3, height=0.05)
    backend = MockPDFWidgetBackend(widgets_by_page={0: [widget]})
    field = make_field_mapping(x=0.1, y=0.1, width=0.3, height=0.05)
    template = make_template(fields=[field])

    # Default threshold (0.5) -> match
    config_low = FormProcessorConfig()
    extractor_low = NativePDFExtractor(pdf_backend=backend, config=config_low)
    results_low = extractor_low.extract("/fake/form.pdf", template)
    assert results_low[0].value == "Test"

    # High threshold (0.8) -> no match
    config_high = FormProcessorConfig(native_pdf_iou_threshold=0.8)
    extractor_high = NativePDFExtractor(pdf_backend=backend, config=config_high)
    results_high = extractor_high.extract("/fake/form.pdf", template)
    assert results_high[0].value is None
```

#### Test 15: `test_iou_computation_direct`

```python
@pytest.mark.unit
def test_iou_computation_direct():
    from ingestkit_forms.extractors.native_pdf import NativePDFExtractor

    # Identical boxes -> IoU = 1.0
    box = BoundingBox(x=0.1, y=0.1, width=0.3, height=0.3)
    assert NativePDFExtractor._compute_iou(box, box) == 1.0

    # No overlap -> IoU = 0.0
    box_a = BoundingBox(x=0.0, y=0.0, width=0.1, height=0.1)
    box_b = BoundingBox(x=0.5, y=0.5, width=0.1, height=0.1)
    assert NativePDFExtractor._compute_iou(box_a, box_b) == 0.0

    # 50% overlap in one dimension
    box_c = BoundingBox(x=0.0, y=0.0, width=0.2, height=0.1)
    box_d = BoundingBox(x=0.1, y=0.0, width=0.2, height=0.1)
    # Intersection: (0.1, 0.0) to (0.2, 0.1) = 0.1 * 0.1 = 0.01
    # Union: 0.02 + 0.02 - 0.01 = 0.03
    # IoU = 0.01 / 0.03 = 0.333...
    iou = NativePDFExtractor._compute_iou(box_c, box_d)
    assert abs(iou - 1.0 / 3.0) < 1e-9
```

#### Test 16: `test_extraction_method_label`

Two fields on one page: one matching widget, one not. With OCR backend injected. Assert matched field has `"native_fields"`, unmatched has `"native_fields_with_ocr_fallback"`.

---

## Implementation Order

1. `_compute_iou()` -- pure geometry, zero dependencies
2. `_coerce_widget_value()` -- type conversion, needs only `FieldType` enum
3. `_validate_field_value()` -- regex + type validation
4. `_match_and_extract()` -- composes #1-3
5. `extract()` -- orchestrates page grouping and calling #4
6. Update `extractors/__init__.py` -- export
7. Update `tests/conftest.py` -- mocks and factories
8. Write `tests/test_extractors.py` -- all 16 tests

---

## Acceptance Criteria

- [ ] `NativePDFExtractor` class implemented with `extract()`, `_compute_iou()`, `_coerce_widget_value()`, `_validate_field_value()`, `_match_and_extract()`
- [ ] Constructor takes `PDFWidgetBackend` (required), `FormProcessorConfig` (required), `OCRBackend` (optional)
- [ ] IoU matching uses `config.native_pdf_iou_threshold` (default 0.5)
- [ ] Matched fields: confidence=0.95, method="native_fields"
- [ ] Unmatched fields with OCR backend: method="native_fields_with_ocr_fallback"
- [ ] Unmatched fields without OCR backend: method="native_fields", value=None
- [ ] Flattened PDF detection: empty list returned when `has_form_fields()` is False
- [ ] Widget value coercion: checkbox/radio -> bool, number -> float, text/date/dropdown -> string, signature -> bool
- [ ] Validation via `re.fullmatch()` on `validation_pattern`; invalid regex handled gracefully
- [ ] `extractors/__init__.py` exports `NativePDFExtractor`
- [ ] `MockPDFWidgetBackend` and `MockOCRBackend` in conftest
- [ ] All 16 tests passing with `@pytest.mark.unit`
- [ ] No concrete backend imports inside `native_pdf.py` -- only Protocol types
- [ ] PII-safe logging: no raw field values logged unless `log_sample_data=True`

---

## Risks and Mitigations

| Risk | Mitigation |
|---|---|
| `FieldMapping` validator requires exactly one of `region`/`cell_address` | All test factories use `region` (PDF context). Excel-only fields (cell_address) are skipped in `extract()` |
| `BoundingBox` has `gt=0.0` on width/height (not `ge`) | Factory helpers use 0.05 minimum; tests never create zero-dimension boxes |
| OCR fallback is a placeholder (no page rendering available) | Documented as design note; sets `value=None` and correct `extraction_method` label |
| Multiple widgets matching same field | Select highest IoU; deterministic |

---

AGENT_RETURN: .agents/outputs/plan-63-021526.md
